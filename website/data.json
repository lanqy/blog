{"posts":[{"title":"git 常用命令","description":"git 常用命令","created":"2019/12/27","author":"lanqy","link":"2019/12/27/git-common-commands","htmlDir":"website\\2019\\12\\27\\git-common-commands","htmlFile":"website\\2019\\12\\27\\git-common-commands\\index.html","body":"\n#  git 常用命令\n\n## 解决冲突：\n\n```text\ngit stash\ngit pull origin develop\ngit stash pop\n```\n## 切换分支：\n\n```text\n// 切换到 develop 分支\ngit checkout -b develop \n```\n##  删除分支 \n\n```text\ngit branch -d feature_x\n```\n##  合并分支到你当前的分支\n\n```text\ngit merge <branch>\n```\n##  查看两个分支的差异\n\n```text\ngit diff <source_branch> <target_branch>\n```\n## 提交流程：\n\n```text\ngit add *\n\ngit commit -m \"提交备注\"\n\ngit push origin develop\n```\n## Git回滚代码到某个commit\n\n```text\n$ git reset --hard HEAD^        // 回退到上个版本\n$ git reset --hard HEAD~3       // 回退到前3次提交之前，以此类推，回退到n次提交之前\n$ git reset --hard commit_id    // 退到/进到 指定commit的sha码\n```\n## 删除某个标签\n\n```text\ngit push origin :refs/tags/v2.7.72 // 删除标签 v2.7.72 \n```\n","source":"source\\_posts\\git-common-commands.md"},{"title":"ES6：var，let和const - 函数作用域和块范围之间的争斗","created":"2018/11/21","description":"ES6：var，let和const - 函数作用域和块范围之间的争斗TypeScript","author":"lanqy","link":"2018/11/21/es6-var-let-and-const-the-battle-between-function-scope-and-block-scope","htmlDir":"website\\2018\\11\\21\\es6-var-let-and-const-the-battle-between-function-scope-and-block-scope","htmlFile":"website\\2018\\11\\21\\es6-var-let-and-const-the-battle-between-function-scope-and-block-scope\\index.html","body":"# ES6：var，let和const - 函数作用域和块范围之间的争斗\r\n\r\n译自：http://www.deadcoderising.com/2017-04-11-es6-var-let-and-const-the-battle-between-function-scope-and-block-scope/\r\n\r\n在 ES6 之前的时代，只有一种方法可以在 JavaScript 中声明变量 - 即使用 var。\r\n\r\nvar 总是有这种特殊的误解光环 - 这可能是因为用 var 声明的变量的行为与大多数其他编程语言的区别。话虽如此，整个事情有一个非常自然的解释 - 作用域。\r\n\r\n问题是，var 是函数作用域。这种类型的作用域与更常用的块范围略有不同。\r\n\r\n让我们来看看这意味着什么。\r\n\r\n##  var - 函数作用域\r\n\r\n如前所述，使用 var 声明的变量将是函数作用域，这意味着它将存在于其声明的函数作用域内。\r\n\r\n```javascript\r\nfunction myFunc() {\r\n  var name = 'Luke'\r\n  console.log(name); // 'Luke'\r\n}\r\n\r\nmyFunc();\r\n\r\nconsole.log(name); // name is not defined\r\n```\r\n\r\n如您所见，函数内部使用 var 声明的变量无法从函数外部访问。\r\n\r\n话虽如此，其他类型的块 - 如 if 语句，循环等 - 将不被视为作用域。\r\n\r\n```javascript\r\nif(true) {\r\n  var name = 'Luke'\r\n}\r\n\r\nconsole.log(name); // 'Luke'\r\n```\r\n\r\n使用 var，变量名在其声明的 if 语句之外可用。这是因为它们属于同一作用域。\r\n\r\n然而，随着 ES6 的引入，引入了两种声明变量的新方法。\r\n\r\n## let 和 const - 块作用域的介绍\r\n\r\n在ES6中，let 和 const 被引入作为声明变量的替代方法 - 两者都块作用域。\r\n\r\n如果你习惯了除 JavaScript 之外的任何其他语言，这可能会更好地与你产生共鸣。\r\n\r\n在块作用域内，任何块都是范围。这将提供更一致的行为。\r\n\r\n这意味着函数仍然是有效作用域，就像使用 var 一样。\r\n\r\n```javascript\r\nfunction myFunc() {\r\n  let name = 'Luke'\r\n  console.log(name); // 'Luke'\r\n}\r\n\r\nmyFunc();\r\nconsole.log(name); // name is not defined\r\n```\r\n\r\n但在这种情况下，其他类型的块也可以作为作用域 - 如 if 语句。\r\n\r\n```javascript\r\nif(true) {\r\n  let name = 'Luke'\r\n}\r\n\r\nconsole.log(name); // name is not defined\r\n```\r\n\r\n## 当函数作用域变得混乱时\r\n\r\n现在我们知道了功能作用域和块范围之间的区别 - 让我们看看为什么这很快就会让人感到困惑。\r\n\r\n在作用域内部具有与外部作用域中的变量同名的局部变量是完全正确的。\r\n\r\n```javascript\r\nvar name = 'Luke';\r\n\r\nconst func = () => {\r\n  var name = 'Phil';\r\n  console.log(name); // 'Phil'\r\n}\r\n\r\nfunc();\r\n\r\nconsole.log(name); // 'Luke'\r\n```\r\n\r\n正如预期的那样，即使在 func (包含一个同样命名的局部变量)执行之后，外部作用域中的 name 仍然保持初始声明值“Luke”。\r\n\r\n然而问题是，由于函数作用域只包含函数而不是其他类型的块，我们会得到与其他块完全不同的行为。\r\n\r\n```javascript\r\nvar name = 'Luke';\r\n\r\nif(true) {\r\n  var name = 'Phil';\r\n  console.log(name); // ‘'Phil'\r\n}\r\n\r\nconsole.log(name); // 'Phil'\r\n```\r\n\r\n在这种情况下，'Phil' 将在两个地方打印。这是因为两个变量都在相同的作用域内，导致 'Phil' 覆盖第一个变量声明。\r\n\r\n\r\n可以想象，随着复杂性的增加，这很快就会变成一个真正的头痛。\r\n\r\n## 与块作用域保持一致\r\n\r\n如果我们看看 let  - 这是块作用域 - 这将对所有块保持一致。\r\n\r\n```javascript\r\nlet name = 'Luke';\r\n\r\nconst func = () => {\r\n  let name = 'Phil'\r\n  console.log(name); // 'Phil'\r\n}\r\n\r\nfunc();\r\n\r\nconsole.log(name); // 'Luke'\r\n```\r\n\r\n```javascript\r\nlet name = 'Luke';\r\n\r\nif (true) {\r\n  let name = 'Phil';\r\n  console.log(name); // 'Phil'\r\n}\r\n\r\nconsole.log(name); // 'Luke'\r\n```\r\n\r\n##  循环怎么样？\r\n\r\n让我们看看另一个例子来真正理解不同的行为。\r\n\r\n\r\n假设我们想要创建一个将惰性函数推送到数组的循环。这些函数中的每一个都将打印当前索引。\r\n\r\n让我们首先看看如果我们使用 var 会发生什么。\r\n\r\n```javascript\r\nvar printsToBeExecuted = [];\r\n\r\nfor (var i = 0; i < 3; i++) {\r\n  printsToBeExecuted.push(() => console.log(i));\r\n}\r\n\r\nprintsToBeExecuted.forEach(f => f());\r\n// Output: 3, 3, 3\r\n```\r\n\r\n再说一次，如果你习惯于块作用域，那会觉得有点奇怪。你会期望 0, 1, 2 对吗？\r\n\r\n解释只是在使用 var 时循环不是作用域。因此，不是为每个增量创建局部变量 i ，而是最终为所有函数打印变量的最终值。\r\n\r\n```javascript\r\nvar printsToBeExecuted = [];\r\n\r\nfor (var i = 0; i < 3; i++) {\r\n  printsToBeExecuted.push(\r\n    ((ii) => () => console.log(ii))()\r\n  )\r\n}\r\n\r\nprintsToBeExecuted.forEach(f => f());\r\n\r\n// Output: 0, 1, 2\r\n```\r\n\r\n太棒了，我们得到了我们预期的输出，但它有点冗长吧？\r\n\r\n如果我们现在看一下使用块作用域的解决方案来获取迭代变量，我们将获得第一个示例的简单性以及预期的结果。\r\n\r\n```javascript\r\nvar printsToBeExecuted = [];\r\n\r\nfor (let i = 0; i < 3; i++) {\r\n  printsToBeExecuted.push(() => consolt.log(i));\r\n}\r\n\r\nprintsTBeExecuted.forEach(f => f());\r\n// Output: 0, 1, 2\r\n```\r\n","source":"source\\_posts\\es6-var-let-and-const-the-battle-between-function-scope-and-block-scope.md"},{"title":"OCaml 符号","created":"2018/10/23","description":"OCaml 符号","author":"lanqy","link":"2018/10/23/OCaml-symbols","htmlDir":"website\\2018\\10\\23\\OCaml-symbols","htmlFile":"website\\2018\\10\\23\\OCaml-symbols\\index.html","body":"# OCaml 符号\r\n\r\n## 1、 (* ... \\*) ，(*\\* ... \\*\\*) \r\n\r\n标识注释，(* ... \\*)  一般用于代码注释，可嵌套。 (*\\* ... \\*\\*)  一般用于文档注释，例如：\r\n \r\n```ocaml\r\n (** 这里是注释. **)\r\nval touch : (string * int) list -> string -> (string * int) list\r\n```\r\n\r\n## 2、 [ ... ] \r\n\r\n生成一个列表（类型）。 使用 ; 分隔符列表元素，例如：\r\n\r\n```ocaml\r\n# let words = [\"foo\"; \"bar\"; \"baz\"];;\r\nval words : string list = [\"foo\"; \"bar\"; \"baz\"]\r\n```\r\n\r\n## 3、 ,\r\n\r\n生成一个元组。但是，元组的类型是通过  *  号来分隔每个元素的，例如：\r\n\r\n```ocaml\r\n(* 类型定义 *)\r\ntype name = string * string\r\n\r\n(* 元组生成 *)\r\nlet johndoe = (\"John\", \"Doe\")\r\n\r\n(* 模式匹配 *)\r\nmatch s with\r\n| (first, last) -> Printf.printf \"my name is %s %s\" first last\r\n```\r\n\r\n## 4、 ;\r\n\r\n这是一个句子休息。尽管 OCaml 的大部分语法都不需要这个分隔符，但它对短代码的函数并没有多大用处。正如上面已经提到的那样，这个符号也被用来分隔列表（下面）和记录元素\r\n\r\n## 5、 &&\r\n\r\n这是一个逻辑与（AND）运算符。我想你可以想象。还有，这是用于另一个目的的语法。\r\n\r\n## 6、 ||\r\n\r\n它是一个逻辑或（OR）运算符。or 也包含在保留字中，但现在已被弃用。\r\n\r\n## 7、 :: \r\n\r\n合成列表的操作符， x :: xs  在  xs  列表的开头添加一个  x  元素，例如：\r\n\r\n```ocaml\r\n# let a = [2;3;4;5];;\r\nval a : int list = [2; 3; 4; 5]\r\n# let b = 1 :: a;;\r\nval b : int list = [1; 2; 3; 4; 5]\r\n\r\n# let a = 1 :: 2 :: 3 :: [];;\r\nval a : int list = [1; 2; 3]\r\n```\r\n\r\n\r\n## 8、 '\r\n\r\n单引号可以用于标识符。  x'  你也可以说变量名 f'  和函数名都可以。\r\n\r\n但是， 你不能以 'a 的形式定义变量。这被称为类型变量，它用于类型符号。\r\n\r\n## 9、 |\r\n\r\n用于编写由变体类型和模式匹配分隔的多个模式。例如：\r\n\r\n```ocaml\r\n(* 变体类型的定义 *) \r\ntype foobar = \r\n    Foo (* 可能是 Foo *) \r\n  | Bar \r\n  | Baz \r\n(* 模式匹配 *) \r\nmatch v with \r\n| Foo -> ... \r\n| Bar -> ... \r\n| Baz -> ...\r\n```\r\n\r\n## 10、 ->\r\n\r\n它用于模式匹配守卫或类型的符号。例如： String.get  获取字符串中特定位置的字符的函数类型是  string -> int -> char \r\n\r\n```ocaml\r\n(* 模式匹配 *) \r\nmatch v with \r\n| Foo -> ... \r\n| Bar -> ... \r\n| Baz -> ...\r\n```\r\n\r\n## 11、 ()\r\n\r\n括号内没有任何内容。这是一个  unit ，它没有任何称为类型的东西......它在其他语言中是无效的。\r\n\r\n() 如果你发现一个指定参数的函数，它是一个不需要任何参数的函数。函数不能在没有参数的情况下调用，因此可以通过指定来调用类型以()开头的 unit - >  函数。例如：\r\n\r\n```ocaml\r\n# Sys.getcwd () ;; (* 获取当前目录 *) \r\n-: string = \"/Volumes/Users/szktty\"\r\n```\r\n\r\n入口点是 let () = ... 也是这个符号，这是模式匹配，但不是一个参数。\r\n\r\n## 12、 ^\r\n\r\n连接字符串的运算符，这个操作符会生成一个新的字符串。例如：\r\n\r\n```ocaml\r\n# let name = \"hello \" ^ \"lanqy\";;\r\nval name : string = \"hello lanqy\"\r\n```\r\n\r\n## 13、 +.  -.  *.  /. \r\n\r\n浮点数的加减乘除。例如：\r\n\r\n```ocaml\r\n(* 相加 *)\r\n# 1.2 +. 1.3;;\r\n- : float = 2.5\r\n(* 相减 *)\r\n# 1.3 -. 1.2;;\r\n- : float = 0.10000000000000009\r\n(* 相乘 *)\r\n# 3.0 *. 2.0;;\r\n- : float = 6.\r\n(* 相除 *)\r\n# 6.0 /. 2.0;;\r\n- : float = 3.\r\n```\r\n## 14、  _\r\n\r\n这是一个可以用于标识符的符号。在模式匹配中，它被称为通配符，但与其他变量相比，它实际上并没有特殊的功能。  _  即  v  它匹配任何值：\r\n\r\n```ocaml\r\nmatch exp with \r\n| 0 -> ... \r\n| v -> ... (* 匹配 0 以外的值 *)\r\n```\r\n\r\n但是，如果将此符号添加到变量名称（或函数名称）的开头，则该变量将绕过警告。通常情况下，如果您根本没有使用任何已定义的变量，编译器将被警告为未使用的变量，但该检查不会完成，不要写 let _ =  。\r\n\r\n```ocaml\r\nmatch exp with \r\n| 0 -> 0 \r\n| v -> 1 (* w 被警告为未使用的变量，因为 v 未使用 *) \r\n\r\nmatch exp with \r\n| 0 -> 0 \r\n| _ -> 1 (* 我不会收到警告 *)\r\n```\r\n\r\n另外，这不是一个单独的语言规范，也不是强制性的，但作为命名惯例_it有时附加到标识符的末尾（特别是记录字段名称），我们经常看到类似  end_ ,  to_  这样的命名方式，原因很简单，因为有同名的end, to 保留字，与其绞尽脑汁想一个命名，不如直接在单词后面加  _  ?\r\n\r\n```ocaml\r\ntype location = {\r\n  start : int;\r\n  end_ : int;\r\n}\r\n```\r\n\r\n## 15、  [| ... |] \r\n\r\n用于生成数组的语法（类型）， [...]  与这个区别是完美的，例如：\r\n\r\n```ocaml\r\n# [|1; 2; 3|];;\r\n- : int array = [|1; 2; 3|]\r\n```\r\n\r\n## 16、  :=  <- \r\n\r\n:=  引用（指针）（赋值（当解引用不提供左值））,  <-  变量赋值或声明（赋值）, 例如：\r\n\r\n```ocaml\r\n# let y = ref None;;\r\nval y : '_a option ref = {contents = None}\r\n# y;;\r\n- : '_a option ref = {contents = None}\r\n# y := Some 3;;\r\n- : unit = ()\r\n# y;;\r\n- : int option ref = {contents = Some 3}\r\n# y := None;;\r\n# y;;\r\n- : int option ref = {contents = None}\r\nlet s = \"hello world\";;\r\nlet s' = s;;\r\ns.[0] <- 'x';;\r\ns';;\r\n- : string = \"xello world\"\r\n(* 数组 *)\r\nlet x = [| 2; 8; 3 |];;\r\n\r\n(* 修改数组元素 *)\r\nx.(1) <- 9;;             (* 设置索引为 1 的元素为 9 *)\r\nx;;\r\n- : int array = [|2; 9; 3|]\r\n```\r\n\r\n## 17、 = <> == !=\r\n\r\n=  相等，  <>  不相等( 深层 )， ==  相等，  !=  不相等 ( 浅层次 )，OCaml中有两个相等运算符 = 和 == ，相应的不等式运算符 <> 和 !=。= 和 <> 检查结构相等，而 == 和 != 检查物理相等，例如：\r\n\r\n```ocaml\r\n# \"a\" == \"a\";;\r\n- : bool = false\r\n# \"a\" = \"a\";;\r\n- : bool = true\r\n# \"a\" != \"a\";;\r\n- : bool = true\r\n# \"a\" <> \"a\";;\r\n- : bool = false\r\n```\r\n\r\n## 18、  ~ \r\n\r\n标签参数中使用的符号，例如：\r\n\r\n```ocaml\r\n# let f ~x ~y = x - y;;\r\nval f : x:int -> y:int -> int = <fun>\r\n\r\n# let x = 3 and y = 2 in f ~x ~y;;\r\n- : int = 1\r\n\r\n# let f ~x:x1 ~y:y1 = x1 - y1;;\r\nval f : x:int -> y:int -> int = <fun>\r\n\r\n# f ~x:3 ~y:2;;\r\n- : int = 1\r\n```\r\n\r\n## 19、 ?\r\n\r\n可选参数 = 用于标记参数的符号，可以省略。例如：\r\n\r\n```ocaml\r\n# let foo ?(z = 0) x y = x + y > z;;\r\nval foo : ?z:int -> int -> int -> bool = <fun>\r\n# foo 3 3 ~z: 2;;\r\n- : bool = true\r\n# foo 3 3 ~z: 10;;\r\n- : bool = false\r\n# foo 2 1;;\r\n- : bool = true\r\n```\r\n\r\n(* 代码来自 https://stackoverflow.com/questions/23703470/ocaml-optional-argument *)\r\n\r\n## 20、  ` \r\n\r\n表示多态变体的符号。还有其他多态变体符号  [>  和  [<  。\r\n\r\n可以结合 http://blog.klipse.tech/reason/2018/03/12/blog-reason-types.html 这篇文章来理解  [>  和  [< 。\r\n\r\n```ocaml\r\n#  type card =  [  `Jorker  |  `Num  of  int  ];;  (* 多态变体类型 *) \r\ntype card =  [  `Jorker  |  `Num  of  int  ] \r\n\r\n#  type in_data =  [  `Str  of  string  |  `Num  of  int  ] ;;  (* 多态变体类型 *) \r\ntype in_data =  [  `Num  of  int  |  `Str  of  string  ] \r\n\r\n#  let get_number=  function  (* 接收多态变体参数 *) \r\n    `Num i -> i\r\n   |  _  -> failwith \" not a number \" ;; \r\nval get_number: [>  ` Num  of 'a ]  -> ' a =  <fun > \r\n\r\n# get_number ( `Num  3 ) ;;  (* 应用多态变体类型 *) \r\n-: int  =  3\r\n ```\r\n(* 代码来自 http://osiire.hatenablog.com/entries/2009/05/10 *)\r\n\r\n## 21、  @@  和   |> \r\n\r\nOCaml 4.01 新添加的两个内置运算符： @@  和  |> ，它们非常简单，你可以在像这样的旧版本中自己定义它们：\r\n\r\n```ocaml\r\nlet (@@) fn x = fn x\r\nlet (|>) x fn = fn x\r\n(* 以下这两个是一样的 *)\r\nprint @@ \"Hello\";;\r\nprint \"Hello\";;\r\n```\r\n\r\n例如，这两行是等价的（我们加载一个文件，将其解析为XML，将生成的文档解析为选择文档，然后执行选择）\r\n\r\n```ocaml\r\nexecute (parse_selections (parse_xml (load_file path)))\r\n\r\nexecute @@ parse_selections @@ parse_xml @@ load_file path\r\n```\r\n\r\n(* 代码来自 http://roscidus.com/blog/blog/2013/10/13/ocaml-tips/ *)\r\n\r\n这样做的好处是，当你阅读一个  ( ，你必须沿着括号中的其余行扫描来找到匹配的。当你看到 @@ 时，你知道表达式的其余部分是前一个单一的参数功能。\r\n\r\n管道运算符 |> 是相似的，但函数和参数是相反的。以下两行是相同的：\r\n\r\n```ocaml\r\nexecute @@ parse_selections @@ parse_xml @@ load_file path\r\n\r\nload_file path |> parse_xml |> parse_selections |> execute\r\n```\r\n\r\n(* 代码来自 http://roscidus.com/blog/blog/2013/10/13/ocaml-tips/ *)\r\n\r\n## 22、  ;; \r\n\r\n顶层环境的结束符。例如：\r\n\r\n```ocaml\r\nlet a = [2;3;4;5];;\r\nval a : int list = [2; 3; 4; 5]\r\n```\r\n\r\n## 23、  @ \r\n\r\n列表的连接符。例如：\r\n\r\n\r\n```ocaml\r\nlet a = [2;3] @ [4;5;6];;\r\nval a : int list = [2; 3; 4; 5; 6]\r\n```\r\n\r\n参考资料：\r\n\r\n- https://qiita.com/szktty/items/05cb2b754c88fbacc274\r\n- http://roscidus.com/blog/blog/2013/10/13/ocaml-tips/\r\n- https://stackoverflow.com/questions/23703470/ocaml-optional-argument\r\n- http://rigaux.org/language-study/syntax-across-languages-per-language/OCaml.html\r\n","source":"source\\_posts\\OCaml-symbols.md"},{"title":"理解 JavaScript 调用堆栈","created":"2018/10/22","description":"理解 JavaScript 调用堆栈","author":"lanqy","link":"2018/10/22/understanding-the-javascript-call-stack","htmlDir":"website\\2018\\10\\22\\understanding-the-javascript-call-stack","htmlFile":"website\\2018\\10\\22\\understanding-the-javascript-call-stack\\index.html","body":"# 理解 JavaScript 调用堆栈\r\n\r\n译自：https://medium.freecodecamp.org/understanding-the-javascript-call-stack-861e41ae61d4\r\n\r\nJavaScript 引擎（在浏览器等托管环境中找到）是一个包含堆和单个调用堆栈的单线程解释器。浏览器提供 DOM，AJAX 和 Timers 等 Web API。\r\n\r\n本文旨在解释调用堆栈是什么以及为什么需要它。对调用堆栈的理解将清楚地说明“函数层次结构和执行顺序”在 JavaScript 引擎中的工作原理。\r\n\r\n调用堆栈主要用于函数调用（调用）。由于调用堆栈是单个的，所以函数执行一次一个地完成，从上到下。这意味着调用堆栈是同步的。\r\n\r\n对调用堆栈的理解对异步编程至关重要（我们将在后面的文章中介绍）。\r\n\r\n在异步 JavaScript 中，我们有一个回调函数，一个事件循环和一个任务队列。在通过事件循环将回调函数推送到堆栈之后，调用堆栈在执行期间对回调函数起作用。\r\n\r\n在最基本的层面上，调用堆栈是一种数据结构，它使用后进先出（LIFO）原则来临时存储和管理函数调用（调用）。\r\n\r\n让我们分解我们的定义：\r\n\r\nLIFO：当我们说调用堆栈由 Last In，First Out 的数据结构原理操作时，这意味着当函数返回时，最后一个被推入堆栈的函数是第一个被弹出的函数。\r\n\r\n让我们看一下代码示例，通过向控制台打印堆栈跟踪错误来演示 LIFO。\r\n\r\n```javascript\r\nfunction firstFunction() {\r\n    throw new Error('Stack Trace Error');\r\n}\r\n\r\nfunction secondFunction(){\r\n    firstFunction();\r\n}\r\n\r\nfunction thirdFunction() {\r\n    secondFunction();\r\n}\r\n\r\nthirdFunction();\r\n```\r\n\r\n代码运行时，我们收到错误。打印堆栈显示函数如何堆叠在彼此之上。看一下图表。\r\n\r\n![console](/images/1_LIuELJ2RTtwWExRWGdu_Hw.png)\r\n\r\n你会注意到函数作为一个堆栈的排列开始于 `firstFunction()`（这是进入堆栈的最后一个函数，并弹出以抛出错误），然后是`secondFunction()` ，然后是 `thirdFunction()`（这是执行代码时第一个被推入堆栈的函数）。\r\n\r\n暂时存储：当调用（called）函数时，函数，其参数和变量被推入调用堆栈以形成堆栈帧。此堆栈帧是堆栈中的内存位置。当函数从堆栈中弹出时，内存被清除。\r\n![stack](/images/1_PPkrowy4n_Pyehb_NdhLrg.png)\r\n\r\n管理函数调用（called）：调用堆栈维护每个堆栈帧的位置记录。它知道要执行的下一个函数（并将在执行后将其删除）。这就是使 JavaScript 中的代码执行同步的原因。\r\n\r\n想象一下你自己站在一个杂货店的现金点排队。只有在你面前的人被照顾后才能照顾你。这是同步的。\r\n\r\n这就是我们所说的“管理函数调用”。\r\n\r\n## 调用堆栈如何处理函数调用？\r\n\r\n我们将通过查看调用另一个函数的函数的示例代码来回答这个问题。这是示例代码：\r\n\r\n```javascript\r\nfunction firstFunction(){\r\n console.log(\"Hello from firstFunction\");\r\n}\r\nfunction secondFunction(){\r\n firstFunction();\r\n console.log(\"The end from secondFunction\");\r\n}\r\nsecondFunction();\r\n```\r\n\r\n![console output](/images/1_9iSkoJoXM0Ok8iQ5mOHl5Q.png)\r\n\r\n这是代码运行时发生的情况：\r\n\r\n1.当执行 secondFunction() 时，会创建一个空堆栈帧。它是该程序的主要（匿名）入口点。\r\n2. secondFunction() 然后调用 firstFunction()，将其推入堆栈。\r\n3. firstFunction() 返回并将“Hello from firstFunction”打印到控制台。\r\n4. firstFunction() 从堆栈中弹出。\r\n5. 执行顺序然后移动到 secondFunction()。\r\n6. secondFunction() 返回并打印“The end from secondFunction”到控制台。\r\n7. 从堆栈中弹出 secondFunction()，清除内存。\r\n\r\n## 是什么导致堆栈溢出？\r\n\r\n当存在递归函数（一个自己调用的函数）而没有退出点时，会发生堆栈溢出。浏览器（托管环境）具有最大堆栈调用，它可以在抛出堆栈错误之前容纳。\r\n\r\n这是一个例子：\r\n\r\n```javascript\r\nfunction callMyself(){\r\n  callMyself();\r\n}\r\ncallMyself();\r\n```\r\n\r\ncallMyself() 将一直运行，直到浏览器抛出“Maximum call size exceeded”。那是堆栈溢出。\r\n\r\n![Maximum call stack error](/images/1_JFRlgLp2uvbdVrh7WdmMrQ.png)\r\n\r\n## 综上所述\r\n\r\n调用堆栈的关键点是：\r\n\r\n- 它是单线程的。这意味着它一次只能做一件事。\r\n- 代码执行是同步的。\r\n- 函数调用会创建占用临时内存的堆栈帧。\r\n- 它作为LIFO - Last In，First Out 数据结构。\r\n\r\n我们使用了调用堆栈文章为我们将在异步 JavaScript 上看到的系列奠定了基础（我们将在另一篇文章中看到）。\r\n\r\n所有代码示例都可以在此 [github仓库](https://github.com/charlesfreeborn/JS-CallStack-CodeSamples/blob/master/codesamples.md) 中找到。 ","source":"source\\_posts\\understanding-the-javascript-call-stack.md"},{"title":"JavaScript 的工作原理：引擎，运行时和调用堆栈的概述","description":"JavaScript 的工作原理：引擎，运行时和调用堆栈的概述","created":"2018/10/22","author":"lanqy","link":"2018/10/22/how-does-javascript-actually-work","htmlDir":"website\\2018\\10\\22\\how-does-javascript-actually-work","htmlFile":"website\\2018\\10\\22\\how-does-javascript-actually-work\\index.html","body":"\r\n# JavaScript 的工作原理：引擎，运行时和调用堆栈的概述\r\n\r\n随着 JavaScript 变得越来越流行，团队正在利用其在堆栈中的多个级别的支持 - 前端，后端，混合应用程序，嵌入式设备等等。\r\n\r\n这篇文章旨在成为系列中的第一篇，旨在深入挖掘 JavaScript 及其实际工作方式：我们认为通过了解 JavaScript 的构建块以及它们如何一起发挥，您将能够编写更好的代码和应用。我们还将分享我们在构建 [SessionStack](https://www.sessionstack.com/?utm_source=medium&utm_medium=source&utm_content=javascript-series-post1-intro) 时使用的一些经验法则，这是一个轻量级JavaScript应用程序，必须具有强大且高性能才能保持竞争力。\r\n\r\n如 [GitHut](https://githut.info/) 统计数据所示，JavaScript 在 GitHub 中的 Active Repositories和 Total Pushes 方面处于领先地位。它也不会落后于其他类别\r\n\r\n![console](/images/1_Zf4reZZJ9DCKsXf5CSXghg.png)\r\n(Check out up-to-date GitHub language stats).\r\n\r\n如果项目越来越依赖于JavaScript，这意味着开发人员必须利用语言和生态系统提供的所有内容，对内部进行更深入和更深入的了解，以便构建出色的软件。\r\n\r\n事实证明，有很多开发人员每天都在使用JavaScript，但却不了解幕后发生的事情。\r\n\r\n## 概貌\r\n\r\n几乎每个人都已经听说过 V8 引擎作为一个概念，大多数人都知道 JavaScript 是单线程的，或者它使用的是回调队列。\r\n\r\n在这篇文章中，我们将详细介绍所有这些概念，并解释 JavaScript 实际运行的方式。通过了解这些详细信息，您将能够编写更好的，非阻塞的应用程序，这些应用程序正确地利用了所提供的 API。\r\n\r\n如果您对 JavaScript 比较陌生，那么这篇博文将帮助您理解为什么 JavaScript 与其他语言相比如此“奇怪”。\r\n\r\n如果您是一位经验丰富的 JavaScript 开发人员，希望它会为您提供一些关于您每天使用的 JavaScript 运行时实际工作方式的新见解。\r\n\r\n## JavaScript 引擎\r\n\r\nJavaScript 引擎的一个流行示例是 Google 的 V8 引擎。例如，V8 引擎用于 Chrome 和 Node.js。这是一个非常简化的视图：\r\n\r\n![](/images/1_OnH_DlbNAPvB9KLxUCyMsA.png)\r\n\r\n引擎包含两个主要组件：\r\n\r\n- 内存堆 - 这是内存分配发生的地方\r\n- 调用堆栈 - 这是您的代码执行时堆栈帧的位置\r\n\r\n## 运行时\r\n\r\n浏览器中有几乎所有 JavaScript 开发人员都使用过的 API（例如“setTimeout”）。但是，引擎不提供这些 API。\r\n\r\n那么，他们来自哪里？\r\n\r\n事实证明，现实有点复杂。\r\n\r\n所以，我们有引擎，但实际上还有很多。我们有一些叫做 Web API 的东西，它们是由浏览器提供的，比如 DOM，AJAX，setTimeout 等等。\r\n\r\n然后，我们有如此受欢迎的事件循环和回调队列。\r\n\r\n## 调用堆栈\r\n\r\nJavaScript 是一种单线程编程语言，这意味着它只有一个调用堆栈。因此，它可以一次做一件事。\r\n\r\n调用栈是一种数据结构，它基本上记录了程序中的位置。如果我们进入函数，我们将它放在堆栈的顶部。如果我们从函数返回，我们会弹出堆栈的顶部。这就是所有堆栈都可以做到的。\r\n\r\n我们来看一个例子吧。看一下下面的代码：\r\n\r\n```javascript\r\nfunction multiply(x, y) {\r\n    return x * y\r\n}\r\n\r\nfunction printSquare(x) {\r\n    var s = multipy(x, x);\r\n    console.log(s);\r\n}\r\n\r\nprintSquare(5);\r\n```\r\n\r\n当引擎开始执行此代码时，调用堆栈将为空。之后，步骤如下：\r\n\r\n![](/images/1_Yp1KOt_UJ47HChmS9y7KXw.png)\r\n\r\n调用堆栈中的每个条目称为堆栈帧。\r\n\r\n这正是抛出异常时堆栈跟踪的构造方式 - 它基本上是异常发生时调用堆栈的状态。看一下下面的代码：\r\n\r\n```javascript\r\nfunction foo() {\r\n    throw new Error('SessionStact will help you resolve crashes :)')\r\n}\r\n\r\nfunction bar() {\r\n    foo();\r\n}\r\n\r\nfunction start() {\r\n    bar();\r\n}\r\n\r\nstart();\r\n```\r\n\r\n如果在 Chrome 中执行此操作（假设此代码位于名为 foo.js 的文件中），则将生成以下堆栈跟踪：\r\n\r\n![](/images/1_T-W_ihvl-9rG4dn18kP3Qw.png)\r\n\r\n“吹掉堆栈” - 当达到最大调用堆栈大小时会发生这种情况。这很容易发生，特别是如果你使用递归而不是非常广泛地测试你的代码。看看这个示例代码：\r\n\r\n```javascript\r\nfunction foo() {\r\n    foo();\r\n}\r\n\r\nfoo();\r\n```\r\n\r\n当引擎开始执行此代码时，它首先调用函数“foo”。但是，此函数是递归的，并且在没有任何终止条件的情况下开始调用自身。因此，在执行的每个步骤中，相同的函数一次又一次地添加到调用堆栈中。它看起来像这样：\r\n\r\n![](/images/1_AycFMDy9tlDmNoc5LXd9-g.png)\r\n\r\n但是，在某些时候，调用堆栈中的函数调用数量超过了调用堆栈的实际大小，并且浏览器决定通过抛出错误来执行操作，该错误看起来像这样：\r\n\r\n![](/images/1_e0nEd59RPKz9coyY8FX-uw.png)\r\n\r\n在单个线程上运行代码非常简单，因为您不必处理多线程环境中出现的复杂场景 - 例如，死锁。\r\n\r\n但是在单个线程上运行也是非常有限的。由于JavaScript只有一个调用堆栈 (Call Stack)，当事情变慢时会发生什么？\r\n\r\n## 并发和事件循环\r\n\r\n如果在调用堆栈中有函数调用需要花费大量时间才能处理，会发生什么？例如，假设您想在浏览器中使用 JavaScript 进行一些复杂的图像转换。\r\n\r\n你可能会问，为什么这甚至是一个问题?问题是，虽然调用堆栈有函数要执行，但浏览器实际上不能做任何其他事情——它被阻塞了。这意味着浏览器不能呈现，不能运行任何其他代码，它只是卡住了。如果你想在应用中使用流畅的 UI，这就会产生问题。\r\n\r\n这不是唯一的问题。一旦您的浏览器开始在调用堆栈中处理如此多的任务，它可能会在相当长的时间内停止响应。大多数浏览器通过引发错误来采取行动，询问您是否要终止网页。\r\n\r\n![](/images/1_WlMXK3rs_scqKTRV41au7g.jpeg)\r\n\r\n现在，那不是最好的用户体验，是吗？\r\n\r\n那么，如何在不阻止 UI 并使浏览器无响应的情况下执行繁重的代码呢？好吧，解决方案是异步回调。\r\n\r\n这将在“如何实际运行JavaScript”教程的第2部分中进行更详细的解释：“[在V8引擎内部+有关如何编写优化代码的5个技巧](https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e)”。与此同时，如果您在JavaScript应用程序中难以复制和理解问题，请查看 [SessionStack](https://www.sessionstack.com/?utm_source=medium&utm_medium=blog&utm_content=Post-1-overview-outro) 。SessionStack 记录 Web 应用程序中的所有内容：所有 DOM 更改，用户交互，JavaScript 异常，堆栈跟踪，网络请求失败和调试消息。\r\n\r\n使用 SessionStack，您可以将网络应用中的问题作为视频重播，并查看用户发生的所有事情。\r\n\r\n有一个免费的计划，不需要信用卡。现在就[开始](https://www.sessionstack.com/?utm_source=medium&utm_medium=blog&utm_content=Post-1-overview-getStarted)。\r\n\r\n![](/images/1_kEQmoMuNBDfZKNSBh0tvRA.png)\r\n","source":"source\\_posts\\how-does-javascript-actually-work.md"},{"title":"OCaml -ppx 语言扩展教程","created":"2018/09/17","description":"OCaml -ppx 语言扩展教程","author":"lanqy","link":"2018/09/17/ppx-tutorial","htmlDir":"website\\2018\\09\\17\\ppx-tutorial","htmlFile":"website\\2018\\09\\17\\ppx-tutorial\\index.html","body":"# OCaml -ppx 语言扩展教程\r\n\r\n译自：https://victor.darvariu.me/jekyll/update/2018/06/19/ppx-tutorial.html\r\n\r\n> 简要介绍 OCaml 中的 ppx 扩展机制，并附有示例和进一步的指示 - 我希望在准备硕士论文时我知道的事情。\r\n\r\n你如何扩展编程语言？老式的方法是编写自己的预处理器，它接受用扩展语法编写的程序，并将它们转换为普通的编程语言(这是早期 c++ 编译器的工作原理)。稍微不那么苛刻的选择是依赖编程语言生态系统提供的工具;OCaml 是为数不多的提供开箱即用功能的d语言之一。在这篇文章中，我尝试从程序员的角度补充现有的集体智慧，了解 OCaml ppx 语言扩展机制的工作原理。\r\n\r\n## ppx 基础知识\r\n\r\nOCaml 语法支持 4.02 版本中的扩展节点，如 [OCaml 手册](https://caml.inria.fr/pub/docs/manual-ocaml/extn.html#sec261)中所述。扩展节点允许以任意复杂的方式扩展语言 - 它们可以表示表达式，类型表达式，模式等。让我们看一个扩展节点的一个愚蠢的例子：一个将 “+ 1” 项附加到任何代数表达式的节点。它可能看起来如下：\r\n\r\n```ocaml\r\n[%addone 1 + 2]\r\n```\r\n\r\n扩展节点由两部分组成：属性 id（上面的 addone ）和有效负载（表达式 1 + 2）。属性 id 标识它所代表的扩展节点的类型，以便由适当的重写器处理，而有效负载是需要根据语言扩展的逻辑重写的表达式的主体。在我们的例子中，在作者展开之后，上面的术语应该被阅读\r\n\r\n```ocaml\r\n(1 + 2) + 1\r\n```\r\n\r\n扩展节点是语法树中的通用占位符，类型检查器拒绝它，并打算由 ppx 重写器扩展它。ppx rewriter 是一种二进制文件，它接收解析器生成的 AST，执行一些转换，并输出经过修改的 AST。\r\n\r\n## OCaml AST\r\n\r\n那么这个 AST 是什么样的？通过解析生成的 AST 数据类型是 compiler-libs 包的一部分。您可以在 [Parsetree](https://caml.inria.fr/pub/docs/manual-ocaml/libref/Parsetree.html) 和 [Asttypes](https://caml.inria.fr/pub/docs/manual-ocaml/libref/Asttypes.html) 模块中找到类型的定义。要检查解析器在特定表达式上生成的 AST，可以通过运行以下命令来使用 [ppx_tools](https://github.com/ocaml-ppx/ppx_tools) 包中的 dumpast 工具：\r\n\r\n```text\r\nocamlfind ppx_tools/dumpast -e \"[%addone 1 + 2]\"\r\n```\r\n\r\n它生成了下面的语法树片段，其中使用了 OCaml 版本4.05中的 Parsetree/Asttypes 模块中的数据类型。我们可以直观地看到，解析树包含一个扩展节点，带有 addone 属性 id 和一个包含表达式的有效负载。这个表达式是对两个子表达式的加法函数的应用，这两个子表达式仅仅是常量。尝试按原样编译这个小程序将导致由于扩展节点未解释而引起错误——这是 ppx 重写程序的工作。\r\n\r\n```ocaml\r\n{pexp_desc =\r\n  Pexp_extension\r\n   ({txt = \"addone\"},\r\n    PStr\r\n     [{pstr_desc =\r\n        Pstr_eval\r\n         ({pexp_desc =\r\n            Pexp_apply ({pexp_desc = Pexp_ident {txt = Lident \"+\"}},\r\n             [(Nolabel,\r\n               {pexp_desc = Pexp_constant (Pconst_integer (\"1\", None))});\r\n              (Nolabel,\r\n               {pexp_desc = Pexp_constant (Pconst_integer (\"2\", None))})])},\r\n         ...)}])}\r\n```\r\n\r\n## AST Helpers\r\n\r\nppx 重写器需要与 AST 片段（例如上面的片段）进行模式匹配并执行转换。这些转换还需要生成有效的 OCaml AST 片段。手工构建这些非常麻烦。为此，[Ast_helper 模块](https://caml.inria.fr/pub/docs/manual-ocaml/libref/Ast_helper.html)提供了用于构造片段的辅助函数。为了构造表达式1 + 2，我们可以使用 Exp.apply 和 Exp.constant 助手 (helpers)，如下所示：\r\n\r\n```ocaml\r\nExp.apply   (Exp.ident {txt = Lident \"+\"; loc=(!default_loc)}) \r\n            [(Nolabel, Exp.constant (Pconst_integer (\"1\", None)));\r\n             (Nolabel, Exp.constant (Pconst_integer (\"2\", None)))];\r\n```\r\n\r\n## AST Mapper\r\n\r\n我们任务的 ppx 重写器将使用 [Ast_mapper API](https://caml.inria.fr/pub/docs/manual-ocaml/libref/Ast_mapper.html)，它提供编译器和 ppx 重写器之间的标准接口。它还提供了一个默认的映射器，它只不过是一个深度的身份映射器 - 因此我们只能修改我们感兴趣的语法树部分。使用必要的管道，我们的 addone 重写器将如下所示：\r\n\r\n```ocaml\r\nopen Ast_mapper\r\nopen Ast_helper\r\nopen Asttypes\r\nopen Parsetree\r\nopen Longident\r\n\r\nlet expr_mapper mapper expr = \r\n   begin match expr with\r\n      | { pexp_desc =\r\n          Pexp_extension ({ txt = \"addone\"; loc }, pstr)} ->\r\n        begin match pstr with\r\n        | PStr [{ pstr_desc =\r\n                  Pstr_eval (expression, _)}] -> \r\n                            Exp.apply  (Exp.ident {txt = Lident \"+\"; loc=(!default_loc)})\r\n                                        [(Nolabel, expression);\r\n                                         (Nolabel, Exp.constant (Pconst_integer (\"1\", None)))]\r\n        | _ -> raise (Location.Error (Location.error ~loc \"Syntax error\"))                       \r\n        end\r\n      (* Delegate to the default mapper. *)\r\n      | x -> default_mapper.expr mapper x;\r\n  end\r\n\r\nlet addone_mapper argv =\r\n  { \r\n    default_mapper with\r\n    expr = expr_mapper;\r\n  }\r\n \r\nlet () = register \"addone\" addone_mapper\r\n```\r\n让我们详细研究这个片段。在第 23 行，我们定义了自定义映射器，它使用我们自己的 expr_mapper 替换默认映射器中的 expr 字段。这意味着我们自己的 expr_mapper 只处理表达式;模式和其他 AST 类型将保持不变。第 7 行的 expr_mapper 的定义将表达式与具有标识符 addone 的扩展节点匹配，其他标识符不应由此映射器处理。然后我们对第 13 行的表达式进行模式匹配，并使用 AST 助手添加另一个函数应用程序 - + 应用于原始表达式和常量1。\r\n\r\n为了构建重写器，我们可以使用标准的  ocamlbuild 工具，指定对 compiler-libs 的依赖，其中必要的模块位于：\r\n\r\n```text\r\nocamlbuild -package compiler-libs.common addone_ppx.native\r\n```\r\n\r\n\r\n要检查重写器是否符合我们的要求，我们可以使用ppx_tools包中的重写器工具。假设 [%addone 1 + 2] OCaml 代码在文件 addone.ml 中：\r\n\r\n```text\r\nocamlfind ppx_tools/rewriter ./addone_ppx.native addone.ml\r\n```\r\n\r\n输出 (1 + 2) + 1，这正是我们想要的。该工具还允许将重写的源代码输出到文件而不是stdout。\r\n\r\n\r\n## 递归呢？\r\n\r\n上面给出的重写器不会递归，因此我们不能有嵌套的 addone 节点，例如 [%addone 1 + [%addone 2]]。支持递归是任何有意义的语言添加的关键要求，正是使扩展功能强大的原因。以下将让我们首先在AST的外部节点上应用+1加法;注意第16行的映射器的递归调用。然后重写[%addone 1 + [%addone 2]]表达式将给出（1 +（2 + 1））+ 1。\r\n\r\n```ocaml\r\nopen Ast_mapper\r\nopen Ast_helper\r\nopen Asttypes\r\nopen Parsetree\r\nopen Longident\r\n\r\nlet rec expr_mapper mapper expr = \r\n   begin match expr with\r\n      | { pexp_desc =\r\n          Pexp_extension ({ txt = \"addone\"; loc }, pstr)} ->\r\n        begin match pstr with\r\n        | PStr [{ pstr_desc =\r\n                  Pstr_eval (expression, _)}] -> \r\n                              Exp.apply  (Exp.ident {txt = Lident \"+\"; loc=(!default_loc)})\r\n                                          [(Nolabel, (expr_mapper mapper expression));\r\n                                           (Nolabel, Exp.constant (Pconst_integer (\"1\", None)))]\r\n        | _ -> raise (Location.Error (Location.error ~loc \"Syntax error in expression mapper\"))                       \r\n        end\r\n      (* Delegate to the default mapper. *)\r\n      | x -> default_mapper.expr mapper x;\r\n  end\r\n\r\nlet addone_mapper argv =\r\n  { \r\n    default_mapper with\r\n    expr = expr_mapper;\r\n  }\r\n \r\nlet () = register \"addone\" addone_mapper\r\n```\r\n\r\n## 构建和打包\r\n\r\n假设您对 ppx 重写器感到满意。 到目前为止的直观工作流程（使用 ppx 重写器重写文件，编译重写文件）对于玩具问题是可接受的，但对于较大的项目是不可行的。 理想情况下，我们希望能够使用扩展语言编写源文件，而不必担心调用预处理步骤。\r\n\r\n这就是打包的地方：将重写器作为包安装（例如，addone.ppx），您只需将其指定为依赖项，编译器将为您处理中间步骤：\r\n\r\n```text\r\nocamlfind ocamlc -package addone.ppx -package decml -linkpkg addone.ml\r\n```\r\n\r\n我个人发现 [oasis](http://oasis.forge.ocamlcore.org/) 工具最容易使用，以便在更复杂的场景下构建扩展。whitequark 的教程提供了一个很好的示例配置;然后，您可以使用 [oasis2opam](https://github.com/ocaml/oasis2opam) 等工具将其转换为 [opam](http://opam.ocaml.org/) 格式，在本地固定，甚至发布！您可能还希望查看更复杂的项目（例如 [SLAP](http://akabe.github.io/slap/) ）以查看示例 oasis 配置和项目布局，因为 oasis 文档简短且不完整。值得一提的是，OCaml 社区似乎正在向 [dune](https://github.com/ocaml/dune) （jbuilder）转变为事实上的构建工具，尽管我认为它更难以作为一个完整的初学者使用，特别是对于 ppx 重写器。\r\n\r\n## Parsetree 版本\r\n\r\n使用 ppx 重写器时的一个警告是 AST 数据类型在不同版本之间略有不同;因此，为 OCaml 版本 4.02 编写的扩展名与例如版本 4.05 的 OCaml 编译器不兼容。社区已经提出了一种自动方式，用于在 [ocaml-migrate-parsetree](https://github.com/ocaml-ppx/ocaml-migrate-parsetree) 库中的不同 AST 版本之间转换扩展。对于本博客中提供的示例，您需要使用 OCaml 4.05 版。如果您只打算支持有限数量的版本，则可能需要避免开销并手动将重写器转换为适当的版本。\r\n\r\n```ocaml\r\n{pexp_desc =\r\n  Pexp_apply ({pexp_desc = Pexp_ident {txt = Lident \"+\"}},\r\n   [(Nolabel, {pexp_desc = Pexp_constant (Pconst_integer (\"1\", None))});\r\n    (Nolabel, {pexp_desc = Pexp_constant (Pconst_integer (\"2\", None))})])}\r\n```\r\nAST for 1 + 2 in OCaml version 4.05.\r\n\r\n```ocaml\r\n{pexp_desc =\r\n  Pexp_apply ({pexp_desc = Pexp_ident {txt = Lident \"+\"}},\r\n   [(\"\", {pexp_desc = Pexp_constant (Const_int 1)});\r\n    (\"\", {pexp_desc = Pexp_constant (Const_int 2)})])}\r\n```\r\nAST for 1 + 2 in OCaml version 4.02.\r\n\r\n## 更多资源\r\n\r\n- [ppx_tools](https://github.com/ocaml-ppx/ppx_tools) 库在编写 ppx 重写器时提供了有用的功能。 本教程提到了重写器和 dumpast; 作者还提供了 metaquot，它为您提供了一种简单的方法来获取重写器代码中特定表达式的 OCaml 语法树。 例如，使用它，您可以通过编写 [%expr 1 + 2] 来获取 1 + 2 的 AST，而不是使用详细的 parsetree s数据类型来构造它。 这在编写测试时很方便。\r\n- [whitequark 的教程](https://whitequark.org/blog/2014/04/16/a-guide-to-extension-points-in-ocaml/)是关于 ppx 重写器的原始教程，是我的初始起点。\r\n- Shayne Fletcher 编写了一个[优秀的教程](http://blog.shaynefletcher.org/2017/05/preprocessor-extensions-for-code.html)，它使用了多种类型的映射器（不是表达式，而是结构和类型/构造函数声明）。您可能会发现它可用作重写器的另一个用例。\r\n\r\n\r\n编辑26/06/2018\r\n\r\n[这里](https://www.reddit.com/r/ocaml/comments/8sus7f/a_tutorial_to_ocaml_ppx_language_extensions/)有关于 OCaml reddit 的帖子的讨论。 OCaml 社区有帮助指出包装部分已经过时。 您可以在 [Rudi Grinberg 的教程](http://rgrinberg.com/posts/extension-points-3-years-later/)中查看如何使用 dune / jbuilder（较新的构建工具）设置配置，包括运行测试以将语法树与 diff 工具进行比较的巧妙方法。 他提供了一个可以在[这里](https://github.com/rgrinberg/ppx_getenv2)克隆的初学者项目。 有些库已经重新组织，因此您必须更改导入才能使其开箱即用。","source":"source\\_posts\\ppx-tutorial.md"},{"title":"OCaml 操作符备忘单","created":"2018/09/17","description":"OCaml 操作符备忘单","author":"lanqy","link":"2018/09/17/ocaml-operator-cheatsheet","htmlDir":"website\\2018\\09\\17\\ocaml-operator-cheatsheet","htmlFile":"website\\2018\\09\\17\\ocaml-operator-cheatsheet\\index.html","body":"# OCaml 操作符备忘单\r\n\r\n译自：https://www.brendanlong.com/ocaml-operator-cheatsheet.html\r\n\r\n学习 OCaml 最困难的部分之一就是弄清楚中缀运算符的作用，因为它们只是一串符号而你无法通过谷歌搜索找到它们。这是我试图制作一个备忘单，无论何时你想知道一系列随机符号是什么意思。在此页面上搜索应该找到有关任何常见 OCaml 运算符的基本信息。请注意，某些库定义了自己的运算符，例如 Jane Street 的[Command.Spec](https://ocaml.janestreet.com/ocaml-core/latest/doc/core/Core/Command/Spec/index.html#val-(++)) 如何定义 ++，+> 和 +<。\r\n\r\n## 关于中缀函数的一般信息\r\n\r\n在 OCaml 中，如果函数名称以以下字符之一开头，则函数为中缀：\r\n\r\n```ocaml\r\n= @ ^ | & + - * / $ %\r\n```\r\n\r\n其次是零个或多个这些字符：\r\n\r\n```ocaml\r\n! $ % & * + - . / : ? @ ^ | ~\r\n```\r\n\r\n定义中缀函数时，需要在 “name” 周围加上 ()。 例如，在 [utop](https://github.com/diml/utop) 中：\r\n\r\n```ocaml\r\n# let (=<>@^|&~+-*/$%!?:.) a b = a + b ;;\r\nval ( =<>@^|&~+-*/$%!?:. ) : int -> int -> int = <fun>\r\n\r\n# 1 =<>@^|&~+-*/$%!?:. 2;;\r\n- : int = 3\r\n```\r\n\r\n此外，您可以通过再次将函数名称包装在括号中来查看 utop 中的中缀运算符的类型：\r\n\r\n```ocaml\r\n# (=<>@^|&~+-*/$%!?:.);;\r\n\r\nval ( =<>@^|&~+-*/$%!?:. ) : int -> int -> int = <fun>\r\n```\r\n\r\n这里的[官方文档在这里](https://caml.inria.fr/pub/docs/manual-caml-light/node4.9.html)，虽然这个[博客](https://haifengl.wordpress.com/2014/07/02/ocaml-functions/)有一个更容易理解的解释。\r\n\r\n## 内置中缀运算符\r\n\r\n内置运算符在 [Pervasives](https://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html) 中定义：\r\n\r\n请参阅文档，了解涉及多种类型（=，<>，<，>等）的函数所涉及的魔力。\r\n\r\n\r\n操作符 | 描述\r\n------------ | -------------\r\n=\t| 结构相等 [1](https://stackoverflow.com/a/13596236/212555)\r\n<>\t| 结果不等 [1](https://stackoverflow.com/a/13596236/212555)\r\n<\t| 小于\r\n>\t| 大于\r\n<=\t| 小于等于\r\n>=\t| 大于等于\r\n==\t| 物理相等（同一对象）[1](https://stackoverflow.com/a/13596236/212555)\r\n!=\t| 物理不相等（不是同一个对象）[1](https://stackoverflow.com/a/13596236/212555)\r\n&&\t| 布尔和\r\n&\t| (已弃用) 布尔和\r\n\\|\\|\t| 布尔或\r\n\\|\t| （已弃用）布尔或\r\n\\|>\t| 反函数应用（x \\|> f 与 f x 相同）。也称管道运算符\r\n@@\t| 功能应用（f @@ x与 f x 相同）\r\n~-\t| 整数否定（与一元相同 - ）\r\n~+\t| 被描述为 “一元加法” 但似乎没有做任何事情。\r\n+\t| 整数加法\r\n-\t| 整数减法\r\n*\t| 整数乘法\r\n/\t| 整数除法\r\n~-.\t| 浮动否定（与一元相同 -.）\r\n~+.\t| 被描述为 “一元加法” 但似乎没有做任何事情。\r\n+.\t| 浮点数加法\r\n-.\t| 浮点数减法\r\n*.\t| 浮点数乘法\r\n/.\t| 浮点数除法\r\n**\t| 浮点数幂\r\n^\t| 字符串连接\r\n@\t| 列表连接\r\n!\t| 获取 ref 的值\r\n:=\t| 设置（修改） ref 的值\r\n^^\t| 格式化字符串连接\r\n\r\n## Jane Street\r\n\r\n### Numbers\r\n\r\nJane Street 通常在模块中定义有意义的算术运算符，因此您可以执行以下操作：\r\n\r\n```ocaml\r\nBigint.(of_int 1 + of_int 3 / of_int 5)\r\n```\r\n\r\n此接口的文档位于 [Int_intf.S_common](https://ocaml.janestreet.com/ocaml-core/latest/doc/base/Base/Int_intf/module-type-S_common/index.html) 下，尽管它们中的大多数也是针对浮点数定义的。\r\n\r\n操作符 | 描述\r\n------------ | -------------\r\n+\t| 特定模块的添加（即 float.(+) 是浮动添加）\r\n-\t| 特定模块的减法\r\n*\t| 特定模块的乘法\r\n/\t| 特定模块的除法\r\n//\t| 整数除法返回浮点数\r\n%\t| 中缀 [mod](https://en.wikipedia.org/wiki/Modulo_operation) (结果总是整数)\r\n/%\t| 中缀 [mod](https://en.wikipedia.org/wiki/Modulo_operation) (如果输入为负，则结果为负)\r\n\r\n### Monads\r\n\r\nJane Street 的库（ Core，Async，Base 等）在 [Monad_infix 模块](https://ocaml.janestreet.com/ocaml-core/latest/doc/base/Base/List/Monad_infix/index.html)下一致地定义了中缀运算符。\r\n\r\n操作符 | 描述\r\n------------ | -------------\r\n>>=\t| 中缀版本的 [bind](https://en.wikipedia.org/wiki/Monad_(functional_programming)#Overview)。打开 Async 将此设置为 [Deferred.bind](https://ocaml.janestreet.com/ocaml-core/latest/doc/async_kernel/Async_kernel/Deferred/index.html#val-bind)\r\n>>\\|\t| 中缀版本的 map. 打开 Async 将此设置为 [Deferred.map](https://ocaml.janestreet.com/ocaml-core/latest/doc/async_kernel/Async_kernel/Deferred/index.html#val-map)\r\n>>=? |\t与 Or_error 混合的 bind。打开 Async 将此设置为 [Deferred.Or_error.bind](https://ocaml.janestreet.com/ocaml-core/latest/doc/async_kernel/Async_kernel__/Deferred_or_error/index.html#val-bind)\r\n\\>>\\|? |\t与 Or_error 混合的 map。打开异步将此设置为 [Deferred.Or_error.map](https://ocaml.janestreet.com/ocaml-core/latest/doc/async_kernel/Async_kernel__/Deferred_or_error/index.html#val-map)\r\n\r\n假设您熟悉 monad，可以记录 map 和 bind ，如果您需要更多信息，可能会发现此 [StackOverflow 答案](https://stackoverflow.com/questions/29851449/what-is-the-use-of-monads-in-ocaml/29852213#29852213)很有用。\r\n\r\n>>= 和 >>| 最常出现在 Async 中，但它们也可以与 Option，List，Result 等一起使用。\r\n\r\n### Lwt\r\n\r\n请参阅 [Lwt文档](http://ocsigen.org/lwt/3.1.0/api/Lwt)。\r\n\r\n操作符 | 描述\r\n------------ | -------------\r\n>>=\t| 中缀版本的 [bind]()\r\n=<<\t| 与反转的参数 bind\r\n\\>\\|=\t| 中缀版 map。与 Jane Street 代码中的 >>| 相同 \r\n=\\|<\t| 与反转的参数 map\r\n\r\nLwt 没有 Async 的>>=? 或 >>|? 因为 Lwt.t 可以包含错误而没有单独的 Or_error 模块。\r\n\r\n如果您需要有关 map 和 bind 的信息，请参阅上面的 Jane Street Monad 部分。","source":"source\\_posts\\ocaml-operator-cheatsheet.md"},{"title":"使用 Rebar3 构建您的第一个 Erlang 应用程序","created":"2018/08/10","description":"使用 Rebar3 构建您的第一个 Erlang 应用程序","author":"lanqy","link":"2018/08/10/building-your-first-erlang-app-using-rebar3","htmlDir":"website\\2018\\08\\10\\building-your-first-erlang-app-using-rebar3","htmlFile":"website\\2018\\08\\10\\building-your-first-erlang-app-using-rebar3\\index.html","body":"# 使用 Rebar3 构建您的第一个 Erlang 应用程序\r\n\r\nRebar3 是 Erlang 的构建工具和包管理工具。由于 Rebar3 带有 [Hex](https://hex.pm/) 插件，因此创建和发布 Erlang 软件包非常简单。让我们制作一个简单的 “hello world” 包，随意在家玩！\r\n\r\n## 下载 Rebar3\r\n\r\n在此下载最新版本：[http://www.rebar3.org/](http://www.rebar3.org/)。\r\n\r\n```text\r\ncurl -O https://s3.amazonaws.com/rebar3/rebar3\r\n```\r\n\r\n使用 chmod 使其可执行，然后将其添加到环境变量 PATH。\r\n\r\n```text\r\nchmod +x rebar3\r\nexport PATH=$PATH:your-current-directory\r\n```\r\n\r\n## 你的第一个 Erlang 应用程序\r\n\r\n从命令 rebar3 new 开始，从名为 app 的内置模板生成一个新项目。在这个例子中，我们正在创建一个名为 myapp 的项目。其他可用的模板有：release，lib，plugin，escript，cmake。\r\n\r\n```text\r\n$ rebar3 new app myapp\r\n===> Writing myapp/src/myapp_app.erl\r\n===> Writing myapp/src/myapp_sup.erl\r\n===> Writing myapp/src/myapp.app.src\r\n===> Writing myapp/rebar.config\r\n===> Writing myapp/.gitignore\r\n===> Writing myapp/LICENSE\r\n===> Writing myapp/README.md\r\n```\r\n\r\n包的代码放在 src 目录中。\r\n\r\n```text\r\n$ cd myapp\r\n$ tree\r\n.\r\n├── LICENSE\r\n├── README.md\r\n├── rebar.config\r\n└── src\r\n    ├── myapp.app.src\r\n    ├── myapp_app.erl\r\n    └── myapp_sup.erl\r\n```\r\n\r\n惯例是有一个 .app.src 文件将您的应用程序定义为 OTP 应用程序，因为 Rebar3 只处理 OTP [结构化项目](http://www.erlang.org/doc/design_principles/applications.html)。看起来很熟悉？该文件也是 Erlang 。查看完整[参考](http://www.erlang.org/doc/design_principles/applications.html#id73836)，看看它可以包含什么。\r\n\r\n```erlang\r\n$ cat src/myapp.app.src \r\n{application, 'myapp',\r\n [{description, \"An OTP application\"},\r\n  {vsn, \"0.1.0\"},\r\n  {registered, []},\r\n  {mod, {'myapp_app', []}},\r\n  {applications,\r\n   [kernel,\r\n    stdlib\r\n   ]},\r\n  {env,[]},\r\n  {modules, []}\r\n ]}.\r\n```\r\n\r\nsrc / myapp_app.erl 中的代码非常简单。它只是确保您可以启动和停止您的 Erlang 应用程序：\r\n\r\n```erlang\r\n$ cat src/myapp_app.erl\r\n-module('myapp_app').\r\n-behaviour(application).\r\n-export([start/2, stop/1]).\r\n\r\nstart(_StartType, _StartArgs) ->\r\n    'myapp_sup': start_link().\r\n\r\nstop(_State) ->\r\n    ok.\r\n```\r\n\r\nRebar3 使用名为 rebar.config 的文件来指定附加元数据，例如[依赖项](https://github.com/rebar/rebar/wiki/Dependency-management)。rebar.config 可以包含很多字段。要查看它们，请查看[完整的样本](https://github.com/rebar/rebar/blob/master/rebar.config.sample)。\r\n\r\n```text\r\n$ cat rebar.config \r\n{erl_opts, [debug_info]}.\r\n{deps, []}.\r\n```\r\n\r\n现在让我们使用 Rebar3 启动一个 Erlang shell ，其中包含您的应用程序和路径中的依赖项。运行应用程序：启动（myapp）。验证您的应用是否已正确加载。\r\n\r\n```erlang\r\n$ rebar3 shell\r\n===> Verifying dependencies...\r\n===> Compiling myapp\r\nErlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:8:8] [async-threads:0] [hipe] [kernel-poll:false]\r\nEshell V5.10.4  (abort with ^G)\r\n1> application:start(myapp).\r\nok\r\n2> application:stop(myapp). \r\nok\r\n3> \r\n=INFO REPORT==== 29-Jun-2015::16:14:10 ===\r\n    application: myapp\r\n    exited: stopped\r\n    type: temporary\r\n```\r\n\r\n要了解命令 rebar3 shell，Fred Hebert（[Learn You Some Erlang](http://learnyousomeerlang.com/) 的作者）在[这里](http://ferd.ca/rebar3-shell.html)写了一篇很好的帖子。\r\n\r\n## Erlang 包\r\n\r\n### 在你开始之前\r\n\r\n我们需要安装一个名为 [rebar3_hex](https://github.com/hexpm/rebar3_hex) 的插件，以便使用来自 [Hex.pm](https://hex.pm/)（Erlang / Elixir 包管理器）的获取和安装 Erlang 包。只需将以下行添加到 rebar.config 文件中即可。 （你需要 Erlang 版 OTP 17.4 及以上版本）\r\n\r\n```text\r\n{plugins, [rebar3_hex]}.\r\n```\r\n\r\n然后通过：rebar3 update 命令运行，以启用插件。\r\n\r\n```text\r\n$ rebar3 update\r\n===> Fetching jsx ({pkg,<<\"jsx\">>,<<\"2.6.1\">>})\r\n===> Fetching ssl_verify_hostname ({pkg,<<\"ssl_verify_hostname\">>,\r\n                                           <<\"1.0.5\">>})\r\n===> Fetching rebar3_hex ({pkg,<<\"rebar3_hex\">>,<<\"0.6.0\">>})\r\n===> Compiling ssl_verify_hostname\r\n===> Compiling jsx\r\n===> Compiling rebar3_hex\r\n===> Updating package index...\r\n```\r\n\r\n如果您想在每次创建新的 Erlang 应用程序时避免此步骤，请将该条目添加到全局 rebar.config 并将其放在：\r\n\r\n```text\r\n~/.config/rebar3/rebar.config\r\n```\r\n\r\n## 寻找 Erlang 包\r\n\r\n使用 search 命令可以找到在 [Hex.pm](https://hex.pm/) 上发布的远程 Erlang 包。您可以在查询中使用正则表达式字符：\r\n\r\n```text\r\n$ rebar3 hex search cowboy\r\ncloudi_service_http_cowboy\r\ncowboy\r\n```\r\n\r\n## 安装包\r\n\r\nRebar3 可以下载并安装 Erlang 包和任何必要的依赖项。将应用程序名称添加到 rebar.config 文件中的 deps 条目，然后运行命令：rebar3 compile。在这个例子中，我们尝试使用两个名为 cowboy 和 meck 的Erlang 包。\r\n\r\n```text\r\n{deps, [cowboy, meck]}.\r\n$ rebar3 compile\r\n===> Verifying dependencies...\r\n===> Fetching ranch ({pkg,<<\"ranch\">>,<<\"1.0.0\">>})\r\n===> Fetching meck ({pkg,<<\"meck\">>,<<\"0.8.2\">>})\r\n===> Fetching cowlib ({pkg,<<\"cowlib\">>,<<\"1.0.1\">>})\r\n===> Fetching cowboy ({pkg,<<\"cowboy\">>,<<\"1.0.0\">>})\r\n===> Compiling cowlib\r\n===> Compiling ranch\r\n===> Compiling meck\r\n===> Compiling cowboy\r\n===> Compiling myapp\r\n```\r\n\r\n想要安装特定版本的 Erlang 包吗？将应用程序名称和版本写入元组中。您可以在 [Hex 主页](https://hex.pm/)上浏览包的可用版本。\r\n\r\n```text\r\n{deps, [{cowboy, “1.0.2”}, {meck, \"0.8.3\"}]}.\r\n```\r\n\r\n## 列出已安装的包\r\n\r\nrebar3 deps 命令显示本地安装的软件包：\r\n\r\n```text\r\n$ rebar3 deps\r\ncowboy (locked package 1.0.0)\r\nmeck (locked package 0.8.2)\r\n```\r\n\r\n## 卸载包\r\n\r\n要卸载软件包，首先必须将其从 rebar.config 文件中删除，然后使用命令：rebar3 unlock。在这里，我们从列表中删除了包 meck。\r\n\r\n```text\r\n$ rebar3 unlock\r\n$ rebar3 deps\r\ncowboy (locked package 1.0.0)\r\n```\r\n\r\n## 进一步阅读\r\n\r\nhttp://www.rebar3.org/\r\n","source":"source\\_posts\\building-your-first-erlang-app-using-rebar3.md"},{"title":"Erlang maps 函数 “简单” 的解释","description":"Erlang maps 函数 “简单” 的解释","created":"2018/08/01","author":"lanqy","link":"2018/08/01/erlang-maps-function-simple-explanation","htmlDir":"website\\2018\\08\\01\\erlang-maps-function-simple-explanation","htmlFile":"website\\2018\\08\\01\\erlang-maps-function-simple-explanation\\index.html","body":"# Erlang maps 函数 “简单” 的解释\r\n\r\n译自：https://qiita.com/kayama0fa/items/b0e60644ed40b318a513\r\n\r\n## Erlang maps 函数 “简单” 的解释\r\n\r\n描述 maps 函数，一行的简要说明和示例代码。 有关更多信息，请参阅官方参考。\r\n\r\n原始转发（官方参考）http://erlang.org/doc/man/maps.html\r\n\r\n描述，以便您可以立即找到该功能，并能够大致掌握它的移动方式。 评述的顺序是根据基于主观性的重要性来安排的。\r\n\r\n本页的TODO：\r\n\r\n- 由于它几乎完全写入，检查是否有错误。\r\n- 如果我能负担得起的话，我会做得更好一点。但是如果你写了别的东西，你想增加另一个库。\r\n- 示例代码已改进\r\n\r\n## 创建一个空 maps - maps:new/0\r\n\r\n```erlang\r\nM0 = maps:new(),\r\n```\r\n\r\n## 向 maps 添加值 - maps:put/3\r\n\r\n```erlang\r\nM1 = maps:put(a, 1, M0),\r\nM2 = maps:put(b, 2, M1),\r\nM3 = maps:put(c, 3, M2),\r\nM4 = maps:put(d, \"abc\",M3),\r\nM5 = maps:put(e, <<\"アイウエオ\"/utf8>>, M4), \r\n```\r\n\r\n## 从 maps 中取值 - maps:get/2, maps:get/3\r\n\r\n```erlang\r\n1 = maps:get(a, M5),\r\nnot_found = maps:get(g, M5, not_found),\r\n```\r\n\r\n## 从 maps 中删除值 - maps:remove/2\r\n\r\n```erlang\r\nM4 = maps:remove(e, M5),\r\nM5 = maps:remove(d, M4),\r\n```\r\n\r\n## 从 maps 中查找和检索值 - maps:find/2\r\n\r\n```erlang\r\n{ok, _} = maps:find(e, M5),\r\nerror = maps:find(g, M5),\r\n```\r\n\r\n## 检查 maps 是否具有指定的 key - maps:is_key/2\r\n\r\n```erlang\r\ntrue = maps:is_key(a, M5),\r\nfalse = maps:is_key(x, M5),\r\n```\r\n\r\n## 获取在 maps 中注册的数据数量 - maps:size/1\r\n\r\n```erlang\r\n5 = maps:size(M5),\r\n1 = maps:size(M1),\r\n0 = maps:size(M0),\r\n```\r\n\r\n## 获取在 maps 中注册的 keys 列表 - maps:keys/1\r\n\r\n```erlang\r\n[a, b, c] = lists:sort(maps:keys(M3)),\r\n```\r\n\r\n## 获取在 maps 中注册的值列表 - maps:valus/1\r\n\r\n```erlang\r\n[1,2,3] = lists:sort(maps:values(M3)),\r\n```\r\n\r\n## maps 一个列表的 keys 和 值的元组 - maps:to_list/1\r\n\r\n```erlang\r\n[{a, 1},{b, 2}] = maps:to_list(M2),\r\n```\r\n\r\n## 从 keys 和值元组列表中获取 maps - maps:from_list/1\r\n\r\n```erlang\r\nM2 = maps:from_list([{a, 1}, {b, 2}]),\r\n```\r\n\r\n## 将任意筛选应用于 maps 以创建新 maps - maps:filter/2\r\n\r\n```erlang\r\nFilterM = maps:from_list([{a, 1},{b, 2}]),\r\nFilterM = maps:filter(fun(_K, V) -> (V rem 3) =:= 1 end, M3),\r\n```\r\n\r\n## 在 maps 上执行卷积操作 - maps:fold/3\r\n\r\n```erlang\r\n6 = maps:fold(fun(_, V, Acc) when is_integer(V) -> V + Acc; (_, _, Acc) -> Acc end, 0, M5),\r\n```\r\n\r\n## 返回 maps 的每个值的任意处理结果 - maps:map/2\r\n\r\n```erlang\r\nNewMap = maps:from_list([{a, 10}, {b, 20}, {c, 30}]),\r\nNewMap = maps:map(fun(_K, V) -> V * 10 end, M3),\r\n```\r\n\r\n## 合并两个 maps - maps:merge/2\r\n\r\n％如果存在相同的键，则优先考虑第二个 maps 的值\r\n\r\n```erlang\r\nMapA = maps:from_list([{a, 10}, {b, 20}]),\r\nMapB = maps:from_list([{a, 1}, {c, 30}]),\r\nMapAB = maps:from_list([{a, 1}, {b, 20}, {c, 30}]),\r\nMapAB = maps:merge(MapA, MapB),\r\n```\r\n\r\n## 更新 maps 的任何键的值 - maps:update/3\r\n\r\n```erlang\r\nUpdateMap1 = maps:from_list([{a, 1}, {b, 2}]),\r\nUpdateMap2 = maps:from_list([{a, 10}, {b, 2}]),\r\nUpdateMap2 = maps:update(a, 10, UpdateMap1),\r\n```\r\n\r\n## 用函数更新 maps 任意键的值 - maps:update_with/3\r\n\r\n```erlang\r\nUpdateMap2 = maps:update_with(a, fun(V) -> V * 10 end, UpdateMap1),\r\n```\r\n\r\n## 来自 update_with/3，一个可以在没有 key 时指定默认值的函数 - maps:update_with/4\r\n\r\n```erlang\r\nUpdateMap3 = maps:from_list([{a, 1}, {b, 2}, {c, 3}]),\r\nUpdateMap3 = maps:update_with(c, fun(V) -> V * 10 end, 3, UpdateMap1),\r\n```\r\n\r\n## 仅使用指定的键从 maps 中重新创建 maps - maps:with/2\r\n\r\n```erlang\r\nWithKeys = [a, c],\r\nWithMap1 = maps:from_list([{a, 1},{b, 2}, {c, 3}]),\r\nWithMap2 = maps:from_list([{a, 1}, {c, 3}]),\r\nWithMap2 = maps:with(WithKeys, WithMap1),\r\n```\r\n\r\n## 使用非指定的键重建 maps，使用 with/2 相反的键 - maps:without/2\r\n\r\n```erlang\r\nWithMap3 = maps:from_list([{b, 2}]),\r\nWithMap3 = maps:without(WithKeys, WithMap1),\r\n```\r\n\r\n## 从已删除该键的 maps 和 maps 中返回任意键的值 - take/2\r\n\r\n```erlang\r\n{2, M1} = maps:take(b, M2)\r\n```\r\n","source":"source\\_posts\\erlang-maps-function-simple-explanation.md"},{"title":"Erlang 入门","description":"Erlang 入门","created":"2018/07/31","author":"lanqy","link":"2018/07/31/getting-start-erlang","htmlDir":"website\\2018\\07\\31\\getting-start-erlang","htmlFile":"website\\2018\\07\\31\\getting-start-erlang\\index.html","body":"\r\n# Erlang 入门\r\n\r\n 译自：https://qiita.com/oskimura/items/87910c2e76cac075ee7f\r\n\r\n## Erlang 入门\r\n\r\nErlang 是一种支持语言和 VM 并行处理的函数式语言。此外，Erlang 受到 Prolog 及其并行逻辑语言的强烈影响，后者是其继承者，其效果可见于 VM 的语法和结构。\r\n\r\n### 安装\r\n\r\n#### Windows\r\n\r\n从 http://www.erlang.org/downloads 下载安装程序并安装它。\r\n\r\n#### Mac\r\n\r\n```text\r\nbrew install erlang\r\n```\r\n\r\n你可以安装\r\n\r\n#### Linux\r\n\r\n如果是 Debian\r\n\r\n```text\r\napt install erlang\r\n```\r\n\r\n### 对话环境\r\n\r\n#### Windows\r\n\r\n```text\r\n\"Start\" -> \"All Programs\" -> \"Erlang OTP\" -> \"Erlang\"\r\n```\r\n\r\n#### Mac & Linux\r\n\r\n通过从终端输入来建立对话环境。我们来试试吧。\r\n\r\n```text\r\n$ erl\r\n```\r\n\r\n```erlang\r\n$ erl\r\nErlang R16B03 (erts-5.10.4) [source] [64-bit] [async-threads:10] [kernel-poll:false]\r\n\r\nEshell V5.10.4  (abort with ^G)\r\n1> 1+2+3.\r\n6\r\n2>\r\n```\r\n\r\n6 它将显示。这是 1 + 2 + 3. 计算公式的结果。Erlang 使用 . 代替 ;。\r\n\r\n### 编译\r\n\r\n用 c 命令编译 。\r\n\r\n由于 Erlang 在名为 BEAM 的 VM 上运行，因此它被编译为在 VM 上运行的二进制文件。 \r\n\r\n我们将此文件称为梁文件。\r\n\r\n创建的文件是\r\n\r\n```shell\r\n$ erl - pz. - noshell - noinput - s module - name function - s init stop\r\n```\r\n\r\n您可以在终端上键入并运行。\r\n\r\n但是，如果您想轻松运行它，它会更方便使用。\r\n\r\n### escript\r\n\r\n在escript中，Erlang的程序可以像Perl脚本一样执行。\r\n\r\n```erlang\r\n#!/usr/bin/env escript\r\n%% -*- erlang -*-\r\n%%! -smp enable -sname factorial -mnesia debug verbose\r\nmain([String]) ->\r\n    try\r\n        N = list_to_integer(String),\r\n        F = fac(N),\r\n        io:format(\"factorial ~w = ~w\\n\", [N,F])\r\n    catch\r\n        _:_ ->\r\n            usage()\r\n    end;\r\nmain(_) ->\r\n    usage().\r\nusage() ->\r\n    io:format(\"usage: factorial integer\\n\"),\r\n    halt(1).\r\n\r\nfac(0) -> 1;\r\nfac(N) -> N * fac(N - 1).\r\n```\r\n\r\n```text\r\n$ chmod u+x factorial\r\n```\r\n\r\n```text\r\n$ ./factorial 5\r\nfactorial 5 = 120\r\n```\r\n\r\n\r\n```text\r\n$ ./factorial\r\nusage: factorial integer\r\n```\r\n\r\n\r\n\r\n```text\r\n$ ./factorial\r\nusage: factorial integer\r\n```\r\n\r\n```text\r\n$ ./factorial five\r\nusage: factorial integer\r\n```\r\n\r\n```text\r\n$ escript factorial 5\r\n```\r\n\r\n等等。\r\n\r\n有关详细信息，请参阅 [escript manual](http://erlang.org/doc/man/escript.html)。\r\n\r\n### 整数和实数\r\n\r\n```erlang\r\n4> 2#0101.\r\n5\r\n5> 16#deadbeaf.\r\n3735928495\r\n```\r\n\r\n作为 # 你可以通过在前面放置一个数字来将 N-ary 符号提高到 36 位小数。\r\n\r\nErlang 是一个多精度整数。\r\n\r\nIEEE 754格式的浮点数在 1.0e−323 到 1.0e+308 范围内\r\n\r\n### 文字列\r\n\r\n字符前面是 ASCII 字符 $ 。用双引号括起字符串。这是字母列表的糖涂层语法。列表将描述以下内容。\r\n\r\n它需要以后面描述的二进制表示。\r\n\r\n```erlang\r\n7> $a.\r\n97\r\n8> \"a\".\r\n\"a\"\r\n9> [$a,$b].\r\n\"ab\"\r\n```\r\n\r\n### 变量\r\n\r\nErlang 变量名以大写字母开头。\r\n\r\n```erlang\r\n10> X = 1.\r\n1\r\n11> X.\r\n1\r\n```\r\n\r\n这是变量 X 在 1 中的值，通过代入 X 的值。\r\n\r\n我们将用后面描述的模式匹配来解释赋值。\r\n\r\n### 操作符\r\n\r\n#### 算术运算符\r\n\r\n- `+`\r\n加\r\n- `*`\r\n乘\r\n- `-`\r\n减\r\n- `/`\r\n除\r\n- `div`\r\n整数除法\r\n- `rem`\r\n整数除法的余数\r\n\r\n它基本上与C语言和Java相同。div和rem分别是除数时的商和余数。\r\n\r\n#### 比较运算符\r\n\r\n- `>`\r\n大于\r\n- `<`\r\n小于\r\n- `>=`\r\n大于等于\r\n- `=<`\r\n小于等于\r\n- `==`\r\n等于\r\n- `/=`\r\n不等于\r\n- `=:=`\r\n相等（带类型检查）\r\n- `=/=`\r\n不等于（带类型检查）\r\n\r\n#### 算术运算符\r\n\r\n- `not`\r\n否定\r\n- `and`\r\n和\r\n- `andalso`\r\n和顺便（短路）\r\n- `or`\r\n或\r\n- `orelse`\r\n或者其他（短路）\r\n- `xor`\r\n独家理论和\r\n\r\n### 条件分支\r\n\r\n#### if\r\n\r\n```erlang\r\nif\r\n    <conditional expression> -> <form 1>;\r\n    <Conditional> -> <Formula 2>\r\nend\r\n```\r\n\r\n因为 Erlang 有一个模式匹配，所以 if 使用不多。\r\n\r\n对于条件分支，我们经常使用模式匹配，如稍后所述。\r\n\r\n### 原子\r\n\r\n原子代表一个标识符。小写字母如果包含以字母或符号开头的字母数字字符，则必须将它们括在反引号中。\r\n\r\n```erlang\r\n1> abc.\r\nabc\r\n```\r\n\r\n当然，您可以将其分配给变量。\r\n\r\n```erlang\r\n2> X = abc.\r\nabc\r\n3> X.\r\nabc\r\n```\r\n\r\nAtom 经常用于 Erlang 编程，因为它便于后面描述的元组和消息的模式匹配。\r\n\r\n### 输出\r\n\r\n在 Erlang 中，输出到控制台 io:format 是使用通常调用的函数完成的。\r\n\r\n#### io:format\r\n\r\nErlang 的格式化输出是通过 io:format完成。printf它对应于C语言，但格式化的输出格式类似于 Common Lisp 或者来自 C 的 Common Lisp。\r\n\r\n```erlang\r\nio:format(\"~p~n\", [Term]).\r\n```\r\n\r\n- `~p` 漂亮打印\r\n- `~s` 文本列\r\n- `~n` 更改行数\r\n- `~d` 整数（十进制数）\r\n\r\nErlang 使用列表，因为没有像 C 语言这样的可变参数。\r\n\r\n### 模式匹配\r\n\r\n#### 案例部分\r\n\r\n```erlang\r\ncase <type> of\r\n    <表达式1> -> <式1>;\r\n    <表达式2> -> <式2>\r\nend\r\n```\r\n\r\ncase 子句是最简单的模式匹配形式。\r\n\r\n```erlang\r\n2> A = 3.\r\n3\r\n3> case A of 1 -> a; 2 -> b; 3 -> c end.\r\nc\r\n```\r\n\r\n将返回 c ，它也可以像这样的C语言 switch 句子。\r\n\r\n如果我们从此表达式中排除最后一次模式匹配的处理，会发生什么？\r\n\r\n```erlang\r\n4> case A of 1 -> a; 2 -> b end.\r\n** 异常错误：没有 case 子句匹配3\r\n5>\r\n```\r\n\r\n像这样发生异常。这是一个例外，意味着没有条件匹配模式匹配。\r\n\r\n#### 通配符\r\n\r\n然后如何更改它如下？它是通配符，并且在每种情况下都匹配。\r\n\r\n```erlang\r\n5> case A of 1 -> a; 2 -> b; _ -> c end.\r\nc\r\n```\r\n\r\n#### 单赋值\r\n\r\n```erlang\r\n6> X = 1.\r\n```\r\n实际上，替换实际上是一种模式匹配。\r\n\r\n`=` 操作符在左侧表达式的右侧执行模式匹配。如果左边的变量尚未绑定，则计算右边表达式的值将被绑定。`=` 当然，如果表达式左侧的模式匹配失败，则会引发异常。\r\n\r\n在这个例子中，因为它只是一个像数字类型的简单类型，我认为它的用处很难理解。通过结合后面描述的列表，记录，元组等，您可以以非常多样化的方式使用它。\r\n\r\n模式匹配是 Erlang 的核心功能。\r\n\r\n### 函数\r\n\r\n```erlang\r\n<function name> (参数...) -> \r\n函数主体<body>.\r\n```\r\n\r\n例如，下面是一个函数，用于递增指定为参数的变量。函数定义是这样的。\r\n\r\n```erlang\r\ninc(X) -> X + 1.\r\n```\r\n\r\n### 函数和模式匹配\r\n\r\nErlang 还可以对函数参数执行模式匹配。\r\n\r\n```erlang\r\nsignal(red) -> stop;\r\nsignal(blue) -> do;\r\nsignal(yellow) -> carefull;\r\nsignal(_) -> error.\r\n```\r\n\r\n#### 递归\r\n\r\n由于 Erlang 没有循环控制语法(如 C 语言中的语句)，因此循环处理是递归进行的。\r\n\r\n我将编写一个函数来查找阶乘。\r\n\r\n```erlang\r\npow(1) -> 1;\r\npow(X) -> X * pow(X - 1).\r\n```\r\n\r\n#### 尾递归\r\n\r\n可以通过使用尾递归的形式来优化循环。\r\n\r\n```erlang\r\npow_tail(1, Ret) -> Ret;\r\npow_tail(X, Ret) -> pow_tail(X - 1, X * Ret).\r\n```\r\n\r\n简单地说，尾递归形式不计算递归函数的返回值，因此不需要每次都将函数的返回点堆栈在堆栈帧上，因此可以像循环一样在内部处理它\r\n\r\n有兴趣的人请自己研究。\r\n\r\n### 记录\r\n\r\n这是一个所谓的结构。\r\n\r\n```erlang\r\n-record(<记录名>, {<元素名1>, <元素名2>, ...}).\r\n```\r\n\r\n还提供了一种称为定义记录的函数的 rd 语法糖。\r\n\r\n```erlang\r\nrd(item, {id, name, price}).\r\n```\r\n\r\n```erlang\r\n7> rd(player, {name, hp}).\r\nplayer\r\n```\r\n\r\n#### 初始化\r\n\r\n```erlang\r\n# <记录名> {<元素名1> = 初始值1, <元素名1> = 初始值2, ...}\r\n```\r\n\r\n可以以这种形式进行记录初始化。\r\n\r\n```erlang\r\n9> P = #player{name=\"hoge\", hp=3}.\r\n```\r\n\r\n#### 引用\r\n\r\n```erlang\r\nVariable#<record name>.<Element>\r\n```\r\n\r\n上面提到它。\r\n\r\n```erlang\r\n10>P#player.name\r\n\"hoge\"\r\n```\r\n\r\n#### 更改\r\n\r\n```erlang\r\nVariable#<record name>{<element> = \"hage\"}.\r\n```\r\n\r\n通过这样做，它返回更改记录元素的记录。\r\n\r\n```erlang\r\n11> P#player{name=\"hage\"}.\r\n#player{name = \"hage\", hp = 2}\r\n```\r\n\r\n#### 记录模式匹配\r\n\r\n在左侧\r\n\r\n```erlang\r\n# <Record name> {<element name 1> = value, <element name 2> = variable name, ..}\r\n```\r\n\r\n你可以用搭配的形式进行模式匹配。\r\n\r\n```erlang\r\n2> P = #item{id = 1, name=\"test\", price=100}.\r\n3> #item{id=1} = P.\r\n#item{id = 1, name = \"test\", price = 100}.\r\n4> #item{id = 1, name = Name} = P.\r\n#item{id = 1, name = \"test\", price = 100}\r\n5> Name.\r\n\"test\"\r\n```\r\n\r\n### 列表\r\n\r\n```erlang\r\n[<element 1>, <element 2>...]\r\n```\r\n\r\n```erlang\r\n1> [1,2,3].\r\n[1,2,3]\r\n```\r\n\r\n这与 Lisp 等列表相同。内部缺点，最后一个是递归结构，单元格类似于Lisp nil。这将在后面描述。\r\n\r\n#### 列表处理\r\n\r\n该列表可以通过模式匹配来处理。\r\n\r\n接下来，我们以一个计算列表长度的函数为例。\r\n\r\n```erlang\r\nlen([]) ->\r\n    0;\r\nlen([Head|Tail]) ->\r\n    1 + len(Tail).\r\n```\r\n\r\n[] 匹配空列表。\r\n\r\n[Head|Tail] Head 标识列表头, 例如, [1,2,3] Head 匹配 1， Tail 匹配 [2,3].\r\n\r\n处理列表的函数是组织成称为标准库的模块的列表。\r\n\r\n### 元组\r\n\r\n```erlang\r\n{<Element 1>, <element 2>...}\r\n```\r\n\r\n```erlang\r\n1> {1,2,3}.\r\n{1,2,3}\r\n```\r\n\r\n在 Erlang 中经常使用元组而不是 Lisp 的 S 表达式。\r\n\r\n### 二进制\r\n\r\n```erlang\r\n<< <Value 1>: <Size 1> / <Type>, <Value 2>: <Size 2> / <Type> ... >>\r\n```\r\n您可以为每个尺寸指定一个大小的值。如果省略大小规范，则默认为 8 位。按此大小的大小划分的块称为段。\r\n\r\n可以指定类型，类型，代码，字节序，多种类型 - 可以连接。 可能的类型如下所列。\r\n\r\n类型\r\n\r\n- `integer` 整型\r\n- `float` 浮点数\r\n- `binary` 二进制类型\r\n- `bytes` 字节型\r\n- `bitstring` 位串\r\n- `bits` 位类型\r\n- `utf8` UTF-8 位字符串\r\n- `utf16` UTF16 的位串\r\n- `utf32` UTF32 位字符串\r\n\r\n符号\r\n\r\n- `signed` 有符号的\r\n- `unsigned` 无符号\r\n\r\n尾数法\r\n\r\n- `big` 大端字节序\r\n- `little` 小端字节\r\n- `native` CPU 原生端\r\n- `unit` 段的大小\r\n\r\n#### 二元运算符\r\n\r\n- `bsl` 左移位\r\n- `bsr` 右移位\r\n- `band` 比特理论\r\n- `bor` 比特理论和\r\n- `bxor` 比特独家论证和\r\n- `bnot` 比特论证否定\r\n\r\n#### 二进制模式匹配\r\n\r\n作为二进制模式匹配的示例，我将展示 RGB 颜色的示例。\r\n\r\n```erlang\r\n1> Color = <<16#FF00FF:(8*3)>>.\r\n<<255,0,255>>\r\n```\r\n\r\n`,` 您可以将每个 8 位 RGB 定义为相隔。\r\n\r\n```erlang\r\n2> <<R,G,B>> = Color.\r\n<<255,0,255>>\r\n```\r\n\r\n这样，它可以通过模式匹配每 8 位进行分解。\r\n\r\n如果只想要第一个 R ，可以使用通配符通过以下方式编写来获得它。\r\n\r\n```erlang\r\n2> <<R:8,_/binary>> = Color.\r\n<<255,0,255>>\r\n3> R.\r\n255\r\n```\r\n\r\n顺便说一句，在 Erlang 中处理像日语这样的多字节字符\r\n\r\n```erlang\r\nio:format(\"~ts~n\",[<<\"お\"/utf8>>]).\r\n```\r\n\r\n必须以二进制格式指定UTF-8，如下所示 有关详细信息，请参阅 [Erlang 文档](http://erlang.org/doc/programming_examples/bit_syntax.html)。\r\n\r\n### 理解符号\r\n\r\n有两种类型的理解符号：列表理解符号和二进制理解符号。\r\n\r\n最初，理解符号是表示一组与集合论中的条件 P 一致的元素的符号。\r\n\r\n试图表达这一点的符号被介绍给米兰达。这种表示法后来被合并到 Haskell 和 Python 中。\r\n\r\n#### 列表理解符号\r\n\r\n 进入 `erl`\r\n\r\n ```erlang\r\nErlang R16B03 (erts-5.10.4) [source] [64-bit] [async-threads:10] [kernel-poll:false]\r\n\r\nEshell V5.10.4  (abort with ^G)\r\n1> [ X * 2 || X <- [1,2,3,4,5], X < 4 ].\r\n[2,4,6]\r\n ```\r\n\r\n 这个 X < - [1,2,3,4,5] 产生一个列表。\r\n\r\n 接下来，X < 4 它匹配条件 1 2 3 但被过滤，\r\n\r\n 最后列表 X * 2 由 1 * 2 , 2 * 2 , 3 * 2 创建公式。\r\n\r\n 概括如下：\r\n\r\n ```erlang\r\n[Expression || pattern <- list, condition]\r\n ```\r\n\r\n 二元理解是理解符号的二进制版本。\r\n\r\n ```erlang\r\n<< expression || pattern <= binary, condition >>\r\n ```\r\n\r\n ### 并行\r\n\r\n Erlang 中的并行处理是通过轻量级进程（进程）和消息实现的。\r\n\r\n Erlang 的过程类似于 OS 过程，但它由 Erlang 的 VM 执行，因此操作系统内的上下文切换没有完成。\r\n\r\n Erlang 的进程通过消息队列进行通信，而不共享内存区域。\r\n\r\n 切换速度很快，因为 Erlang 的进程不涉及复杂的上下文切换，例如临时保存寄存器和切换到内核模式。\r\n\r\n #### Actor 模型\r\n\r\n 我将简要介绍作为 Erlang 并行模型的 Actor 模型。\r\n\r\n 一个叫做 actor 的对象，能够发送和接收消息 通过异步发送和接收消息并行执行计算处理的计算模型。在 Erlang 中，该过程相当于一个 actor ，我们正在相互发送和接收消息。 除了 Erlang 之外，这个 actor 模型的概念被采用为 Scala 的框架等\r\n\r\n#### spawn\r\n\r\nspawn 通过以下方式调用它来生成轻量级进程。\r\n\r\n```erlang\r\nPid = spawn (<module name>, <function name>, <list of arguments>)\r\n```\r\n\r\nspawn 从参数函数创建一个进程，并为每个进程返回一个唯一的数值，称为进程 ID。\r\n\r\n进程 ID 和进程是链接的，此进程 ID 用于在进程之间发送和接收消息。\r\n\r\n#### 发送消息\r\n\r\n要发送消息，请将消息以消息的形式发送到您想要发送的流程的进程 ID ，如下所示。\r\n\r\n```erlang\r\nPid! Message\r\n```\r\n\r\n#### 接收消息\r\n\r\n通过以下方式接收消息并通过模式匹配执行与消息相对应的处理是常见的。\r\n\r\n```erlang\r\nreceive\r\n    <Pattern 1> ->\r\n        <Process 1>;\r\n    <Pattern 2> ->\r\n        <Process 2>;\r\n    \r\n    .........\r\n\r\n    <Pattern N> ->\r\n        <Process N>\r\n    after n ->\r\n        < Timeout processing>\r\nend\r\n```\r\n\r\nafter 将进程在 n 毫秒后超时。\r\n\r\n#### 进程注册\r\n\r\nspawn 对程序员来说每次都要保存变量生成的进程 ID 很麻烦。特别是当多个程序创建程序来发送消息时，管理变得非常麻烦。\r\n\r\nErlang 有一种通过指定原子而不是进程 ID 来发送消息的方法。\r\n\r\n这是流程注册。 register 使用该函数注册进程。\r\n\r\n由于它超出了本文档的范围，因此不对其进行详细描述，但是进程注册功能通常用于分布式环境中。\r\n\r\n```erlang\r\nregister(Atom,Pid)\r\n```\r\n\r\n通过 Atom ! the message 您可以在进程中发送已经以所述形式向 atom 注册的消息。\r\n\r\n### spawn_link\r\n\r\nspawn_link 基本上是 spawn 相同，但是当发生异常时行为会有所不同。 该进程的父进程会在生成的子进程中创建一个异常。 spawn，父进程不会收到异常。\r\n\r\n\r\n### 异常\r\n\r\n我这样写异常。\r\n\r\n```erlang\r\ntry <evaluated expression> of\r\n    <pattern 1> guard 1 -> <process 1>;\r\n    <pattern 2> guard 2 -> <process 2>;\r\ncatch\r\n    <exception type 1>: <pattern 1> guard 1 -> <Exception processing 1>;\r\n    <exception type 2>: <pattern 2> guard 2 -> <Exception processing 2>\r\nafter\r\n    <Processing executed even if an exception occurs but not occurring>\r\nend\r\n```\r\n\r\ntry ... of 当在封闭的表达式中出现异常时，将在其后执行一个捕捉模式匹配，并在执行异常处理后执行处理。\r\n\r\n以下是引发异常的函数。\r\n\r\n#### 抛出异常\r\n\r\n您可以按如下方式引发异常。\r\n\r\n```erlang\r\nthrow(<表达式>)\r\n```\r\n\r\n#### 退出\r\n\r\n它引发了如下异常并终止了该过程。\r\n\r\n```erlang\r\nexit(<表达式>)\r\n```\r\n#### 错误\r\n\r\n我们将提出一个严重的例外，并终止如下过程。\r\n\r\n错误主要用于 Eralng 的 VM 生成的运行时错误。\r\n\r\n```erlang\r\nerror(<表达式>)\r\n```\r\n\r\n### 模块\r\n\r\n当以描述源的文件为单位进行编译时，模块是最小的单元。除非属于某个模块，否则无法编译源代码。\r\n\r\n要创建模块，您需要在.erl 文件中描述模块属性，例如模块声明 。\r\n\r\n#### 模块属性\r\n\r\n```erlang\r\n-module(<module name>).\r\n```\r\n\r\n#### 导出声明\r\n\r\n声明导出声明函数。请连接 函数名称的参数个数如下 `/`。您可以按如下方式导出模块创建的所有功能。\r\n\r\n```erlang\r\n-export([<函数名1>/<参数1>>, <函数名2>/<参数2>>])\r\n\r\n-export_all\r\n```\r\n\r\n#### 编译选项声明\r\n\r\n为编译器指定[此选项](http://erlang.org/doc/man/compile.html)。\r\n\r\n#### 宏定义\r\n\r\n宏可以定义如下。\r\n\r\n```erlang\r\n-define{<macro>，<expression>}\r\n```\r\n\r\n#### 记录声明\r\n\r\n记录可以声明如下。\r\n\r\n```erlang\r\n-record(<记录名>, {<元素名1>, <元素名2>,...}).\r\n```\r\n\r\n#### include\r\n\r\n头文件可以包括如下。\r\n\r\n```erlang\r\n-include(\"<header file>\").\r\n```\r\n\r\n头文件扩展名为.hrl。\r\n","source":"source\\_posts\\getting-start-erlang.md"},{"title":"理解JS：事件循环","created":"2018/07/26","description":"理解JS：事件循环","author":"lanqy","link":"2018/07/26/understanding-js-the-event-loop","htmlDir":"website\\2018\\07\\26\\understanding-js-the-event-loop","htmlFile":"website\\2018\\07\\26\\understanding-js-the-event-loop\\index.html","body":"# 理解JS：事件循环\r\n\r\n译自：https://hackernoon.com/understanding-js-the-event-loop-959beae3ac40\r\n\r\n由于大量的库，工具和各种使您的开发变得更容易的东西，许多程序员开始构建应用程序而不必深入了解某些内容的工作原理。JavaScript 是这种确切行为的典型代表。虽然它是最复杂的语言之一并且传播最广泛，但许多开发人员都被使用更高级别的工具和抽象语言的“坏部分”所吸引。\r\n\r\n虽然您仍然可以构建令人惊叹的应用程序，但进入 JavaScript 漩涡对您来说非常有益。理解“怪异部分”是将普通编码者与高级开发人员分开的原因，而 JS 生态系统不断变化，其基础是构建所有其他工具的基础。了解这些可以让您更广泛地了解并改变您对开发过程的看法。\r\n\r\n## 什么是事件循环？\r\n\r\n你可能听说 JavaScript 是一种单线程语言。您甚至可能听说过 Call Stack 和 Event Queue 这两个术语。大多数人都知道事件循环允许 JavaScript 使用回调和承诺（ promises ），但还有更多内容。但还有很多东西。在不深入细节的情况下，我们将高度了解 JavaScript 代码的实际执行方式。\r\n\r\n## 调用堆栈\r\n\r\nJavaScript 有一个单独的调用堆栈，它跟踪我们当前正在执行的函数以及之后要执行的函数。首先，什么是堆栈?堆栈是一种类似数组的数据结构，但是有一些限制——您只能在后面添加项，并且只删除最后一个项。另一个例子是一堆盘子——你把它们放在一起，在任何时候你只能把最上面的拿走。\r\n\r\n当您要执行某个函数时，它会被添加到调用堆栈中。然后，如果该函数调用另一个函数 - 另一个函数将位于调用堆栈中的第一个函数之上。当您在控制台中收到错误时，您将得到一条长长的消息，该消息显示了执行路径——这正是栈在那个时刻所看到的。但是，如果我们发出请求或对某件事超时怎么办?理论上，应该冻结整个浏览器直到它被执行，这样调用堆栈才能继续?但是在实践中，您知道这不会发生——因为事件表和事件队列。\r\n\r\n## 事件表和事件队列\r\n\r\n每次调用 setTimeout 函数或执行异步操作时，都会将其添加到事件表中。这是一种数据结构，它知道在某个事件之后应该触发某个功能。一旦发生该事件（超时，单击，鼠标移动），它就会发送通知。请记住，事件表不执行函数，也不会将它们添加到调用堆栈中。它的唯一目的是跟踪事件并将其发送到事件队列。\r\n\r\n事件队列是一个类似于堆栈的数据结构 - 再次向后面添加项目但只能从前面删除它们。它存储了执行函数的正确顺序。它接收来自事件表的函数调用，但它需要以某种方式将它们发送到调用堆栈？这就是Event Loop的用武之地。\r\n\r\n## 事件循环\r\n\r\n我们终于到达了臭名昭着的 Event Loop。这是一个持续运行的进程，用于检查调用堆栈是否为空。想象它就像一个时钟，每次滴答时都会查看调用堆栈，如果它是空的，它会查看事件队列。如果事件队列中有某些东西正在等待，则会将其移动到调用堆栈。如果没有，那么没有任何反应。\r\n\r\n这里有几个有趣的案例。您认为以下代码将以什么顺序运行？\r\n\r\n```javascript\r\nsetTimeout(() => console.log('first'), 0)\r\nconsole.log('second')\r\n```\r\n有些人认为因为设置超时被调用0（零），它应该立即运行。事实上，在这个具体的例子中，你会看到 “second” 在 “first” 之前打印出来。JavaScript 看到了 setTimeout 并说“好吧，我应该将它添加到我的事件表并继续执行”。然后它将通过事件表，事件队列并等待事件循环勾选以便运行。\r\n\r\n## 应用\r\n\r\n事件循环行为的另一个有趣的例子是递归。您是否见过堆栈溢出错误消息?当你进行无限递归时，你有时会得到这个结果但有时你会有大量的递归调用。这里有一个简单而简单的解决方案，它将允许您保留代码结构并仍然进行大量调用——在 setTimeout 中包装递归调用。与直接调用 recursion() (设想这是您的方法的名称)相反，您可以调用 setTimeout(() => recursion(), 0).这将避免堆栈溢出，因为调用将经过事件表和队列，而不是直接堆积在堆栈上。尽量避免使用这种方法，但这是 JavaScript 行为的一个很好的例子。\r\n\r\n## 结束\r\n\r\n还有更多的事情在发生，这只是循环和它周围的一切的基本解释。尽管我希望尽可能地保持简单，但如果不深入整个过程，就无法解释事件循环做了什么。需要注意的是，这个解释是在 V8 JavaScript 引擎的上下文中进行的。它是 Chrome 背后的引擎，也用于 Node。","source":"source\\_posts\\understanding-js-the-event-loop.md"},{"title":"F# 备忘单","description":"F# 备忘单","created":"2018/07/19","author":"lanqy","link":"2018/07/19/fsharp-cheatsheet","htmlDir":"website\\2018\\07\\19\\fsharp-cheatsheet","htmlFile":"website\\2018\\07\\19\\fsharp-cheatsheet\\index.html","body":"\r\n# F# 备忘单\r\n\r\n译自：https://dungpa.github.io/fsharp-cheatsheet/\r\n\r\n这张备忘单浏览了一些 F# 3.0 的常用语法。如果您有任何意见，更正或建议添加内容，请打开问题或发送拉取请求到https://github.com/dungpa/fsharp-cheatsheet。\r\n\r\n## 注释\r\n\r\n块注释放在 (* 和 *) 之间。行注释从 // 开始并一直持续到行结束。\r\n\r\n```text\r\n(* 这是块注释 *)\r\n\r\n// 这是行注释\r\n```\r\n\r\n在 /// 允许我们使用 XML 标记生成文档后，XML 文档注释就会出现。\r\n\r\n```fsharp\r\n/// `let`关键字定义了一个（不可变的）值\r\nlet result = 1 + 1 = 2\r\n```\r\n\r\n## 字符串\r\n\r\nF# 字符串类型是 System.String 类型的别名。\r\n\r\n```fsharp\r\n/// 使用字符串连接创建字符串\r\nlet hello = \"Hello\" + \"World\"\r\n```\r\n\r\n使用以 @ 符号开头的逐字字符串以避免转义控制字符（除了通过 \"\" 转义 \"）。\r\n\r\n```fsharp\r\nlet verbatimXml = @\"<book title=\"\" Paradise Lost \"\">\"\r\n```\r\n我们甚至不必转义 \" 使用三引号字符串。\r\n\r\n```fsharp\r\nlet tripleXml = \"\"\"<book title=\"Paradise Lost\">\"\"\"\r\n```\r\n\r\n反斜杠字符串通过去除前导空格来缩进字符串内容。\r\n\r\n```fsharp\r\nlet poem = \r\n    \"The lesser world was daubed\\n\\\r\n     By a colorist of modest skill\\n\\\r\n     A master limned you in the finest inks\\n\\\r\n     And with a fresh-cut quill.\"\r\n```\r\n\r\n## 基本类型和文字\r\n\r\n大多数数字类型都有相关的后缀，例如，uy 表示无符号 8 位整数，L 表示有符号 64 位整数。\r\n\r\n```fsharp\r\nlet b, i, l = 86uy, 86, 86L\r\n\r\nval b : byte = 86uy\r\nval i : int = 86\r\nval l : int64 = 86L\r\n```\r\n\r\n其他常见的例子是 32 位浮点数的 F 或 f ，小数的 M 或 m ，大整数的 I。\r\n\r\n```fsharp\r\nlet s, f, d, bi = 4.14F, 4.14, 0.7833M, 9999I\r\n\r\nval s : float32 = 4.14f\r\nval f : float = 4.14\r\nval d : decimal = 0.7833M\r\nval bi : System.Numerics.BigInteger = 9999\r\n```\r\n\r\n有关完整参考，请[参阅文字（MSDN）](http://msdn.microsoft.com/en-us/library/dd233193.aspx)。\r\n\r\n## 函数\r\n\r\nlet 关键字还定义了命名函数。\r\n\r\n```fsharp\r\nlet negate x = x * -1\r\nlet square x = x * x\r\nlet print x = printfn \"The number is: %d\" x\r\n\r\nlet squareNegateThenPrint x = \r\n    print (negate (square x))\r\n```\r\n\r\n### 管道和组合操作符\r\n\r\n管道运算符 |> 用于将函数和参数链接在一起。双重反引号标识符便于提高可读性，尤其是在单元测试中：\r\n\r\n```fsharp\r\nlet ``square, negate, then print`` x = \r\n    x |> square |> negate |> print\r\n```\r\n\r\n此运算符在使用前通过提供类型信息来协助 F# 类型检查器是必不可少的：\r\n\r\n```fsharp\r\nlet sumOfLengths (xs : string []) =\r\n    xs\r\n    |> Array.map (fun s -> s.Length)\r\n    |> Array.sum\r\n```\r\n\r\n组合运算符 >> 用于组合函数：\r\n\r\n```fsharp\r\nlet squareNegateThenPrint' = \r\n    square >> negate >> print\r\n```\r\n\r\n### 递归函数\r\n\r\nrec 关键字与 let 关键字一起用于定义递归函数：\r\n\r\n```fsharp\r\nlet rec fact x = \r\n    if x < 1 then 1\r\n    else x * fact (x - 1)\r\n```\r\n\r\n相互递归函数（那些相互调用的函数）由 and 关键字表示：\r\n\r\n```fsharp\r\nlet rec even x = \r\n    if x = 0 then true\r\n    else odd (x - 1)\r\nend odd x = \r\n    if x = 1 then true\r\n    else even (x - 1)\r\n```\r\n\r\n## 模式匹配\r\n\r\n通常通过 match 关键字来促进模式匹配。\r\n\r\n```fsharp\r\nlet rec fib n = \r\n    match n with\r\n    | 0 -> 0\r\n    | 1 -> 1\r\n    | _ -> fib (n - 1) + fib (n - 2)\r\n```\r\n\r\n为了匹配复杂的输入，可以使用 when 在模式上创建过滤器或防护：\r\n\r\n```fsharp\r\nlet sign x = \r\n    match x with\r\n    | 0 -> 0\r\n    | x when x < 0 -> -1\r\n    | x -> 1\r\n```\r\n\r\n模式匹配可以直接在参数上完成：\r\n\r\n```fsharp\r\nlet fst' (x, _) = x\r\n```\r\n\r\n或通过 function 关键字隐式：\r\n\r\n```fsharp\r\n/// 类似于 `fib`;使用 `function` 进行模式匹配\r\nlet rec fib' = function\r\n    | 0 -> 0\r\n    | 1 -> 1\r\n    | n -> fib' (n - 1) + fib' (n - 2)\r\n```\r\n\r\n有关更完整的参考，请访问[模式匹配（MSDN）](http://msdn.microsoft.com/en-us/library/dd547125.aspx)。\r\n\r\n## 集合\r\n\r\n### 列表\r\n\r\n列表是相同类型的元素的不可变集合。\r\n\r\n```fsharp\r\n// 列表使用方括号和`;`分隔符\r\nlet list1 = [\"a\";\"b\"]\r\n// :: 用于将元素加在列表开头\r\nlet list2 = \"c\" :: list1\r\n// @ 用于连接列表\r\nlet list3 = list1 @ list2\r\n\r\n// 使用( :: )运算符在列表上递归\r\nlet rec sum list = \r\n    match list with\r\n    | [] -> 0\r\n    | x :: xs -> x + sum xs\r\n```\r\n\r\n### 数组\r\n\r\n数组是连续数据元素的固定大小，从零开始，可变的集合。\r\n\r\n```fsharp\r\n// 数组使用方括号和条形\r\nlet array1 = [|\"a\";\"c\"|]\r\n// 使用点进行索引访问\r\nlet first = array1.[0]\r\n```\r\n\r\n### 序列\r\n\r\n序列是相同类型的逻辑系列元素。仅根据需要计算各个序列元素，因此在不使用所有元素的情况下，序列可以提供比列表更好的性能。\r\n\r\n```fsharp\r\n// 序列可以使用 yield 并包含子序列\r\nlet seq1 = \r\n    seq {\r\n        // “yield”增加一个元素\r\n        yield 1\r\n        yield 2\r\n\r\n        // \"yield!\" 添加一个完整的子序列\r\n        yield! [5..10]\r\n    }\r\n\r\n```\r\n\r\n### 集合上的高阶函数\r\n\r\n同样的清单 [1; 3; 5; 7; 9] 或数组 [| 1; 3; 5; 7; 9 |] 可以以各种方式生成。\r\n\r\n- 使用范围运算符..\r\n```fsharp\r\nlet xs = [1..2..9]\r\n```\r\n- 使用列表或数组理解\r\n```fsharp\r\nlet yx = [| for i in 0..4 -> 2 * i + 1 |]\r\n```\r\n- 使用 init 函数\r\n```fsharp\r\nlet zs = List.init 5 (fun i -> 2 * i + 1)\r\n```\r\n\r\n列表和数组具有用于操作的全面的高阶函数集。\r\n\r\n- fold 从列表（或数组）的左侧开始，foldBack 的方向相反\r\n```fsharp\r\nlet xs' = Array.fold (fun str n -> sprintf \"%s,%i\" str n) \"\" [|0..9|]\r\n```\r\n- reduce 不需要初始累加器\r\n```fsharp\r\nlet last xs = List.reduce (fun acc x -> x) xs\r\n```\r\n- map 转换列表（或数组）的每个元素\r\n```fsharp\r\nlet ys' = Array.map (fun x -> x * x) [|0..9|]\r\n```\r\n- iter 列表并产生副作用\r\n```fsharp\r\nlet _ = List.iter (printfn \"%i\") [0..9]\r\n```\r\n\r\n所有这些操作也可用于序列。序列的附加好处是对实现 IEnumerable<'T> 的所有集合的懒惰和统一处理。\r\n\r\n```fsharp\r\nlet zs' = \r\n    seq {\r\n        for i in 0..9 do\r\n            printfn \"Adding %d\" i\r\n            yield i\r\n    }\r\n```\r\n\r\n## 元组和记录\r\n\r\n元组是一组未命名但有序的值，可能是不同类型的：\r\n\r\n```fsharp\r\n// 元组结构\r\nlet x = (1, \"Hello\")\r\n\r\n// 三重\r\nlet y = (\"one\", \"two\", \"three\")\r\n\r\n// 元组解构/模式\r\nlet (a', b') = x\r\n```\r\n\r\n可以使用 fst，snd 或模式匹配获得元组的第一个和第二个元素：\r\n\r\n```fsharp\r\nlet c' = fst (1, 2)\r\nlet d' = snd (1, 2)\r\n\r\nlet print' tuple = \r\n    match tuple with\r\n    | (a, b) -> printfn \"Pair %A %A\" a b\r\n```\r\n\r\n记录表示命名值的简单聚合，可选择包含成员：\r\n\r\n```fsharp\r\n// 声明记录类型\r\ntype Person = { Name: string; Age: int }\r\n\r\n// 通过记录表达式创建值\r\nlet paul = { Name = \"Paul\"; Age = 28}\r\n\r\n// '复制并更新'记录表达式\r\nlet paulsTwin = {paul with Name = \"Jim\"}\r\n\r\n```\r\n\r\n记录可以使用属性和方法进行扩充：\r\n\r\n```fsharp\r\ntype Person with\r\n    member x.Info = (x.Name, x.Age)\r\n```\r\n\r\n记录本质上是带有额外顶部的密封类：默认不变性，结构相等和模式匹配支持。\r\n\r\n```fsharp\r\nlet isPaul person = \r\n    match person with\r\n    | { Name = \"Paul\" } -> true\r\n    | _ -> false\r\n```\r\n\r\n## 识别联合\r\n\r\n识别联合（DU）为可以是多个命名案例之一的值提供支持，每个案例可能具有不同的值和类型。\r\n\r\n```fsharp\r\ntype Tree<'T> =\r\n    | Node of Tree<'T> * 'T * Tree<'T>\r\n    | Leaf\r\n\r\nlet rec depth = function \r\n    | Node(l, _, r) -> 1 + max (depth l) (depth r)\r\n    | Leaf -> 0\r\n```\r\n\r\nF# Core 有一些用于错误处理的内置区分联合，例如 [Option](http://msdn.microsoft.com/en-us/library/dd233245.aspx) 和 [Choice](http://msdn.microsoft.com/en-us/library/ee353439.aspx) 。\r\n\r\n```fsharp\r\nlet optionPatternMatch input = \r\n    match input with\r\n    | Some i -> printfn \"input is an int=%d\" i\r\n    | None -> printfn \"input is missing\"\r\n```\r\n\r\n单例区分联合通常用于创建具有模式匹配支持的类型安全抽象：\r\n\r\n```fsharp\r\ntype OrderId = Order of string\r\n\r\n// 创建DU值\r\nlet orderId = Order \"12\"\r\n\r\n// 使用模式匹配来解构单个案例 DU\r\nlet (Order id) = orderId\r\n```\r\n\r\n## 异常\r\n\r\nfailwith 函数抛出异常类型 Exception 。\r\n\r\n```fsharp\r\nlet divideFailwith x y = \r\n    if y = 0 then\r\n        failwith \"Divisor cannot be zero\"\r\n    else x / y\r\n```\r\n\r\n异常处理通过 try / with 表达式完成。\r\n\r\n```fsharp\r\nlet divide x y =\r\n    try\r\n        Some (x / y)\r\n    with :? System.DivideByZeroException ->\r\n        printfn \"Division by zero!\"\r\n        None\r\n```\r\n\r\ntry / finally 表达式使您可以执行清理代码，即使代码块引发异常也是如此。这是一个定义自定义异常的示例。\r\n\r\n```fsharp\r\nexception InnerError of string\r\nexception OuterError of string\r\n\r\nlet handleErrors x y =\r\n    try\r\n        try\r\n            if x = y then raise (InnerError(\"inner\"))\r\n            else raise (OuterError(\"outer\"))\r\n        with\r\n            printfn \"Error1 %s\" str\r\n    finally\r\n        printfn \"Always print this.\"\r\n```\r\n\r\n## 类和继承\r\n\r\n此示例是一个基本类，包含（1）本地 let 绑定，（2）属性，（3）方法和（4）静态成员。\r\n\r\n```fsharp\r\ntype Vector(x: float, y: float) =\r\n    let mag = sqrt(x * x + y * y) // (1)\r\n    member this.X = x // (2)\r\n    member this.Y = y\r\n    member this.Mag = mag\r\n    member this.Scale(s) = // (3)\r\n        Vector(x * s, y * s)\r\n    static member (+) (a: Vector, b: Vector) = // (4)\r\n        Vector(x.X + b.X, a.Y + b.Y)\r\n```\r\n\r\n从派生类调用基类。\r\n\r\n```fsharp\r\ntype Animal() =\r\n    member __.Reset() = ()\r\n\r\ntype Dog() = \r\n    inherit Animal()\r\n    member __.Run() =\r\n        base.Reset()\r\n```\r\n\r\n上传表示为 :> 运算符。\r\n\r\n```fsharp\r\nlet dog = Dog()\r\nlet animal = dog :> Animal\r\n```\r\n\r\n如果转换在运行时未成功，则动态向下转换（ :?> ）可能会抛出 InvalidCastException。\r\n\r\n```fsharp\r\nlet shouldBeDog = animal :?> Dog\r\n```\r\n\r\n## 接口和对象表达式\r\n\r\n声明 IVector 接口并在 Vector' 中实现它。\r\n\r\n```fsharp\r\ntype IVector\r\n    abstract Scale : float -> IVector\r\n\r\ntype Vector'(x, y) = \r\n    interface IVector with\r\n        member __.Scale(s) =\r\n            Vector'(x * s, y * s) :> IVector\r\n    member __.X = x\r\n    member __.Y = y\r\n```\r\n\r\n实现接口的另一种方法是使用对象表达式。\r\n\r\n```fsharp\r\ntype ICustomer =\r\n    abstract Name : string\r\n    abstract Age : int\r\n\r\nlet createCustomer name age = \r\n    { new ICustomer with\r\n        member __.Name = name\r\n        member __.Age = age }\r\n```\r\n\r\n## 活动模式\r\n\r\n完整的活动模式：\r\n\r\n```fsharp\r\nlet (|Even|Odd|) i = \r\n    if i % 2 = 0 then Even else Odd\r\n\r\nlet testNumber i = \r\n    match i with\r\n    | Even -> printfn \"%d is even\" i\r\n    | Odd -> printfn \"%d is odd\" i\r\n```\r\n\r\n参数化活动模式：\r\n\r\n```fsharp\r\nlet (|DivisibleBy|_|) by n =\r\n    if n % by = 0 then Some DivisibleBy else None\r\n\r\nlet fizzBuzz = function\r\n    | DivisibleBy 3 & DivisibleBy 5 -> \"FizzBuzz\"\r\n    | DivisibleBy 3 -> \"Fizz\"\r\n    | DivisibleBy 5 -> \"Buzz\"\r\n    | i -> string i\r\n```\r\n\r\n部分活动模式共享参数化模式的语法，但它们的主动识别器只接受一个参数。\r\n\r\n## 编译器指令\r\n\r\n将另一个 F# 源文件加载到 FSI 中。\r\n\r\n```fsharp\r\n#load \"../lib/StringParsing.fs\"\r\n```\r\n\r\n引用.NET程序集（建议使用/符号以实现Mono兼容性）。\r\n\r\n```fsharp\r\n#r \"../lib/FSharp.Markdown.dll\"\r\n```\r\n\r\n在程序集搜索路径中包含目录。\r\n\r\n```fsharp\r\n#I \"../lib\"\r\n#r \"FSharp.Markdown.dll\"\r\n```\r\n\r\n其他重要指令是 FSI（INTERACTIVE）中的条件执行和查询当前目录（ __SOURCE_DIRECTORY__ ）。\r\n\r\n```fsharp\r\n#if INTERACTIVE\r\nlet path = __SOURCE_DIRECTORY__ + \"../lib\"\r\n#else\r\nlet path = \"../../../lib\"\r\n#endif\r\n```\r\n","source":"source\\_posts\\fsharp-cheatsheet.md"},{"title":"使用 Erlang / OTP 构建您的第一个多用户聊天室应用程序","created":"2018/07/18","description":"使用 Erlang / OTP 构建您的第一个多用户聊天室应用程序","author":"lanqy","link":"2018/07/18/build-your-first-multi-user-chat-room-app-with-erlang-otp","htmlDir":"website\\2018\\07\\18\\build-your-first-multi-user-chat-room-app-with-erlang-otp","htmlFile":"website\\2018\\07\\18\\build-your-first-multi-user-chat-room-app-with-erlang-otp\\index.html","body":"# 使用 Erlang / OTP 构建您的第一个多用户聊天室应用程序\r\n\r\n译自：https://medium.com/@kansi/chatbus-build-your-first-multi-user-chat-room-app-with-erlang-otp-b55f72064901\r\n\r\n> 在本教程中，我将使用 Erlang / OTP和 ErlBus 构建另一个消息传递系统（稍后我们将讨论它），并在此过程中探索 Erlang 的强大功能！\r\n\r\n注意：以下假设假定您对 Erlang / OTP 和 Web 开发有基本的了解。\r\n\r\n本文的目的是构建一个多用户聊天室应用程序，但这个想法听起来太无聊了！所以让我们添加一些创造力并称之为 ChatBus。现在您可能想知道这个名字是如何帮助的。等一下 ！让我解释 ChatBus 的内容。我们将聊天室的概念抽象为公共汽车，聊天室中的所有用户都被称为搭便车，因为他们不需要为乘坐这辆公共汽车支付任何费用！\r\n\r\n在我们潜入并开始编码像疯狗之前！我们应该决定 ChatBus 要具备哪些功能。这通常称为软件开发中的需求规范。在实施之前或者很快项目将开始分崩离析时，始终要根据经验确切知道要实施的内容！\r\n\r\n对于我们的多用户聊天系统，我们将具有以下功能：\r\n\r\n- 允许用户创建新的总线（也称为聊天室）！\r\n- 允许用户从一个总线切换到另一个总线！ （这里有一些不可能的任务）\r\n- 动态更新乘坐所选巴士的可用巴士和搭便车的列表。\r\n\r\n这完成了基本规范。现在我们继续决定实现这个项目所需的工具和库。\r\n\r\n## 工具和库\r\n\r\n- [Polymer](https://www.polymer-project.org/1.0/)：对于这个应用程序，我使用 [Polymer](https://www.polymer-project.org/1.0/) 来开发客户端，但是你可以选择在Bootstrap中实现它或者你喜欢什么，因为讨论客户端不在讨论的范围内。\r\n- [ErlBus](https://github.com/cabol/erlbus)：在 Erlang 中传递消息非常简单，但是这个项目更进一步，使它更容易。它允许用户创建频道并为其订阅侦听器进程。这就是我们实现 ChatBus 所需要的一切！下面是一个快速示例，以显示它的力量：\r\n\r\n```erlang\r\n\r\n% 创建匿名函数以执行监听频道的操作\r\n% 请注意，该函数有两个参数，第一个是self\r\n% 第一个是自解释的，第二个是上下文\r\n% (ctx) 在生成这个函数时可以设置。\r\n\r\nF = fun({Channel, Msg}, Ctx) ->\r\n        io:format(\"[Pid: ~p] [Channel: ~p] [Msg: ~p] [Ctx: ~p]~n\", [self(), Channel, Msg, Ctx])\r\n    end.\r\n% 将此函数派生为进程。\r\nMH2 = ebus_handler:new(F, {my_ctx, <<\"MH2\">>}).\r\n\r\n% 将生成的进程订阅到通道（ch1）\r\n% 注意：如果通道不存在，则创建该通道。\r\nebus:sub(ch1, [MH2]).\r\n\r\n% 让我们发一条消息给 'ch1'\r\nebus:pub(ch1, \"Hello!\").\r\n[Pid: <0.52.0>] [Channel: ch1] [Msg: \"Hello!\"] [Ctx: {my_ctx, <<MH2>>}]\r\n\r\n\r\n```\r\n\r\n我希望这足以说明如何使用 ChatBus，但如果不能，你可以在他们的 [GitHub 项目](https://github.com/cabol/erlbus) 页面看一些例子。\r\n- [Cowboy](https://github.com/ninenines/cowboy)：我们将使用 Cowboy 来实现我们的网络服务器。\r\n- [Rebar3](https://www.rebar3.org/docs/getting-started)：我们将使用rebar3作为此项目的构建和发布工具。\r\n\r\n\r\n...\r\n\r\n## 实现\r\n\r\nChatBus 的项目源码位于[此处](https://github.com/beamX/chatBus/tree/feat-chatbus-client)。\r\n\r\n首先，我们将使用rebar3生成模板项目：\r\n\r\n```text\r\n$ rebar3 new release chatbus\r\n```\r\n\r\n这将生成一个模板项目。执行以确保项目正常工作：\r\n\r\n```text\r\n$ rebar3 compile\r\n$ rebar3 release\r\n$ ./_build/default/rel/chatbus/bin/chatbus console\r\n```\r\n\r\n最后一个命令应该打开 erlang shell。该项目应如下所示\r\n\r\n```text\r\n├── apps\r\n│   └── chatbus\r\n│      └── src\r\n│          ├── chatbus_app.erl\r\n│          ├── chatbus.app.src\r\n│          └── chatbus_sup.erl\r\n├── _build\r\n│   └── default\r\n│       ├── lib\r\n│       └── rel\r\n├── config\r\n│   ├── sys.config\r\n│   └── vm.args\r\n├── LICENSE\r\n├── Makefile\r\n├── README.md\r\n├── rebar.config\r\n└── rebar.loc\r\n```\r\n\r\n首先，我们添加项目所需的依赖项，将 rebar.config 更改为像[这样](https://github.com/beamX/chatBus/blob/feat-chatbus-client/rebar.config)。我们在那里有以下依赖：\r\n\r\n- cowboy：用于创建允许客户端连接的 Web 服务器。\r\n- lager：记录错误和东西。\r\n- mochiweb：解析 json。\r\n- erlbus：用于创建频道和传递消息。\r\n- sync：用于开发目的。您可以选择排除它，但您必须相应地更改 chatbus.app.src。\r\n\r\n现在我们使用 cowboy 创建我们的Web服务器。在你的chatbus_app.erl文件中，启动函数如下所示：\r\n\r\n```erlang\r\nstart(_StartType, _StartArgs) ->\r\n\r\n    ok = application:ensure_started(ebus),\r\n \r\n   Dispatch = cowboy_router:compile(\r\n                 [{'_', [\r\n                         {\"/\", cowboy_static, {priv_file, chatbus, \"index.html\"}},\r\n                         {\"/ws\", ws_handler, []},\r\n                         {\"/[...]\", cowboy_static, {priv_dir, chatbus, \"./\"}}]}]),\r\n    {ok, _} = cowboy:start_http(http, 100, [{port, 9090}], [{env, [{dispatch, Dispatch}]}]),\r\n    'chatbus_sup':start_link().\r\n```\r\n\r\n这里我们添加了一些路由。我们的应用程序将是一个单页面的 Web 应用程序，因此我们定义静态文件 “index.html” 的位置，任何点击 “/” 的人都将获得此 “index.html” 和其他静态文件。接下来我们指定一个路由 “/ws”，我们将用它来建立一个 websocket 连接，对该端点的任何请求都将由 ws_handler.erl 模块处理。加载静态文件后，将使用 javascript 调用此 websocket 端点。最后，我们使用 “[...]” 定义所有静态文件的位置。\r\n\r\n现在我们将创建一个 bus_listener.erl 模块，它将订阅一个频道，收听和广播消息，\r\n\r\n```erlang\r\n-module(bus_listener).\r\n-behaviour(ebus_handler).\r\n\r\n%% API\r\n-export([handle_msg/2]).\r\n\r\nhandle_msg({_Channel, {Sender, Type, Msg}}, User) ->\r\n    if\r\n        Sender =:= User -> ok;\r\n        true -> User ! {Type, Msg}\r\n    end\r\n```\r\n\r\n如果你通过[这里](https://github.com/cabol/erlbus#my_handlererl)的文档，上面的模块应该很容易理解，但不过我将解释这段代码，但稍后。\r\n\r\n现在我们将创建一个 websocket 处理程序，它将在调用端点 “/ws” 时创建 websocket 连接。回想一下，我们在路由中将处理程序名称指定为 “ws_handler”，因此我们使用以下内容创建名为 “[ws_handler.erl](https://github.com/beamX/chatBus/blob/feat-chatbus-client/apps/chatbus/src/ws_handler.erl)” 的模块，\r\n\r\n```erlang\r\n\r\n-module(ws_handler).\r\n-export([init/2]).\r\n-export([websocket_handle/3]).\r\n-export([websocket_info/3]).\r\n-export([websocket_terminate/3]).\r\n-export([send_active_channels/1]).\r\ninit(Req, _Opts) ->\r\n    io:format(\"connected !~n\"),\r\n \r\n    %% subscribe to default bus\r\n    BusFd = ebus_handler:new(bus_listener, self()),\r\n    ok = ebus:sub(default, [BusFd]),\r\n    %% send subscribes bus name\r\n    auto_send(<<\"bus_subscribed\">>, default),\r\n \r\n    {cowboy_websocket, Req, #{bus => default\r\n                             ,bus_fd => BusFd\r\n                             ,hitchhicker => false}}.\r\nwebsocket_handle({text, Msg}, Req, #{bus := BusName\r\n                                    ,bus_fd := BusFd\r\n                                    ,hitchhicker := Hitchhicker} = \r\n                                     State) ->\r\n    {ok, {Type, Msg1}} = parse_message(Msg),\r\n    case Type of\r\n        <<\"chat\">> ->\r\n            ok = ebus:pub(BusName, {self(), Type, Msg1}),\r\n            {ok, Req, State};\r\n         <<\"bus_list\">> ->\r\n            {ok, List}  = bus_manager:bus_list(),\r\n            {ok, Reply} = encode_message(<<\"bus_list\">>, List),\r\n            {reply, {text, Reply}, Req, State};\r\n         <<\"hitchhicker_list\">> ->\r\n            {ok, List}  = bus_manager:get_hitchhickers(BusName),\r\n            {ok, Reply} = encode_message(<<\"hitchhicker_list\">>, List),\r\n            {reply, {text, Reply}, Req, State};\r\n         <<\"bus_subscribed\">> ->\r\n            BusName2 = erlang:binary_to_atom(Msg1, utf8),\r\n            ok = ebus:unsub(BusName, BusFd),\r\n            ok = ebus:sub(BusName2, [BusFd]),\r\n            {ok, Reply} = encode_message(<<\"bus_subscribed\">>, BusName2),\r\n            {reply, {text, Reply}, Req, State#{bus => BusName2}};\r\n         <<\"add_bus\">> ->\r\n            BusNewName = erlang:binary_to_atom(Msg1, utf8),\r\n            ok = ebus:unsub(BusName, BusFd),\r\n            ok = ebus:sub(BusNewName, [BusFd]),\r\n            %% signal bus_manager to send all client list of \r\n            %% active buses\r\n            bus_manager:check_bus(BusName),\r\n            %% send message to client updating his bus\r\n            {ok, Reply} = encode_message(<<\"bus_subscribed\">>, \r\n                                         BusNewName),\r\n            {reply, {text, Reply}, Req, State#{bus => BusNewName}};\r\n         <<\"username\">> ->\r\n            %% check if username is assignable\r\n            case bus_manager:store_username(BusName, Msg1) of\r\n                {ok, error} ->\r\n                    {ok, Reply} = encode_message( <<\"username_error\">>, error),\r\n                    {reply, {text, Reply}, Req, State};\r\n                 _ ->\r\n                    {ok, List} = bus_manager:get_hitchhickers(BusName),\r\n                     ok = ebus:pub(BusName, {none,\r\n                                  <<\"hitchhicker_list\">>, List}),\r\n                     {ok, Reply} = encode_message(<<\"username\">>, \r\n                                                  Msg1),\r\n                     {reply, {text, Reply}, Req, \r\n                      State#{hitchhicker => Msg1}}\r\n            end;\r\n         <<\"terminate\">> ->\r\n            bus_manager:remove_hitchhicker(Hitchhicker),\r\n            ebus:unsub(BusName, BusFd),\r\n            ebus_handler:delete(BusFd),\r\n            {ok, List} = bus_manager:get_hitchhickers(BusName),\r\n            ok = ebus:pub(BusName, {none, <<\"hitchhicker_list\">>, \r\n                          List}),\r\n            {shutdown, Req, State};\r\n         _ ->\r\n            io:format(\"unknown message type ~p~n\", [Type]),\r\n            {ok, Req, State}\r\n    end;\r\nwebsocket_handle(Data, Req, State) ->\r\n   io:format(\"received ~p~n\", [Data]),\r\n   {ok, Req, State}.\r\n%% handle erlang messages\r\nwebsocket_info({Type, Msg}, Req, State) ->\r\n   {ok, Reply} = encode_message(Type, Msg),\r\n   {reply, {text, Reply}, Req, State};\r\nwebsocket_info(Info, Req, State) ->\r\n   io:format(\"[ws_info]: unknown message ~p~n\", [Info]),\r\n   {ok, Req, State}.\r\nwebsocket_terminate(_Reason, _Req, _State) ->\r\n   io:format(\"[ws_info]: terminating websocket ~n\"),\r\n   ok.\r\n%% ===============================================================\r\n%% other exports\r\n%% ===============================================================\r\nsend_active_channels(Channels) ->\r\n   lists:map(fun(Bus) ->\r\n               ok = ebus:pub(Bus, {none, <<\"bus_list\">>, Channels})\r\n             end, Channels).\r\n%% ===============================================================\r\n%% internal functions\r\n%% ===============================================================\r\nauto_send(Mtype, Msg) ->\r\n   %% send subscribes bus name\r\n   timer:send_after(10, self(), {Mtype, Msg}).\r\nparse_message(Msg) ->\r\n   {struct, Msg1} = mochijson2:decode(Msg),\r\n   {<<\"type\">>, Type} = lists:keyfind(<<\"type\">>, 1, Msg1),\r\n   {<<\"msg\">>, Content} = lists:keyfind(<<\"msg\">>, 1, Msg1),\r\n   {ok, {Type, Content}}.\r\nencode_message(Type, Msg) ->\r\n   Reply = {[{type, Type}, {msg, Msg}]},\r\n   {ok, iolist_to_binary(mochijson2:encode(Reply))}.\r\n\r\n```\r\n\r\n当客户端调用 “/ws” 端点时，将通过调用 init/2 函数创建 websocket 。在这个功能中发生了两件重要的事情\r\n\r\n```erlang\r\n\r\nBusFd = ebus_handler:new(bus_listener, self()),\r\nok = ebus:sub(default, [BusFd]),\r\n\r\n```\r\n\r\n在第一行中，我们使用 bus_listener 模块生成一个新的 ebus 处理程序进程。然后，此处理程序进程订阅名为 “default” 的通道。\r\n\r\n```erlang\r\nhandle_msg({_Channel, {Sender, Type, Msg}}, User) ->\r\n    if\r\n        Sender =:= User -> ok;\r\n        true -> User ! {Type, Msg}\r\n    end\r\n```\r\n\r\nhandle_msg/2 的第一个参数是包含通道名称和消息的元组，第二个参数是我们在创建此过程时传递给 ebus_handler:new/2 的参数，即 self()。接下来，websocket_handle/3 函数处理来自客户端的数据。人们可以很容易地注意到客户端发送包含消息类型和消息的 json 对象。根据消息类型，我们执行不同的操作，例如。消息类型 “chat” 用于在通道上发送消息，该消息使用 ebus:pub/2 完成，还有其他消息类型执行不同的功能，如更改用户名，添加新聊天室，发送连接用户列表等。\r\n\r\n...\r\n\r\n通过上面的讨论，我试图介绍处理消息传递部分的 ChatBus 的基本代码库。我鼓励读者探索代码库并尝试使用它。\r\n\r\n总之，使用 Erlang 构建聊天系统非常容易 :)\r\n","source":"source\\_posts\\build-your-first-multi-user-chat-room-app-with-erlang-otp.md"},{"title":"OCaml简介第6部分","description":"OCaml简介第6部分","created":"2018/07/17","author":"lanqy","link":"2018/07/17/getting_started6","htmlDir":"website\\2018\\07\\17\\getting_started6","htmlFile":"website\\2018\\07\\17\\getting_started6\\index.html","body":"\r\n## OCaml简介第6部分\r\n\r\n译自：https://qiita.com/zenwerk/items/97d370d457008d8f01de\r\n\r\n### 标记的参数\r\n\r\n#### 〜标签名称：\r\n* 你可以命名这个参数。\r\n* 如果你给一个标签名称，你可以改变你喜欢的参数的顺序。\r\n\r\n```ocaml\r\n(* 使用带标签的参数定义函数 *)\r\n\r\n# let rec range ~first: a  ~last: b = \r\n  if a > b then []\r\n  else a :: range ~first: (a + 1) ~last: b;;\r\n  \r\n(* 函数类型上的标签类型 *)\r\nval range : first:int -> last:int -> int list = <fun>\r\n\r\n(* 指定标签名称函数应用程序 *)\r\n\r\n# range ~first: 1 ~last: 10;;\r\n\r\n- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] \r\n\r\n# range ~last: 10 ~first: 1;;\r\n\r\n- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] \r\n\r\n(* 除非指定了标签名称，否则按标签名称定义应用 *) \r\n\r\n# range 1 10;;\r\n- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\r\n\r\n# range 10 1;;\r\n- : int list = []\r\n```\r\n\r\n* 〜hoge：○○ ○○ 是可选的\r\n\r\n```ocaml\r\n# let rec range ~first ~last = \r\n  if first > last then []\r\n  else first :: range (first + 1) last;;\r\nval range : first:int -> last:int -> int list = <fun>\r\n```\r\n\r\n#### 可选参数\r\n\r\n?标签名称：（pattern =表达式）\r\n\r\n与Python的家伙相同的功能。\r\n\r\n```ocaml\r\n(* 默认值1给出步骤值 *)\r\n\r\n# let rec range ?(step = 1) a b = \r\n  if a > b then []\r\n  else a :: range ~step (a + step) b;;\r\nval range : ?step:int -> int -> int -> int list = <fun>\r\n\r\n(* 函数应用 *)\r\n# range 1 10;;\r\n\r\n- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\r\n\r\n(* 因为它在调用时指定了标签 *)\r\n\r\n# range 1 10 ~step:2;;\r\n- : int list = [1; 3; 5; 7; 9]\r\n# range 1 ~step:3 10;;\r\n- : int list = [1; 4; 7; 10]\r\n\r\n# range 2 1 10;;\r\nError: The function applied to this argument has type ?step:int -> int list\r\nThis argument cannot be applied without label\r\n```\r\n#### 关于可选参数的说明\r\n\r\n##### 在选项参数后面准备一个无标签的参数\r\n\r\n如果选项参数在函数的结尾，则它变成了不能省略的选项参数，所以没有任何意义。\r\n\r\n```ocaml\r\n(**\r\n * 我想定义一个函数，返回常量1 ....。\r\n * 如果选项参数在最后，我会收到警告\r\n *)\r\n# let f ?(x=1) = x;;\r\nWarning 16: this optional argument cannot be erased.\r\nval f : ?x:int -> int = <fun>\r\n(* 1函数返回我以为它返回一个函数，接收*选项参数返回正在currying\r\n *)\r\n# f;;\r\n- : ?x:int -> int = <fun>\r\n\r\n(* 最后这么糟糕，不要添加无标签的参数 *)\r\n# let f ?(x=1) () = x;;\r\nval f : ?x:int -> unit -> int = <fun>\r\n# f;;\r\n- : ?x:int -> unit -> int = <fun>\r\n# f();;\r\n- : int = 1\r\n```\r\n#### 选项参数实体\r\n\r\n可选参数是用 'a option 实现的\r\n\r\n如果你没有指定默认值，并写入它，尝试执行，你会得到一个错误，如下所示\r\n\r\n```ocaml\r\n# let rec range ?step a b =\r\n    if a > b then []\r\n    else a :: range ~step (a+step) b;;\r\n(* 'a option type error is occurring  *)\r\nError: This expression has type 'a option\r\n       but an expression was expected of type 'a\r\n       The type variable 'a occurs inside 'a option\r\n```\r\n\r\n因此，在这种情况下，None 加 'a Some 来模式匹配\r\n\r\n```ocaml\r\n\r\n(* 与选项类型匹配的模式 *)\r\n\r\n# let rec range ?step a b =\r\n    let s = match step with None -> 1 | Some s -> s in\r\n    if a > b then [] else a :: range (a + s) b;;\r\nval range : ?step:int -> int -> int -> int list = <fun>\r\n\r\n# range 1 10;;\r\n- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\r\n```\r\n\r\n#### 多态变种\r\n\r\n##### `Constructor\r\n\r\n一种机制，可以为多种变体类型使用通用的构造函数。\r\n\r\n消除 “1构造函数<=> 1变体” 的限制。\r\n\r\n```ocaml\r\n# `Hoge;;\r\n- : [> `Hoge ] = `Hoge\r\n# `Hoge 2;;\r\n- : [> `Hoge of int ] = `Hoge 2\r\n# `Hoge `Fuga;;\r\n- : [> `Hoge of [> `Fuga ] ] = `Hoge `Fuga\r\n```\r\n\r\n#### 函数返回多态变种\r\n\r\n```ocaml\r\n# let f b = if b then `Hoge else `Fuga;;\r\nval f : bool -> [> `Fuga | `Hoge ] = <fun>\r\n```\r\n```ocaml\r\n# let hoge = function\r\n  | `Hoge -> \"hoge\"\r\n  | `Fuga -> \"fuga\"\r\n  | `Piyo -> \"piyo\";;\r\nval hoge : [< `Fuga | `Hoge | `Piyo ] -> string = <fun>\r\n```\r\n\r\n#### 多态变种的类型方案\r\n\r\n[> ...] , [<...] 是类型方案 (同 `a)\r\n\r\n[> ..] 和 [< ..] 它被视为有限制的类型变量。\r\n\r\n在 [> ...] 的情况下\r\n[> 可以解释为 “包含多态变种” 或更高。\r\n\r\n```ocaml\r\n(* \r\n * 可以接受任何东西的多相变体列表\r\n *)\r\n# let  a : [>] list = [`Fuga; `Piyo];;\r\nval a : [> `Fuga | `Piyo ] list = [`Fuga; `Piyo]\r\n\r\n# a @ [`Asdf];;\r\n- : [> `Asdf | `Fuga | `Piyo ] list = [`Fuga; `Piyo; `Asdf]\r\n```\r\n\r\n在 [<...] 中\r\n\r\n[< 可以被解释为“在所包含的多相变体类型中”。\r\n\r\n```ocaml\r\n(* `Hoge,`within Fuga *)\r\n# let f = function\r\n  | `Hoge -> \"hoge\"\r\n  | `Fuga -> \"fuga\";;\r\nval f : [< `Fuga | `Hoge ] -> string = <fun>\r\n\r\n(* `Hoge, type within Fuga *)\r\n# type type_A = [`Hoge | `Fuga];;\r\ntype type_A = [ `Fuga | `Hoge ]\r\n# let a:type_A = `Hoge;;\r\nval a : type_A = `Hoge\r\n# f a;;\r\n- : string = \"hoge\"\r\n\r\n(* `Hoge,`Fuga or more types *)\r\n# type type_B = [`Hoge | `Fuga | `Piyo];;\r\ntype type_B = [ `Fuga | `Hoge | `Piyo ]\r\n\r\n(* `I'm Hoge type_B is `Hoge, `Fuga or more types *)\r\n# let b:type_B = `Hoge;;\r\nval b : type_B = `Hoge\r\n# f b;; (* type error　*)\r\nError: This expression has type type_B but an expression was expected of type\r\n         [< `Fuga | `Hoge ]\r\n       The second variant type does not allow tag(s) `Piyo\r\n```\r\n\r\n#### 多态变体类型的定义\r\n\r\n[> ..] [<..] 无法使用的模式\r\n\r\ntype hoge = [`Hoge |`Fuga |...]\r\n\r\n声明一个类型变量 [> ..] 和 [<..] 定义一个模式\r\n\r\ntype 'a hoge = [> `Hoge ...] as' a\r\n\r\n```ocaml\r\n# type hoge = [`Hoge | `Fuga];;\r\ntype hoge = [ `Fuga | `Hoge ]\r\n\r\n# type 'a hoge = [> `Hoge] as 'a;;\r\ntype 'a hoge = 'a constraint 'a = [> `Hoge ]\r\n\r\n# type 'a hoge = [< `Hoge] as 'a;;\r\ntype 'a hoge = 'a constraint 'a = [< `Hoge ]\r\n\r\n(* 类型定义可以重用 *)\r\n# type hoge' = [hoge | `Piyo];;\r\ntype hoge' = [ `Fuga | `Hoge | `Piyo ]\r\n```\r\n\r\n#### 递归定义多相变量\r\n\r\n##### type 'a mylist = Nil | Cons of 'a * 'a mylist 我们将其定义为多相变量\r\n* 首先按顺序定义它，并检查Valiant类型发生了什么\r\n\r\n```ocaml\r\n（*通过定义来查看价格类型的变化*）\r\n# let l1 = `Nil;;\r\nval l1 : [> `Nil ] = `Nil\r\n# let l2 = `Cons(1, `Nil);;\r\nval l2 : [> `Cons of int * [> `Nil ] ] = `Cons (1, `Nil)\r\n\r\n（*你不能获得泛型类型定义*）\r\n# let l3 = `Cons(2, `Cons(1, `Nil));;\r\nval l3 : [> `Cons of int * [> `Cons of int * [> `Nil ] ] ] =\r\n  `Cons (2, `Cons (1, `Nil))\r\n```\r\n* 如果你写一个执行任意列表处理的函数，你应该能够获得列表的通用术语类型定义...\r\n\r\n```ocaml\r\n(* 递归Variant类型的类型定义是...？ *)\r\n# let rec length = function\r\n  | `Nil -> 0\r\n  | `Cons (a, l) -> 1 + length l;;\r\n(*\r\n* [...]因为'a已被赋予变体类型定义的别名\r\n*这个别名'a出现在[...]中，原来是一个递归的定义\r\n*'由b给出的类型变量是一个也可以看出哪个是固定的类型\r\n*)\r\n\r\nval length : ([< `Cons of 'b * 'a | `Nil ] as 'a) -> int = <fun>\r\n```\r\n\r\n```ocaml\r\n(* 函数在列表中选择*的最大值 *)\r\n# let rec max_list = function\r\n  | `Cons(x, `Nil) -> x\r\n  | `Cons(x, `Cons(y, l)) ->\r\n    if x < y then max_list (`Cons(y, l)) else max_list (`Cons(x, l));;\r\n\r\n(*\r\n* [.. [..]] 是因为它的形式，可以看出长度大于或等于1\r\n*)\r\nval max_list : [ `Cons of 'a * ([< `Cons of 'a * 'b | `Nil ] as 'b) ] -> 'a = <fun>\r\n```\r\n\r\n#### 注意多相变异型\r\n\r\n##### 注意 \"&\"\r\n\r\n如果多态变体＆出来，它表明，它输入失败\r\n\r\n例如，int＆float指示表示int和float，不能实现\r\n\r\n那么，在这种情况下，您应该查看函数定义等\r\n\r\n```ocaml\r\n# let f = function `A x -> x+1 | `B -> 2;;\r\nval f : [< `A of int | `B ] -> int = <fun>\r\n# let g = function `A x -> int_of_float x+1 | `B -> 2;;\r\nval g : [< `A of float | `B ] -> int = <fun>\r\n\r\n(*\r\n*返回不正确的类型[int＆float]\r\n* hoge＆fuga是一个不可行的类型，所以下面的类型定义是真实的[<`B] - > Int\r\n*)\r\n\r\n# let f_or_g b = if b then f else g;;\r\nval f_or_g : bool -> [< `A of int & float | `B ] -> int = <fun>\r\n```\r\n\r\n#### 使用点\r\n\r\n练习多相变量的正确使用所必需的。\r\n\r\n在很多情况下，应该使用正常的变体来完成。\r\n\r\n#### 奖励：你有多态记录吗？\r\n\r\n如果有多相变量，是否还有多态记录（如``hoge：int'）？ 我想，但没有这样的事情。\r\n\r\n相反，OCaml对象可以提供等效的功能。\r\n\r\n然而，对象没有模式匹配，所以说它用得不多。\r\n","source":"source\\_posts\\getting_started6.md"},{"title":"OCaml简介第5部分","description":"OCaml简介第5部分","created":"2018/07/16","author":"lanqy","link":"2018/07/16/getting_started5","htmlDir":"website\\2018\\07\\16\\getting_started5","htmlFile":"website\\2018\\07\\16\\getting_started5\\index.html","body":"\r\n## OCaml简介第5部分\r\n\r\n译自：https://qiita.com/zenwerk/items/3844df72c5f4afb1782f\r\n\r\n### 面向对象的功能\r\n\r\n#### 类声明\r\n\r\nobject ... end \r\n\r\nOCaml实例变量的所有成员都是私有的\r\n\r\n```ocaml\r\n# class point ini_x ini_y =\r\n    object (self)  (* 自身の名前をつける, 自由なので this とかでも良い *)\r\n      val mutable x = 0 (* 实例变量不能从外部访问 *)\r\n      val mutable y = 0\r\n\r\n      (*\r\n       * 实例方法\r\n       * method 方法名称 参数... = 表达式\r\n       *)\r\n      method set new_x new_y = begin x <- new_x; y <- new_y end\r\n      method private print_x = print_int x (* 私有方法 *)\r\n\r\n      (* 构造函数 *)\r\n      initializer begin\r\n        x <- ini_x; y <- ini_y\r\n      end\r\n    end;;\r\n(* 签名 *)    \r\nclass point :\r\n  int ->\r\n  int ->\r\n  object\r\n    val mutable x : int\r\n    val mutable y : int\r\n    method private print_x : unit\r\n    method set : int -> int -> unit\r\n  end\r\n```\r\n#### 实例生成\r\n\r\nnew 类名称\r\n\r\n```ocaml\r\n# let p = new point;;\r\nval p : point = <obj>\r\n```\r\n\r\n#### 调用实例方法\r\n\r\n实例#方法名称\r\n\r\n```ocaml\r\n# p#set 1 2;;\r\n- : unit = ()\r\n```\r\n\r\n#### 継承\r\n\r\ninherit 类名\r\n\r\n以下类可以由 self 本身通过 super 访问父类。\r\n\r\n```ocaml\r\n(* 打印坐标 *)\r\n# class point_with_print x y =\r\n    object (self)\r\n      inherit point x y as super (* 访问父类的名称 *)\r\n      method print = Printf.printf \"(%d, %d)\\n\" x y\r\n    end;;\r\nclass point_with_print :\r\n  int ->\r\n  int ->\r\n  object\r\n    val mutable x : int\r\n    val mutable y : int\r\n    method print : unit\r\n    method private print_x : unit\r\n    method set : int -> int -> unit\r\n  end\r\n\r\n(* 生成继承类的实例 *)\r\n# let p = new point_with_print 1 1;;\r\nval p : point_with_print = <obj>\r\n# p#print;;\r\n(1, 1)\r\n- : unit = ()\r\n```\r\n\r\n#### 类类型\r\n\r\n##### <方法名称：类型 ...>\r\n* 对象的类型是方法类型的顺序\r\n* 如果方法名称和类型的组合匹配，则认为是相同的对象类型\r\n* 要检查一个类的类型，直接使用 let 定义对象而不使用 class。\r\n\r\n```ocaml\r\n(* 直接定义对象 *)\r\nlet obj = \r\n  object (self)\r\n    val mutable x = 0\r\n    val mutable y = 0\r\n    method set new_x new_y = begin x <- new_x; y <- new_y end\r\n  end;;\r\n\r\n(* 显示类型 *)\r\nval obj : < set : int -> int -> unit > = <obj>\r\n(* 尝试调用实例方法 *)\r\n# obj#set 1 2;;\r\n- : unit = ()\r\n```\r\n\r\n#### 上面的 obj 类型是 < set : int -> int -> unit >\r\n\r\n换句话说，这意味着有一个方法设置int - > int - > unit。\r\n\r\n具有满足这个定义的方法的类被认为是相同的对象类型。\r\n\r\n```ocaml\r\n(* 定义上面与obj无关的类 *)\r\n# class unrelated_class =\r\n    object\r\n      (* 定义一个显示x，y的方法集 *)\r\n      method set x y = Printf.printf \"(%d, %d)\\n\" x y\r\n    end;;\r\nclass unrelated_class : object method set : int -> int -> unit end\r\n\r\n(* 由于对象类型匹配，它们被放在同一个列表中 *)\r\n# let obj2 = new unrelated_class;;\r\nval obj2 : unrelated_class = <obj>\r\n# [obj; obj2];;\r\n- : unrelated_class list = [<obj>; <obj>]\r\n\r\n(* 由于对象类型匹配，可以将其作为相同的返回值类型进行处理 *)\r\n# let hoge x = if x then obj else new unrelated_class;;\r\nval hoge : bool -> unrelated_class = <fun>\r\n# (hoge true)#set 1 2;;\r\n- : unit = ()\r\n# (hoge false)#set 1 2;;\r\n(1, 2)\r\n- : unit = ()\r\n```\r\n\r\n我个人觉得Java和Go的界面正在扮演OCaml的对象类型的角色。\r\n\r\n#### 部分类型\r\n\r\n##### 部分类型=>如果定义了部分对象类型的方法，则将其视为部分类型\r\n* 示例：类型2是类型1的部分类型\r\n* 类型1 => <方法1：int - > int，方法2：unit>\r\n* 类型2 => <method1：int - > int>\r\n\r\n#### CORATION（类型转换）\r\n\r\n（表达式：类型1：>类型2）\r\n\r\n将部分类型1转换为类型2。 它接近于Java中的上传。\r\n\r\n```ocaml\r\n(* print_class1 是 print_class2 的部分类型 *)\r\n# class print_class1 = object\r\n    method print_1 = print_int 1\r\n  end;;\r\nclass print_class1 : object method print_1 : unit end\r\n# class print_class2 = object\r\n    method print_1 = print_int 1\r\n    method print_2 = print_int 2\r\n  end;;\r\nclass print_class2 : object method print_1 : unit method print_2 : unit end\r\n\r\n(* 由于对象类型不同，print_class 1和print_class 2不在同一个列表中 *)\r\n# let obj_list = [new print_class1; new print_class2];;\r\nError: This expression has type print_class2\r\n       but an expression was expected of type print_class1\r\n       The second object type has no method print_2\r\n\r\n(* 通过指导（类型转换）把它们放在同一个列表中 *)\r\n# let obj_list = [new print_class1; (new print_class2 :> print_class1)];;\r\nval obj_list : print_class1 list = [<obj>; <obj>]\r\n\r\n(* コアーションによって削ぎ落とされた情報は呼び出せない *)\r\n# let [obj1; obj2] = obj_list;;\r\nval obj1 : print_class1 = <obj>\r\nval obj2 : print_class1 = <obj>\r\n\r\n# obj1#print_1;; (* 可以调用 *)\r\n1- : unit = ()\r\n# obj2#print_2;; (* 不能被调用 *)\r\nError: This expression has type print_class1\r\n       It has no method print_2\r\n```\r\n\r\n#### 多层对象类型\r\n\r\n表示满足部分类型的任意类型\r\n* <方法名称1：类型1; ...，方法名称n：类型n; ..>\r\n* 最后一个“..”是重要的\r\n* 换句话说，它表示“各种其他”\r\n ```ocaml\r\n \r\n (* 定义接受多层对象类型的函数 *)\r\n# let print1 print_obj = print_obj#print_1;;\r\nval print1 : < print_1 : 'a; .. > -> 'a = <fun>\r\n\r\n(* 您可以接收满足部分类型的对象类型 *)\r\n# print1 obj1;;\r\n1- : unit = ()\r\n# print1 obj2;;\r\n1- : unit = ()\r\n```\r\n\r\n以上 < print_1 : 'a; .. > -> 'a = <fun> 中的 -> 'a 部分 'a 是一个类型变量 < print_1 : 'a; .. > 的别名\r\n\r\n#### 关于多层次对象类型的参数类型的变化\r\n\r\n如果你给一个多层次的类型的参数\r\n\r\n```ocaml\r\n(* 定义多层函数 *)\r\n# let k1 a b = a and k2 a b = b;;\r\nval k1 : 'a -> 'b -> 'a = <fun>\r\nval k2 : 'a -> 'b -> 'b = <fun>\r\n\r\n(* 请求相同类型的函数的返回值会更改该类型。 *)\r\n# let f b = if b then k1 else k2;;\r\n（*'a - >'b - >'a /'b 的类型是 'a - >'a - >'a *）\r\nval f : bool -> 'a -> 'a -> 'a = <fun>\r\n```\r\n\r\n当给出一个不是多层的类型的参数时\r\n\r\n```ocaml\r\n(* 不同类型的函数 *)\r\n# let k1' (a:int) (b:string) = a and k2' (a:int) (b:string) = b;;\r\nval k1' : int -> string -> int = <fun>\r\nval k2' : int -> string -> string = <fun>\r\n\r\n（*\r\n  *由于返回值的函数类型不同，因此不能作为返回值使用\r\n  *统一的类型不能完成\r\n *）\r\n# let f' b = if b then k1' else k2';;\r\nError: This expression has type int -> string -> string\r\n       but an expression was expected of type int -> string -> int\r\n       Type string is not compatible with type int\r\n```\r\n\r\n给定一个多层对象类型\r\n\r\n```ocaml\r\n(* 多定义分层对象类型的函数 *)\r\n# let print1' obj = obj#print_1 and print2' obj = obj#print_2;;\r\nval print1' : < print_1 : 'a; .. > -> 'a = <fun>\r\nval print2' : < print_2 : 'a; .. > -> 'a = <fun>\r\n\r\n(* 当组合两个分层对象类型函数时 *)\r\n# let f b = if b then print1' else print2';;\r\n(*\r\n * 函数的返回值的类型为 < print_1 : 'a; print_2 : 'a; .. >\r\n * 换句话说，诸如合成每个多层对象类型的类型变成了\r\n *)\r\nval f : bool -> < print_1 : 'a; print_2 : 'a; .. > -> 'a = <fun>\r\n\r\n(* 函数调用 *)\r\n# let a = f true;;\r\nval a : < print_1 : '_a; print_2 : '_a; _.. > -> '_a = <fun>\r\n(* print_2 因为它没有类型错误 *)\r\n# a new print_class1;;\r\nError: This expression has type print_class1\r\n       but an expression was expected of type print_class2\r\n       The first object type has no method print_2\r\n(* OK, 因为它满足对象类型 *)\r\n# a new print_class2;;\r\n1- : unit = ()\r\n```\r\n#### 抽象方法·抽象类\r\n* 定义假定稍后继承\r\n* 抽象方法=>具有空定义的方法\r\n* method virtual 方法 : 类型\r\n* 抽象类=>抽象方法的类定义\r\n\r\n```ocaml\r\n\r\n(* 抽象类的定义 *)\r\n# class virtual abstruct_print =\r\n    object (self)\r\n      method virtual print : unit (* 抽象方法 *)\r\n    end;;\r\nclass virtual abstruct_print : object method virtual print : unit end\r\n\r\n(* 继承抽象类 *)\r\n# class print_hoge =\r\n    object (self)\r\n      inherit abstruct_print\r\n      method print = Printf.printf \"hoge!\\n\"\r\n    end;;\r\nclass print_hoge : object method print : unit end\r\n```\r\n class virtual\r\n\r\n#### 多阶段类（泛型）\r\n* 定义用类型参数化的对象类。\r\n* 类定义=>定义一个同名的对象类型，而不仅仅是类\r\n* 类型变量的声明是定义多层定义中的类类型所必需的\r\n* 显式声明类型变量\r\n* 请参阅中定义的类型变量\r\n\r\n#### class [类型变量, ...] 类名称 object ... end\r\n\r\n定义一个可以填充任何类型值的堆栈（从官方网站引用）\r\n\r\n```ocaml\r\n# class ['a] stack =\r\n    object (self)\r\n      val mutable list = ( [] : 'a list )  (* 实例变量 *)\r\n      method push x = list <- x :: list    (* 推入堆栈 *)\r\n      method pop =                         (* 从堆栈中移除(pop) *)\r\n        let result = List.hd list in\r\n        list <- List.tl list;\r\n        result\r\n      method peek = List.hd list     (* 堆栈峰值 *)\r\n      method size = List.length list (* 堆栈的大小 *)\r\n    end;;\r\nclass ['a] stack :\r\n  object\r\n    val mutable list : 'a list\r\n    method peek : 'a\r\n    method pop : 'a\r\n    method push : 'a -> unit\r\n    method size : int\r\n  end\r\n```\r\n\r\n使用多阶段类 \r\n\r\n```ocaml\r\n(* 生成堆栈的一个实例 *)\r\n# let s = new stack;;\r\n(* 用非约束状态的类型变量生成实例 *)\r\nval s : '_a stack = <obj>\r\n(* 添加一个浮点数 *)\r\n# s#push 1.0;;\r\n- : unit = ()\r\n(* 类型变量 '_a 被绑定为浮点数 *)\r\n# s;;\r\n- : float stack = <obj>\r\n```\r\n","source":"source\\_posts\\getting_started5.md"},{"title":"OCaml简介第4部分","description":"OCaml简介第4部分","created":"2018/07/15","author":"lanqy","link":"2018/07/15/getting_started4","htmlDir":"website\\2018\\07\\15\\getting_started4","htmlFile":"website\\2018\\07\\15\\getting_started4\\index.html","body":"\r\n## OCaml简介第4部分\r\n\r\n译自：https://qiita.com/zenwerk/items/244b84bee48bf61d2a51\r\n\r\n### 模块\r\n\r\n它是程序的一部分，但在OCaml中被称为结构。\r\n\r\n所有OCaml库都作为模块（结构）提供。\r\n\r\n#### 文件名称即是模块名称\r\n\r\n文件名 example.ml => 模块名称为 Example\r\n\r\n#### 标准模块\r\n\r\nOCaml 内置模块\r\n\r\n```ocaml\r\n(* 列表 *)\r\n# List.length [1; 2; 3];;\r\n- : int = 3\r\n# let q = Queue.create ();;\r\nval q : '_a Queue.t = <abstr>\r\n\r\n(* 队列 *)\r\n# Queue.add \"first\" q;;\r\n- : unit = ()\r\n# Queue.take q;;\r\n- : string = \"first\"\r\n# Queue.take q;;\r\nException: Queue.Empty.\r\n\r\n(* 数组 *)\r\n# Array.make 3 'a';;\r\n- : char array = [|'a'; 'a'; 'a'|]\r\n\r\n(* 标准输出 *)\r\n# Printf.printf \"%d, %x, %s\\n\" 10 255 \"hoge\";;\r\n10, ff, hoge\r\n- : unit = ()\r\n```\r\n#### open 模块\r\n\r\n通过 open 打开模块可以省略模块名称\r\n\r\n与 python 中 from hoge import * 类似\r\n\r\n由于打开到当前源的模块的名称空间已扩展，因此只有在不困惑时才能打开它。\r\n\r\n由于容器名称经常与函数名称重叠，因此不打开它们是正常的。\r\n\r\n```ocaml\r\n(* 打开模块 *)\r\n# open List;;\r\n# length [1; 2; 3];;\r\n- : int = 3\r\n\r\n(* 覆盖函数名称 *)\r\n# let length () = \"overload!\";;\r\nval length : unit -> string = <fun>\r\n# length ();;\r\n- : string = \"overload!\"\r\n\r\n(* 您可以通过指定模块名称来调用它 *)\r\n# List.length [1; 2; 3];;\r\n- : int = 3\r\n```\r\n顺便说一下，OCaml有一个名为Pervasives的模块，在启动时打开。\r\n\r\n像abs和open_in这样的函数属于这个模块。\r\n\r\n#### 模块定义\r\n\r\n模块名称以大写字母开头\r\n\r\n##### module 模块名 = struct 各种定义... end\r\n\r\n```ocaml\r\n(* 模块定义 *)\r\n# module Hello = struct\r\n    let message = \"Hello\"\r\n    let hello () = print_endline message\r\n  end;;\r\nmodule Hello : sig val message : string val hello : unit -> unit end\r\n(* 调用 *)\r\n# Hello.hello ();;\r\nHello\r\n- : unit = ()\r\n```\r\n\r\n#### 签名\r\n\r\n##### 签名\r\n* sig ... end 周围的部分\r\n* 整个模块的类型（类似）\r\n* 表示模块的I / F（可以定义可访问模块的元素）\r\n\r\n#### mli文件\r\n\r\nHoge 模块的签名可以在 hoge.mli 文件中定义。\r\n\r\n在文件中写一个签名\r\n\r\n##### 签名定义\r\n* 定义 => module type 签名名 = sig ... end\r\n* 应用 => module 模块名 : 签名名 = 模块名或 struct ... end\r\n\r\n```ocaml\r\n(* message 元素可访问 *)\r\n# Hello.message;;\r\n- : string = \"Hello\"\r\n\r\n(* message 定义未定义的签名 *)\r\n# module type Hello_Sig =\r\n    sig\r\n      val hello: unit -> unit\r\n    end;;\r\nmodule type Hello_Sig = sig val hello : unit -> unit end\r\n\r\n(* 给一个模块签名 *)\r\n# module Hello2 : Hello_Sig = Hello;;\r\nmodule Hello2 : Hello_Sig\r\n\r\n(* 因为它不是签名, message 元素不可访问 *)\r\n# Hello2.hello ();;\r\nHello\r\n- : unit = ()\r\n# Hello2.message;;\r\nError: Unbound value Hello2.message\r\n\r\n(* 直接定义模块 *)\r\n# module Hello3 : Hello_Sig = struct\r\n    let hello () = print_endline \"Hello3!\"\r\n  end;;\r\nmodule Hello3 : Hello_Sig\r\n# Hello3.hello ();;\r\nHello3!\r\n- : unit = ()\r\n# Hello3.message;;\r\nError: Unbound value Hello3.message\r\n```\r\n#### 抽象数据类型\r\n\r\n在签名定义中，省略 = ...用于类型定义（typ t = ...）\r\n\r\n您可以隐藏定义的详细信息。\r\n\r\n通过隐藏类型信息和实现，可以将该类型的操作限制为通过模块进行的操作。\r\n\r\n防止意外操作。\r\n\r\n```ocaml\r\n(* 签名定义 *)\r\n# module type AbstTypeSig = sig\r\n    type t (* 抽象数据类型 *)\r\n    val get_t : int -> t\r\n    val print : t -> unit\r\n  end;;\r\nmodule type AbstTypeSig =\r\n  sig type t val get_t : int -> t val print : t -> unit end\r\n\r\n(* 模块定义 *)\r\n# module AbstTypeInt : AbstTypeSig = struct\r\n    type t = int\r\n    let get_t i = i\r\n    let print t = print_int t\r\n  end;;\r\nmodule AbstTypeInt : AbstTypeSig\r\n\r\n(* 如果返回值是一个抽象数据类型 <abstr> *)\r\n# let t = AbstTypeInt.get_t 0;;\r\nval t : AbstTypeInt.t = <abstr>\r\n# AbstTypeInt.print t;;\r\n0- : unit = ()\r\n\r\n(* \r\n  抽象数据类型不能在外部处理\r\n  AbstTypeInt.t 是一个真正的int，但是因为它隐藏着一个抽象的数据类型\r\n  print_int 即使是作为参数引用\r\n*)\r\n# let () = print_int t;;\r\nError: This expression has type AbstTypeInt.t\r\n       but an expression was expected of type int\r\n```\r\n\r\n### Functor\r\n\r\n通过应用参数动态生成参数的函数。\r\n\r\n消除了多次定义不同模块的麻烦。\r\n\r\n#### 使用 Functor\r\n\r\n##### Functor应用程序 => Functor名称（模块化）\r\n\r\n##### ※模块化功能应用程序本身\r\n\r\n#### 处理集合 Set 模块示例\r\n\r\n标准模块的 Set 和 Queue 使用 functor\r\n\r\n对于要处理的集合的元素，定义以下模块\r\n* 定义集合元素的模块\r\n* 一个类型 t 表示一个集合的元素\r\n* 比较元素类型t的大小的函数：compare: t -> t -> int\r\n\r\n将上述“元素类型模块”应用于 functor ，生成“该类型为元素的模块”。\r\n\r\n```ocaml\r\n(* functor 应用 *)\r\n# module IntSet = Set.Make (struct\r\n    type t = int\r\n    let compare i j = i - j\r\n  end);;\r\nmodule IntSet :\r\n  sig\r\n    type elt = int (* 元素我想作为元素类型对待 elt = int *)\r\n    type t         (* 代表一个集合的类型是 IntSet.t 是一种抽象数据类型 *)\r\n    val empty : t\r\n    val is_empty : t -> bool\r\n    val mem : elt -> t -> bool\r\n    val add : elt -> t -> t\r\n    val singleton : elt -> t\r\n    val remove : elt -> t -> t\r\n    val union : t -> t -> t\r\n    val inter : t -> t -> t\r\n    val diff : t -> t -> t\r\n    val compare : t -> t -> int\r\n    val equal : t -> t -> bool\r\n    val subset : t -> t -> bool\r\n    val iter : (elt -> unit) -> t -> unit\r\n    val fold : (elt -> 'a -> 'a) -> t -> 'a -> 'a\r\n    val for_all : (elt -> bool) -> t -> bool\r\n    val exists : (elt -> bool) -> t -> bool\r\n    val filter : (elt -> bool) -> t -> t\r\n    val partition : (elt -> bool) -> t -> t * t\r\n    val cardinal : t -> int\r\n    val elements : t -> elt list\r\n    val min_elt : t -> elt\r\n    val max_elt : t -> elt\r\n    val choose : t -> elt\r\n    val split : elt -> t -> t * bool * t\r\n    val find : elt -> t -> elt\r\n    val of_list : elt list -> t\r\n  end\r\n\r\n(* 使用由 functor 生成的模块 *)\r\n# open IntSet;;\r\n# let s1 = add 2 (add 1 empty)\r\n  and s2 = add 1 (add 3 empty);;\r\nval s1 : IntSet.t = <abstr>\r\nval s2 : IntSet.t = <abstr>\r\n# mem 1 s1;;\r\n- : bool = true\r\n```\r\n\r\n#### Functor 的定义\r\n\r\n##### module functor名称（参数名称：签名表达式）= 模块化表达式\r\n\r\n以下糖衣语法\r\n\r\n##### module functor名称 = functor（参数名称：签名表达式） -> 模块化表达式\r\n\r\n定义 Set.Make 的一个简单 functor 的例子\r\n\r\n```ocaml\r\n(* 签名定义 *)\r\nmodule type ELEMENT = sig\r\n  type t\r\n  val compare: t -> t -> int\r\nend\r\n\r\n(* functor 定义 *)\r\nmodule MakeSet (Element : ELEMENT) =\r\n  struct\r\n    type elt = Element.t\r\n    type t = elt list\r\n\r\n    let empty = []\r\n\r\n    let mem x set = List.exists (fun y -> Element.compare x y = 0) set\r\n\r\n    let rec add elt = function\r\n    | [] -> [elt]\r\n    | (x :: rest as s) ->\r\n        match Element.compare elt x with\r\n        | 0 -> s\r\n        | r when r < 0 -> elt :: s\r\n        | _ -> x :: (add elt rest)\r\n\r\n    let rec elements s = s\r\n  end;;\r\n```\r\n\r\n#### 依赖类型\r\n* 上述 functor 的返回值的签名如下\r\n* Functor（Element：ELEMENT） -> 转换的描述在 sig ... end 中查看\r\n* type elt = Element.t 被写入正式参数的值包含在返回类型中\r\n* 换句话说，返回值的类型根据给定的参数值（！= Type）而变化，\r\n* 这被称为依赖类型\r\n\r\n```ocaml\r\n(* 返回顶层的值 *)\r\nmodule type ELEMENT = sig type t val compare : t -> t -> int end\r\nmodule MakeSet :\r\n  functor (Element : ELEMENT) ->\r\n    sig\r\n      type elt = Element.t\r\n      type t = elt list\r\n      val empty : 'a list\r\n      val mem : Element.t -> Element.t list -> bool\r\n      val add : Element.t -> Element.t list -> Element.t list\r\n      val elements : 'a -> 'a\r\n    end\r\n```\r\n\r\n#### functor 的信息隐藏\r\n\r\n像普通模块一样，您可以限制函数返回值的签名并隐藏内部实现。\r\n\r\n##### module functor名称（参数名称：输入签名表达式）：签名表达式返回 = 模块表达式\r\n\r\n通过指定要返回的签名表达式可以隐藏信息\r\n\r\n```ocaml\r\nmodule MakeSet (Element : ELEMENT) :\r\n  (* 签名表达式返回 *)\r\n  sig\r\n    type elt = Element.t\r\n    type t (* 抽象数据类型 *)\r\n    val mem : elt -> t -> bool\r\n    val add : elt -> t -> t\r\n    val elements : t -> elt list\r\n  end\r\n  =\r\n  (* 模块化 *)\r\n  struct\r\n    type elt = Element.t\r\n    type t = elt list\r\n\r\n    let empty = []\r\n\r\n    let mem x set = List.exists (fun y -> Element.compare x y = 0) set\r\n\r\n    let rec add elt = function\r\n    | [] -> [elt]\r\n    | (x :: rest as s) ->\r\n        match Element.compare elt x with\r\n        | 0 -> s\r\n        | r when r < 0 -> elt :: s\r\n        | _ -> x :: (add elt rest)\r\n\r\n    let rec elements s = s\r\n  end;;\r\n\r\n(* functor 表达式的返回值 *)\r\nmodule MakeSet :\r\n  functor (Element : ELEMENT) ->\r\n    sig\r\n      type elt = Element.t\r\n      type t\r\n      val empty : t\r\n      val mem : elt -> t -> bool\r\n      val add : elt -> t -> t\r\n      val elements : t -> elt list\r\n    end\r\n```\r\n\r\n比较上述函数应用方程的返回值签名公式\r\n* before\r\n```ocaml\r\n# module StringSet = MakeSet(String);;\r\nmodule StringSet :\r\n  sig\r\n    type elt = String.t\r\n    type t = elt list\r\n    val empty : 'a list\r\n    val mem : String.t -> String.t list -> bool\r\n    val add : String.t -> String.t list -> String.t list\r\n    val elements : 'a -> 'a\r\n  end\r\n```\r\n* After\r\n\r\n```ocaml\r\n# module IntSet = MakeSet(struct\r\n    type t = int\r\n    let compare i j = i - j\r\n  end);;\r\nmodule IntSet :\r\n  sig\r\n    type elt = int\r\n    type t (* 抽象数据类型 *)\r\n    val empty : t\r\n    val mem : elt -> t -> bool\r\n    val add : elt -> t -> t\r\n    val elements : t -> elt list\r\n  end\r\n\r\n# Open IntSet;;\r\n# let s1 = add 1 (add 2 empty)\r\n  and s2 = add 3 (add 4 empty);;\r\nval s1 : IntSet.t = <abstr> (* 抽象数据类型 *)\r\nval s2 : IntSet.t = <abstr>\r\n\r\n(* 当它是一个字符串 *)\r\n# module StringSet = MakeSet(String);;\r\nmodule StringSet :\r\n  sig\r\n    type elt = String.t\r\n    type t = MakeSet(String).t (* 有隐藏的实现吗？ *)\r\n    val empty : t\r\n    val mem : elt -> t -> bool\r\n    val add : elt -> t -> t\r\n    val elements : t -> elt list\r\n  end\r\n\r\n# open StringSet;;\r\n# let s1 = add \"a\" (add \"b\" empty)\r\n  and s2 = add \"c\" (add \"d\" empty);;\r\nval s1 : StringSet.t = <abstr> (* 这是一个抽象的数据类型 *)\r\nval s2 : StringSet.t = <abstr>\r\n```\r\n\r\n#### 签名的分解和定义（ with type ）\r\n\r\n签名表达式 with type 类型名 = 类型定义 and type ...\r\n\r\n不要指定你希望 functor 直接用 sig ... end 返回的签名定义，而是要给它定义名称。\r\n\r\ntype elt = Element.t 部分\r\n\r\n签名不能被定义为别名，因为它取决于伪参数名称\r\n\r\n```ocaml\r\nmodule MakeSet (Element : ELEMENT) :\r\n  (* 签名表达式返回 *)\r\n  sig\r\n    type elt = Element.t\r\n    type t (* 抽象数据类型 *)\r\n  end\r\n  =\r\n  struct ... end;;\r\n```\r\n\r\n#### with type 语法使用\r\n\r\n```ocaml\r\n(* with type 类型定义替换 elt *)\r\n# module type ElementWithType =\r\n    sig\r\n      type elt\r\n      type t\r\n      val empty : t\r\n      val mem : elt -> t -> bool\r\n      val add : elt -> t -> t\r\n      val elements : t -> elt list\r\n    end;;\r\n\r\n(* with type 定义 *)\r\n# module type E2 = ElementWithType with type elt = int;;\r\nmodule type E2 =\r\n  sig\r\n    type elt = int\r\n    type t\r\n    val empty : t\r\n    val mem : elt -> t -> bool\r\n    val add : elt -> t -> t\r\n    val elements : t -> elt list\r\n  end\r\n```\r\n\r\n### 批处理编译器和拆分编译\r\n\r\n编译器通过file => 批量编译器导出\r\n\r\n以文件为单位创建一个目标文件Link => 分割编译\r\n\r\nocaml 的批处理编译器 => ocamlc（bytecode），ocamlopt（本地代码）\r\n\r\n#### 统一编译\r\n\r\n```ocaml\r\n$ ocamlc -o output.name src1.ml src2.ml ...\r\n```\r\n\r\n#### 拆分编译\r\n\r\n* 需要安排最后一个链接的 cmo 文件，以便名称解析成为可能\r\n* 非标准库\r\n* 链接时有必要明确指出文件名\r\n* nums.cma 等\r\n* -c 选项输出目标文件而不链接\r\n* -I 允许您指定包含 cmi，cmo 的目录\r\n\r\n```ocaml\r\n$ ocamlc -c mod1.ml\r\n$ ocamlc -c mod2.ml\r\n$ ocamlc -o output.name nums.cma mod1.cmo mod2.cmo\r\n```\r\n\r\n#### mli文件 \r\n\r\nmli 文件描述了相应的 .ml 签名\r\n\r\n在编译时使用 ocamlc\r\n\r\n用 ocamlc 编译 mli 文件\r\n\r\n用 ocamlc -c编译ml文件\r\n\r\n链接 cmo 与 ocamlc\r\n\r\n```ocaml\r\n$ ocamlc mod.mli  # -c 没有选项要求\r\n$ ocamlc -c mod.ml\r\n$ ocamlc -c mod2.ml\r\n$ ocamlc -o a.out mod.cmo mod2.cmo\r\n```\r\n","source":"source\\_posts\\getting_started4.md"},{"title":"OCaml简介第3部分","description":"OCaml简介第3部分","created":"2018/07/14","author":"lanqy","link":"2018/07/14/getting_started3","htmlDir":"website\\2018\\07\\14\\getting_started3","htmlFile":"website\\2018\\07\\14\\getting_started3\\index.html","body":"\r\n## OCaml简介第3部分\r\n\r\n译自：https://qiita.com/zenwerk/items/bfc1978718b5da3f463b\r\n\r\n### 异常处理\r\n\r\n它在您除以零或指定一个不存在的文件时发生。\r\n\r\n```ocaml\r\n# 1/0;;\r\nException: Division_by_zero.\r\n# open_in \"\";;\r\nException: Sys_error \": No such file or directory\".\r\n```\r\n#### 抛出异常（ raise 表达式 ）\r\n\r\n##### raise 异常\r\n##### raise（ 异常参数 ）\r\n\r\n如果异常需要参数，则（）是必需的。\r\n\r\n```ocaml\r\n# raise Not_found;;\r\nException: Not_found.\r\n# raise (Sys_error \": No such file or directory\");;\r\nException: Sys_error \": No such file or directory\".\r\n# raise (Sys_error \": 我会抛出异常！\");;\r\nException: Sys_error \": ?\\136\\145?\\154?\\138\\155?\\135??\\130常?\\129\".\r\n```\r\n\r\n```ocaml\r\n# let rec fact n =\r\n    if n < 0 then raise (Invalid_argument \": negative argument\")\r\n    else if n = 0 then 1 else n * fact (n-1);;\r\nval fact : int -> int = <fun>\r\n# fact 5;;\r\n- : int = 120\r\n# fact (-1);;\r\nException: Invalid_argument \": negative argument\".\r\n```\r\n\r\n#### 异常处理( try with )\r\n\r\n##### try 表达式 with 异常1 -> 表达式1 | ...\r\n\r\n```ocaml\r\n# try raise Not_found with\r\n  | Not_found -> \"not found !\"\r\n  | _ -> \"unknown !\";;\r\n- : string = \"not found !\"\r\n\r\n(* 前面定义的 fact 函数例子 *)\r\n# try fact (-1) with\r\n  | Invalid_argument _ -> 0\r\n  | _ -> 9999;;\r\n- : int = 0\r\n```\r\n#### 异常定义\r\n\r\n异常类型的构造函数中称为异常构造函数。\r\n该变种是 exn 类型\r\n\r\n```ocaml\r\n(* 确认异常的变体类型 *)\r\n# Not_found;;\r\n- : exn = Not_found\r\n# raise;;\r\n- : exn -> 'a = <fun>\r\n```\r\n\r\n异常定义是为exn类型添加一个新的构造函数。\r\n\r\nexn类型是特殊的，你可以稍后添加一个构造函数。\r\n\r\n##### exception 异常名\r\n\r\n```ocaml\r\n(* 异常定义 *)\r\n# exception Hoge;;\r\nexception Hoge\r\n# exception Fuga of string;;\r\nexception Fuga of string\r\n# raise Hoge;;\r\nException: Hoge.\r\n# raise (Fuga \"fuga!\");;\r\nException: Fuga \"fuga!\".\r\n```\r\n\r\n#### 关于exn类型\r\n\r\n既然exn也是一个变体类型，它也可以作为一个参数传递。\r\n\r\n```ocaml\r\n# exception Hoge;;\r\nexception Hoge\r\n\r\n(* exn 类型列表 *)\r\n# let exnlist = [Not_found; Hoge; (Invalid_argument \"fuga\")];;\r\nval exnlist : exn list = [Not_found; Hoge; Invalid_argument \"fuga\"]\r\n\r\n(* 接收exn类型的函数 *)\r\n# let f = function\r\n  | Hoge -> \"hoge!\"\r\n  | x -> raise x;;\r\nval f : exn -> string = <fun>\r\n# f Hoge;;\r\n- : string = \"hoge!\"\r\n# f Not_found;;\r\nException: Not_found.\r\n```\r\n### unit 类型\r\n\r\n输出字符串的程序。\r\n\r\n```ocaml\r\n# print_string \"hoge\\n\";;\r\nhoge\r\n- : unit = ()\r\n```\r\n返回类型是 unit 类型\r\n\r\nunit 类型的值只是一个名为（）的常量，称为 unit 值。\r\n\r\n#### unit 类型的用法\r\n\r\n* （）上没有可以执行的操作\r\n* 用作返回值本身没有意义的函数的返回值\r\n* 在定义不需要有意义的参数的函数时用作参数\r\n\r\n```ocaml\r\n# let const () = 777;;\r\nval const : unit -> int = <fun>\r\n# const ();;\r\n- : int = 777\r\n```\r\n\r\n##### 用作判断操作是否成功的返回值\r\n\r\n```ocaml\r\n（*\r\n   () 将匹配模式，如果操作成功，将返回单位类型。\r\n   也就是说，如果匹配成功，则表示操作成功。\r\n*）\r\n# let () = Bytes.set \"Test\" 1 'C';;\r\n```\r\n\r\n### 可变的数据结构\r\n\r\n#### 修改字符串\r\n\r\n##### \"string\".[index] <- 'char'\r\n\r\n```ocaml\r\n# let s = \"life\";;\r\nval s : string = \"life\"\r\n# s.[2] <- 'v';;\r\n- : unit = ()\r\n# s;;\r\n- : string = \"live\"\r\n\r\n(* String.set 弃用 *)\r\n# let f2 = \"hoge\";;\r\nval f2 : string = \"hoge\"\r\n# Bytes.set f2 0 'H';;\r\n- : unit = ()\r\n# f2;;\r\n- : string = \"Hoge\"\r\n```\r\n\r\n##### 该操作操作参考目的地 \r\n\r\n```ocaml\r\n# let s = \"hoge\";;\r\nval s : string = \"hoge\"\r\n# let a = (s, s);;\r\nval a : string * string = (\"hoge\", \"hoge\")\r\n# Bytes.set s 3 'E';;\r\n- : unit = ()\r\n\r\n(* 两者都被改变，因为参考目标是相同的 *)\r\n# a;;\r\n- : string * string = (\"hogE\", \"hogE\")\r\n```\r\n\r\n#### 物理相等\r\n\r\n##### 物理相等 => 比较数据地址时的平等性\r\n\r\n* 使用 ==, !=\r\n\r\n##### 结构相等 => 平等作为价值进行比较\r\n\r\n* 使用=，<>\r\n\r\n```ocaml\r\n# let s1 = \"hoge\" and s2 = \"hoge\";;\r\nval s1 : string = \"hoge\"\r\nval s2 : string = \"hoge\"\r\n(* 结构相等 *)\r\n# s1 = s2;;\r\n- : bool = true\r\n(* 物理相等 *)\r\n# s1 == s2;;\r\n- : bool = false\r\n# s1 != s2;;\r\n- : bool = true\r\n```\r\n#### 可修改的记录\r\n* 修改记录 => 使用 mutable 关键字\r\n* 记录修改 => record.field <- 值\r\n\r\n```ocaml\r\n# type account = {name:string;mutable amount:int};;\r\ntype account = { name : string; mutable amount : int; }\r\n# let ac = {name = \"bob\"; amount = 1000};;\r\nval ac : account = {name = \"bob\"; amount = 1000}\r\n# ac.amount <- 999;;\r\n- : unit = ()\r\n# ac;;\r\n- : account = {name = \"bob\"; amount = 999}\r\n(* 不可改变 *)\r\n# let () = ac.name <- \"Hoge\";;\r\nError: The record field name is not mutable\r\n(* 这样是可以的 *)\r\n# ac.name.[0] <- 'B';;\r\n- : unit = ()\r\n# ac;;\r\n- : account = {name = \"Bob\"; amount = 999}\r\n```\r\n\r\n#### 创建引用（ ref ）\r\n* 创建引用 => ref函数\r\n* 引用获取 => !引用\r\n* 引用目标重写 => 引用 := 值\r\n\r\n```ocaml\r\n(* 创建引用 *)\r\n# let h = ref \"Hoge\" and f = ref \"Fuga\";;\r\nval h : string ref = {contents = \"Hoge\"}\r\nval f : string ref = {contents = \"Fuga\"}\r\n\r\n(* 引用获取 *)\r\n# let () = print_string (!h ^ !f ^ \"\\n\");;\r\nHogeFuga\r\n\r\n(* 引用重写 *)\r\n# h := !f;;\r\n- : unit = ()\r\n# let () = print_string (!h ^ !f ^ \"\\n\");;\r\nFugaFuga\r\n```\r\n\r\n#### 引用的引用 ( ref ref )\r\n\r\n它也可以像C语言中的双指针一样\r\n```ocaml\r\n(* 创建引用 *)\r\n# let r1 = ref 5 and r2 = ref 2;;\r\nval r1 : int ref = {contents = 5}\r\nval r2 : int ref = {contents = 2}\r\n(* 引用的引用创建 *)\r\n# let rr1 = ref r1 and rr2 = ref r2;;\r\nval rr1 : int ref ref = {contents = {contents = 5}}\r\nval rr2 : int ref ref = {contents = {contents = 2}}\r\n(* 引用操作 *)\r\n# let () = !rr1 := !(!rr2);;\r\n# (!r1, !r2);;\r\n- : int * int = (2, 2)\r\n```\r\n\r\n#### 数组\r\n* [|值1;值2; ... |]\r\n* 引用元素 => [| ... |].( 下标 )\r\n* 改变数组元素 => [| ... |].( 下标 ) <- value\r\n\r\n数组的长度是固定的。\r\n\r\n您可以通过下标直接获取任何元素。\r\n\r\n### 程序控制结构\r\n\r\n作为OCaml的规范，参数的评估顺序是未定义的。\r\n\r\n因此，准备了用于像过程性语言那样控制执行顺序的语法。\r\n\r\n#### 顺序执行\r\n\r\n##### 表达式1; 表达式2; ... 表达式n\r\n\r\n与如下如下代码一样\r\n\r\n```ocaml\r\nlet _ = 表达式1 in\r\nlet _ = 表达式2 in\r\n.\r\n.\r\n.\r\n表达式n\r\n```\r\n最后的表达式n是整个返回值。\r\n\r\n#### begin 与 end\r\n\r\n你可以写 begin 表达式1; ...表达式n end ，而不是（表达式; ...表达式n）\r\n\r\n这似乎是首选。\r\n\r\n#### ignore\r\n\r\n如果相当于一个句子的表达式返回非 unit 类型，则会出现警告\r\n\r\n忽略警告的函数 \r\n\r\n```ocaml\r\n(* 将返回值设置为0（int） *)\r\n# let print_hello () = print_string \"Hello, \"; 0;;\r\nval print_hello : unit -> int = <fun>\r\n\r\n(* 警告出现在 print_hello *)\r\n# print_hello (); print_string \"World\\n\";;\r\nWarning 10: this expression should have type unit.\r\nHello, World\r\n- : unit = ()\r\n\r\n(* 忽略不发出警告 *)\r\n# ignore (print_hello ()); print_string \"World\\n\";;\r\nHello, World\r\n- : unit = ()\r\n```\r\n;是一个分隔符\r\n\r\n;不是终止符，它被用作分隔符。\r\n\r\n因此，要小心如果在表达式n的末尾添加一个分号作为表达式n，经常会出现额外的错误。\r\n\r\n#### 条件语句\r\n\r\nif then 的 then 子句的返回值是（），则else可以省略。\r\n\r\nif 表达式1 then 表达式2 => if 表达式1 then 表达式2 else（）\r\n\r\n这意味着如果表达式1不成立，将会做任何事情。\r\n\r\n#### 循环语句\r\n\r\nfor 和 while 语句\r\n\r\n##### for \r\n\r\nfor => for variable = start_value to end_value do 表达式 done\r\n\r\n或\r\n\r\nfor variable = start_value downto end_value do 表达式 done\r\n\r\n```ocaml\r\n(* for 循环 *)\r\n# for i = 1 to 10 do begin print_int i; () end done;;\r\n12345678910- : unit = ()\r\n# for i = 10 downto 1 do begin print_int i; () end done;;\r\n10987654321- : unit = ()\r\n```\r\n\r\n##### while\r\n\r\nwhile 条件 do 表达式 done\r\n\r\nwhile据说它用得不多。\r\n\r\n```ocaml\r\nlet quit_loop = ref false in\r\n  while not !quit_loop do\r\n  print_string \"Have you had enough yet? (y/n) \";\r\n  let str = read_line () in\r\n  if str.[0] = 'y' then\r\n      quit_loop := true\r\n  done;;\r\nHave you had enough yet? (y/n) n\r\nHave you had enough yet? (y/n) y\r\n- : unit = ()\r\n```\r\n","source":"source\\_posts\\getting_started3.md"},{"title":"OCaml简介第2部分","description":"OCaml简介第2部分","created":"2018/07/13","author":"lanqy","link":"2018/07/13/getting_started2","htmlDir":"website\\2018\\07\\13\\getting_started2","htmlFile":"website\\2018\\07\\13\\getting_started2\\index.html","body":"\r\n## OCaml简介第 2 部分\r\n\r\n译自：https://qiita.com/zenwerk/items/603bd383fe5c6b8cace3\r\n\r\n### 递归多层数据结构。\r\n\r\n列表类型\r\n\r\n```ocaml\r\n# [1;2;3;4;5];;\r\n- : int list = [1; 2; 3; 4; 5]\r\n# [\"a\"; \"b\"; \"c\"];;\r\n- : string list = [\"a\"; \"b\"; \"c\"]\r\n(* 不同的类型不能存在于同一个列表 *)\r\n# [1; \"a\"];;\r\nError: This expression has type string but an expression was expected of type int\r\n```\r\n\r\n### 将值添加到列表的开头\r\n\r\n使用consus操作符(::)。\r\n\r\n右结合\r\n\r\n```ocaml\r\n# 1 :: [2; 3; 4];;\r\n- : int list = [1; 2; 3; 4]\r\n\r\n(* 右結合 *)\r\n# 1 :: 2 :: [3; 4];;\r\n- : int list = [1; 2; 3; 4]\r\n```\r\n\r\n### 列表合并\r\n\r\n使用 @ 。\r\n\r\n```ocaml\r\n# [] @ [];;\r\n- : 'a list = []\r\n# [1] @ [2; 3];;\r\n- : int list = [1; 2; 3]\r\n# [\"asdf\"; \"hoge\"] @ [\"fuga\"];;\r\n- : string list = [\"asdf\"; \"hoge\"; \"fuga\"]\r\n```\r\n\r\n### 模式匹配\r\n\r\nmatch 表达式\r\n\r\nmatch 表达式 with 模式1 - >表达式 | 模式2 - >表达式...\r\n\r\n找到整数列表的总和的例子:\r\n\r\n```ocaml\r\n# let rec total l =\r\n    match l with\r\n      [] -> 0\r\n    | h :: rest -> h + (total rest);;\r\nval total : int list -> int = <fun>\r\n# total [1; 2; 3; 4; 5];;\r\n- : int = 15\r\n```\r\n反转列表的函数示例:\r\n\r\n```ocaml\r\n# let reverse l =\r\n    let rec innerReverse l1 l2 =\r\n      match l1 with\r\n      | [] -> l2\r\n      | h :: rest -> innerReverse rest (h :: l2)\r\n    in\r\n    innerReverse l [];;\r\nval reverse : 'a list -> 'a list = <fun>\r\n# reverse [1; 2; 3; 4];;\r\n- : int list = [4; 3; 2; 1]\r\n```\r\n\r\n### function 表达式\r\n\r\nfun 和 match 通过组合定义一个匿名函数\r\n\r\nfunction 模式1 - > 表达式 | 模式2 - > 表达式...\r\n\r\n上面整数列表的总和的例子可以改写如下：\r\n\r\n当使用最后一个参数进行模式匹配时方便，并且该参数仅用于模式匹配\r\n\r\n```ocaml\r\n# let rec total = function\r\n    [] -> 0\r\n  | h :: rest -> h + (total rest);;\r\nval total : int list -> int = <fun>\r\n# total [1; 2; 3; 4; 5];;\r\n- : int = 15\r\n```\r\n\r\n### map 函数的例子\r\n\r\n```ocaml\r\n# let rec map fn = function\r\n    | [] -> []\r\n    | h :: rest -> fn h :: map fn rest;;\r\nval map : ('a -> 'b) -> 'a list -> 'b list = <fun>\r\n# map (fun x -> x + 1) [1; 2; 3; 4];;\r\n- : int list = [2; 3; 4; 5]\r\n```\r\n### fold (折叠)函数例子\r\n\r\n```ocaml\r\n(* 左fold *)\r\n# let rec foldl fn acc l =\r\n    match l with\r\n    | [] -> acc\r\n    | h :: rest -> foldl fn (fn acc h) rest;;\r\n\r\n(* 用于查找列表长度的 fold 示例 *)\r\n# foldl (fun acc x -> acc + 1) 0 [1; 2; 3];;\r\n- : int = 3\r\n\r\n(* 右fold *)\r\n# let rec foldr fn l acc =\r\n    match l with\r\n    | [] -> acc\r\n    | h :: rest -> fn h (foldr fn rest acc);;\r\nval foldr : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b = <fun>\r\n```\r\n\r\n### 模式匹配守卫子句\r\n\r\nmatch 表达式 with 模式1 when 真/假表达式 - >表达式| ...\r\n\r\n使用 when。\r\n\r\n### 注意：match，function 中没有关闭符号\r\n\r\n在match with 和 function 上没有结束符号。\r\n\r\n因此，当模式匹配嵌套时，必须用（）等括起来\r\n\r\n### 数据结构\r\n\r\n#### 记录（record）\r\n\r\nC语言结构，数据结构等同于 Python 字典。\r\n\r\n命名元素名称。\r\n\r\n#### 记录定义\r\n\r\n* type name = {field name：type; ...}\r\n* 字段 - > 名称和值对\r\n* 请注意，字段名称不能与其他记录重复\r\n\r\n```ocaml\r\n# type student = {name: string; id: int};;\r\ntype student = { name : string; id : int; }\r\n```\r\n#### 创建记录\r\n\r\n* {Field name = value; ...}\r\n\r\n```ocaml\r\n# let s = {name = \"hoge\"; id = 1};;\r\nval s : student = {name = \"hoge\"; id = 1}\r\n```\r\n\r\n### 记录转移\r\n\r\n创建一个新的记录值，而不是覆盖现有的值。\r\n\r\n{记录 with 字段名称 = 值; ...}\r\n\r\n```ocaml\r\n# let s2 = {s with name = \"fuga\"};;\r\nval s2 : student = {name = \"fuga\"; id = 1}\r\n```\r\n### 变体\r\n\r\n数据结构代表案例分类。 \r\n\r\n```ocaml\r\ntype name =\r\n  | 构造函数 [ of <type> [* <type>]... ]\r\n  | 构造函数 [ of <type> [* <type>]... ]\r\n  | ...\r\n```\r\n* 构造函数以英文大写字母开头\r\n* of 是构造函数所需的参数类型\r\n* of int * int 参数不是一组 int ，两个 int\r\n* of (int * int) 参数是一对 int\r\n\r\n以下是四种数字的变体类型：\r\n\r\n```ocaml\r\n# type figure =\r\n  | Point\r\n  | Circle of int\r\n  | Rectangle of int * int (* 两个 int 类型的参数，不是元组 *)\r\n  | Square of int;;\r\ntype figure = Point | Circle of int | Rectangle of int * int | Square of int\r\n\r\n# let c = Circle 4;;\r\nval c : figure = Circle 4\r\n# let figs = [Point; Rectangle (1, 1); c];;\r\nval figs : figure list = [Point; Rectangle (1, 1); Circle 4]\r\n```\r\n\r\n### 变体的模式匹配\r\n\r\n#### function | 构造函数的参数 -> | ...\r\n\r\n省略参数部分意味着没有参数构造函数。\r\n\r\n```ocaml\r\n(* 计算图形面积的例子 *)\r\n# let area = function\r\n  | Point -> 0\r\n  | Circle r -> r * r * 3\r\n  | Rectangle (x, y) -> x * y\r\n  | Square x -> x * x;;\r\nval area : figure -> int = <fun>\r\n# area c;;\r\n- : int = 48\r\n```\r\n\r\n### 多态变体类型\r\n\r\n* 可以使用类型变量（ 'a 等）来定义变体类型，\r\n* 它也被称为带参数的参数。\r\n* 例如，'a list 可以使用多态变量来表示。\r\n\r\n```ocaml\r\n# type 'a mylist =\r\n  | Nil\r\n  | Cons of 'a * 'a mylist;;\r\ntype 'a mylist = Nil | Cons of 'a * 'a mylist\r\n# Nil;;\r\n- : 'a mylist = Nil\r\n\r\n(* 表示一个整数列表 *)\r\n# Cons(1, Nil);;\r\n- : int mylist = Cons (1, Nil)\r\n\r\n(* 表示字符列表 *)\r\n# Cons('a', Cons('b', Nil));;\r\n- : char mylist = Cons ('a', Cons ('b', Nil))\r\n```\r\n\r\n### Optional\r\n\r\n通常说可选，表明这些情况下没有值\r\n\r\n```ocaml\r\n# type 'a option =\r\n  | None\r\n  | Some of 'a;;\r\ntype 'a option = None | Some of 'a\r\n```\r\n使用可选的示例\r\n\r\n```ocaml\r\n# let fact n =\r\n    let rec fact' n = if n = 0 then 1 else n * fact' (n - 1) in\r\n    if n < 0 then None else Some (fact' n);;\r\nval fact : int -> int option = <fun>\r\n# fact 3;;\r\n- : int option = Some 6\r\n# fact (-10);;\r\n- : int option = None\r\n```\r\n\r\n### 递归变体类型\r\n\r\n在构造函数中 of 下面是它自己的类型出现的变体类型\r\n\r\n#### 二叉树的例子\r\n\r\n```ocaml\r\n# type 'a btree =\r\n  | Leaf\r\n  | Node of 'a * 'a btree * 'a btree;;\r\ntype 'a btree = Leaf | Tree of 'a * 'a btree * 'a btree\r\n\r\n# Node(1, Node(1, Leaf, Leaf), Node(1, Node(1, Leaf, Leaf), Leaf));;\r\n- : int btree =\r\nNode (1, Node (1, Leaf, Leaf), Node (1, Node (1, Leaf, Leaf), Leaf))\r\n```\r\n查找树的元素数量和高度的函数示例\r\n\r\n```ocaml\r\n# let tr = Node(1, Node(1, Leaf, Leaf), Node(1, Node(1, Leaf, Leaf), Leaf));;  \r\nval tr : int btree =\r\n  Node (1, Node (1, Leaf, Leaf), Node (1, Node (1, Leaf, Leaf), Leaf))\r\n\r\n(* 用于查找高度的函数 *)\r\n# let rec height = function\r\n  | Leaf -> 0\r\n  | Node(_, left, right) -> 1 + max (height left) (height right);;\r\nval height : 'a btree -> int = <fun>\r\n# height tr;;\r\n- : int = 3\r\n\r\n(* 用于查找元素数目的函数 *)\r\n# let rec size = function\r\n  | Leaf -> 0\r\n  | Node (_, left, right) -> 1 + size left + size right;;\r\nval size : 'a btree -> int = <fun>\r\n# size tr;;\r\n- : int = 4\r\n```\r\n\r\n#### 二叉搜索树的例子\r\n\r\n* 添加元素\r\n\r\n```ocaml\r\n# let rec insert x = function\r\n  | Leaf -> Node(x, Leaf, Leaf)\r\n  | Node(k, left, right) ->\r\n      if x < k then Node(k, insert x left, right)\r\n      else Node(k, left, insert x right);;\r\nval insert : 'a -> 'a btree -> 'a btree = <fun>\r\n```\r\n\r\n* 搜索元素\r\n\r\n```ocaml\r\n# let rec mem x = function\r\n  | Leaf -> false\r\n  | Node(k, left, right) ->\r\n      if x < k then mem x left\r\n      else if x = k then true\r\n      else mem x right;;\r\nval mem : 'a -> 'a btree -> bool = <fun>\r\n```\r\n\r\n* 使用例子\r\n\r\n```ocaml\r\n# let tr = Leaf;;\r\nval tr : 'a btree = Leaf\r\n# tr;;\r\n- : 'a btree = Leaf\r\n# insert 10 tr;;\r\n- : int btree = Node (10, Leaf, Leaf)\r\n# let tr = insert 10 tr;;\r\nval tr : int btree = Node (10, Leaf, Leaf)\r\n# let tr = insert 5 tr;;\r\nval tr : int btree = Node (10, Node (5, Leaf, Leaf), Leaf)\r\n# let tr = insert 20 tr;;\r\nval tr : int btree = Node (10, Node (5, Leaf, Leaf), Node (20, Leaf, Leaf))\r\n# mem 5 tr;;\r\n- : bool = true\r\n# mem 15 tr;;\r\n- : bool = false\r\n```\r\n\r\n### 玫瑰树的一个例子\r\n\r\n玫瑰树是元素数量未知的树。\r\n\r\n它可以被认为是与 UNIX 相同的目录结构。\r\n\r\n* 类型定义 \r\n\r\n```ocaml\r\n(* 由于子元素的数量是不确定的，节点的元素是列表 *)\r\n# type 'a rosetree = RLeaf | RNode of 'a * 'a rosetree list;;\r\ntype 'a rosetree = RLeaf | RNode of 'a * 'a rosetree list\r\n```\r\nXML作为玫瑰树\r\n\r\n* 类型定义\r\n\r\n因为它是 XML ，叶子也没有价值 - >（'b option）\r\n\r\n```ocaml\r\n(* 'a 标记, 'b 值 *)\r\n# type ('a, 'b) xml = XLeaf of 'b option | XNode of 'a * ('a, 'b) xml list;;\r\ntype ('a, 'b) xml = XLeaf of 'b option | XNode of 'a * ('a, 'b) xml list\r\n```\r\n对XML数据结构进行字符串化的函数\r\n\r\n递归XML（Rose Tree）包含一个递归数据结构的列表\r\n\r\n它是相互递归的定义\r\n```ocaml\r\n# let rec string_of_xml = function\r\n  | XNode(tag, xml_list) -> \"<\" ^ tag ^ \">\" ^ string_of_xmllist xml_list ^ \"</\" ^ tag ^ \">\"\r\n  | XLeaf None -> \"\"\r\n  | XLeaf(Some s) -> s\r\n  and\r\n  string_of_xmllist = function\r\n  | [] -> \"\"\r\n  | xml :: rest -> string_of_xml xml ^ string_of_xmllist rest;;\r\nval string_of_xml : (string, string) xml -> string = <fun>\r\nval string_of_xmllist : (string, string) xml list -> string = <fun>\r\n```\r\n\r\n### 无限的列\r\n\r\n#### 整数的无限列的例子\r\n\r\n```ocaml\r\n# type intseq = Cons of int * (int -> intseq);;\r\ntype intseq = Cons of int * (int -> intseq)\r\n```\r\n* 无限列的示例递增\r\n\r\n```ocaml\r\n# let rec f x = Cons(x+1, f);;\r\nval f : int -> intseq = <fun>\r\n# f 0;;\r\n- : intseq = Cons (1, <fun>)\r\n# f 100;;\r\n- : intseq = Cons (101, <fun>)\r\n```\r\n* 如果返回值的 x 是下一个元素\r\n\r\n   通过给x作为参数，我们得到元素的顺序\r\n   \r\n```ocaml\r\n# let Cons(x, f) = f 0;;\r\nval x : int = 1\r\nval f : int -> intseq = <fun>\r\n# let Cons(x, f) = f x;;\r\nval x : int = 2\r\nval f : int -> intseq = <fun>\r\n# let Cons(x, f) = f x;;\r\nval x : int = 3\r\nval f : int -> intseq = <fun>\r\n```\r\n* 获取第 N 个元素函数\r\n\r\n```ocaml\r\n# let rec nthseq n (Cons(x, f)) =\r\n    if n = 1 then x\r\n    else nthseq (n-1) (f x);;\r\nval nthseq : int -> intseq -> int = <fun>\r\n# nthseq 10 (f 0);;\r\n- : int = 10\r\n```\r\n","source":"source\\_posts\\getting_started2.md"},{"title":"OCaml简介第1部分","description":"OCaml简介第1部分","created":"2018/07/12","author":"lanqy","link":"2018/07/12/getting_started1","htmlDir":"website\\2018\\07\\12\\getting_started1","htmlFile":"website\\2018\\07\\12\\getting_started1\\index.html","body":"\r\n# OCaml 简介第 1 部分\r\n\r\n译自 : https://qiita.com/zenwerk/items/3bdf7eef6b7511e11b2c\r\n\r\n## 函数式语言\r\n\r\n函数式语言 => 执行程序 = 执行表达式\r\n\r\n执行表达式 => 计算表达式（eval）以获得值\r\n\r\n![函数式语言原理图](/images/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e616d617a6f6e6177732e636f6d2f302f343432382f65373633373633322d393262342d623736342d623063652d6465366161653933396161342e706e67.png)\r\n\r\n## 基本类型\r\n\r\n### 整型（int）\r\n\r\n#### 字首\r\n\r\n-   二进制 0b\r\n-   八进制 Oo\r\n-   十六进制 0x\r\n\r\n```ocaml\r\n# 351;;\r\n- : int = 351\r\n# 12345;;\r\n- : int = 12345\r\n# 0o523;;\r\n- : int = 339\r\n# 0xffff;;\r\n- : int = 65535\r\n```\r\n\r\n### 浮点数（float）\r\n\r\n```ocaml\r\n# 3.141;;\r\n- : float = 3.1415\r\n# 1.04e10;;\r\n- : float = 10400000000.\r\n# 25e-15;;\r\n- : float = 2.5e-14\r\n```\r\n\r\n### 字符（char）\r\n\r\n-   将其用单引号括起来，用单字节字母数字字符（ascii 字符）\r\n\r\n```ocaml\r\n# 'a';;\r\n- : char = 'a'\r\n# '\\101';;\r\n- : char = 'e'\r\n# '\\n';;\r\n- : char = '\\n'\r\n```\r\n\r\n### 字符串（string）\r\n\r\n-   用双引号括起来。\r\n-   一个字符串，一个字符可以用[下标]获取。\r\n\r\n```ocaml\r\n# \"string\";;\r\n- : string = \"string\"\r\n# \"string\".[0];;\r\n- : char = 's'\r\n```\r\n\r\n### 类型转换\r\n\r\n-   从 X 类型转换为 Y 类型的函数的命名规则为 Y_of_X。\r\n\r\n```ocaml\r\n# float_of_int 5;;\r\n- : float = 5.\r\n# int_of_float 5.;;\r\n- : int = 5\r\n- # string_of_int 123;;\r\n- : string = \"123\"\r\n# int_of_string \"123\";;\r\n- : int = 123\r\n```\r\n\r\n### 元组\r\n\r\n-   (类型名 \\* 类型名...)\r\n\r\n```ocaml\r\n# (1, 2);;\r\n- : int * int = (1, 2)\r\n# ('a', 1, \"str\", 4.3);;\r\n- : char * int * string * float = ('a', 1, \"str\", 4.3)\r\n# ((1, 2), ('a', \"str\"));;\r\n- : (int * int) * (char * string) = ((1, 2), ('a', \"str\"))\r\n```\r\n\r\n### 定义变量\r\n\r\n#### let 定义（let defenition）\r\n\r\n-   let 变量名称 = 表达式\r\n\r\n```ocaml\r\n# let hoge = 1;;\r\nval hoge : int = 1\r\n```\r\n\r\n#### 可以同时定义\r\n\r\n-   let 变量名称 = 表达式 1 and 表达式 2\r\n\r\n```ocaml\r\n# let a = 1 and b = 2;;\r\nval a : int = 1\r\nval b : int = 2\r\n```\r\n\r\n### 定义函数\r\n\r\n#### let 函数名 参数 = 表达式\r\n\r\n```ocaml\r\n# let twice s = s ^ s;;\r\nval twice : string -> string = <fun>\r\n```\r\n\r\n包含参数（）是可选的。\r\n\r\n#### let 表达式（let expression）\r\n\r\n-   与 let 定义不同。\r\n-   用于在函数中定义临时变量（局部变量）的表达式。\r\n-   let 变量名 = 表达式 1 in 表达式 2\r\n\r\n```ocaml\r\n# let four_times s =\r\n  let twice = s ^ s in\r\n  twice ^ twice;;\r\nval four_times : string -> string = <fun>\r\n```\r\n\r\n### 递归定义\r\n\r\n#### 用 let rec 定义。\r\n\r\n-   使用 rec 可以引用函数定义中定义的函数名称。\r\n\r\n阶乘的例子:\r\n\r\n```ocaml\r\n# let rec fact x =\r\n    if x <= 1 then 1 else x * fact (x - 1);;\r\nval fact : int -> int = <fun>\r\n# fact 5;;\r\n- : int = 120\r\n```\r\n\r\n### 相互递归\r\n\r\n-   两个或多个函数相互调用的样式的递归定义。\r\n\r\n-   let rec 函数名称 1 参数 1 = 表达式 1 and 函数名称 2 参数 2 = 表达式 2 and ...\r\n\r\n```ocaml\r\n# let rec even n =\r\n    match n with\r\n    | 0 -> true\r\n    | x -> odd (x-1)\r\n  and odd n =\r\n    match n with\r\n    | 0 -> false\r\n    | x -> even (x-1);;\r\nval even : int -> bool = <fun>\r\nval odd : int -> bool = <fun>\r\n\r\n# even 10;;\r\n- : bool = true\r\n# even 3;;\r\n- : bool = false\r\n# odd 3;;\r\n- : bool = true\r\n# odd 10;;\r\n- : bool = false\r\n```\r\n\r\n### 匿名函数\r\n\r\n#### fun 参数名 = 表达式\r\n\r\n-   let f 参数 = 表达式 是 let f = fun 参数 = 表达式 的语法糖\r\n-   因为 fun 是尽可能地认识到它是一个函数定义，所以最好在必要时用（）分割它。\r\n\r\n### 高阶函数\r\n\r\n定义一个函数作为参数\r\n\r\n```ocaml\r\n# let twice f x = f (f x);;\r\nval twice : ('a -> 'a) -> 'a -> 'a = <fun>\r\n# twice (fun x -> x * x) 3;;\r\n- : int = 81\r\n\r\n# let fourth x =\r\n    let square y = y * y in\r\n    twice square x;;\r\nval fourth : int -> int = <fun>\r\n# fourth 3;;\r\n- : int = 81\r\n```\r\n\r\n### 柯里化函数\r\n\r\n```ocaml\r\n# let concat_curry s1 = fun s2 -> s1 ^ s2 ^ s1;;\r\nval concat_curry : string -> string -> string = <fun>\r\n# concat_curry \"a\";;  (* 部分適用 *)\r\n- : string -> string = <fun>\r\n# (concat_curry \"a\") \"b\";;\r\n- : string = \"aba\"\r\n```\r\n\r\n### 柯里化语法糖\r\n\r\n一下这个定义\r\n\r\n```ocaml\r\nlet concat_curry s1 s2 = s1 ^ s2 ^ s1;;\r\n```\r\n\r\n与以下相同\r\n\r\n```ocaml\r\nlet concat_curry s1 = fun s2 -> s1 ^ s2 ^ s1;;\r\n```\r\n\r\n也就是说，当参数排序的时候，以下代码\r\n\r\n```ocaml\r\n# let fuga x y z = x + y + z;;\r\nval fuga : int -> int -> int -> int = <fun>\r\n```\r\n\r\n实际上可以展开为以下代码\r\n\r\n```ocaml\r\n# let hoge x = fun y -> fun z -> x + y + z;;\r\nval hoge : int -> int -> int -> int = <fun>\r\n```\r\n\r\n函数是左结合，所以可以扩展如下：\r\n\r\n```ocaml\r\nf x y z => (((f x) y) z)\r\n```\r\n\r\n函数类型构造函数是右结合的\r\n\r\n```ocaml\r\nint - > int - > int - > int = <fun>\r\n解释为\r\nint - >（int - >（int - > int））= <fun>\r\n```\r\n\r\n### 运算符定义\r\n\r\n#### 中缀运算符被定义为柯里化函数。\r\n\r\n```ocaml\r\n# (+);;\r\n- : int -> int -> int = <fun>\r\n# (+) 1 2;;\r\n- : int = 3\r\n```\r\n\r\n#### 自己定义操作符时\r\n\r\n#### 前缀运算符\r\n\r\n-   1、定义为一个参数函数\r\n\r\n#### 中缀运算符\r\n\r\n-   2、定义为参数（currying）函数\r\n-   请注意，可以用来定义运算符的字符类型是有限的。\r\n\r\n### 类型推断\r\n\r\n-   比较运算符（=等）可以使用多种类型，如整数类型和实数类型=>多态（多态）。\r\n-   具有多态性的类型系统被称为多态类型系统。\r\n\r\n#### 类型方案·参数多态性\r\n\r\n-   一种表示一种类型的外观模式的变量。\r\n-   它表示为'a 或'b。\r\n\r\n```ocaml\r\n# let twice f x = f (f x);;\r\nval twice : ('a -> 'a) -> 'a -> 'a = <fun>\r\n# let first (x, y) = x;;\r\nval first : 'a * 'b -> 'a = <fun>\r\n```\r\n\r\n#### 类型变量的泛化\r\n\r\n-   将类型变量（如'\\_a）（类型方案，如'a'）泛化的条件之一如下。\r\n-   如果定义右侧的表达式是一个值，则可以概括类型变量\r\n-   作为值处理的事物=>不需要计算的表达式\r\n-   作为一个例子\r\n-   函数声明\r\n-   常量\r\n-   需要计算的表达式不被视为值，因为它们是有价值的。\r\n\r\n```ocaml\r\n（*定义身份函数*）\r\n# let id x = x ;;\r\nval id：'a - >'a = <fun>\r\n\r\n（*'_a不是一个类型方案\r\n    因为id是一个值，一些实际的参数是必需的，计算是必要的。\r\n*）\r\n# let id'= id id ;;\r\nval id'：'_a - >'_a = <fun>\r\n\r\n（*\r\n    这种类型的方案\r\n    通过添加参数x，id'变成了函数定义。\r\n*）\r\n# let id'x = id id x ;;\r\nval id'：'a - >'a = <fun>\r\n```\r\n","source":"source\\_posts\\getting_started1.md"},{"title":"编程规则和约定","description":"编程规则和约定","created":"2018/07/05","author":"lanqy","link":"2018/07/05/erlang-programming-rules","htmlDir":"website\\2018\\07\\05\\erlang-programming-rules","htmlFile":"website\\2018\\07\\05\\erlang-programming-rules\\index.html","body":"# 编程规则和约定\r\n\r\n译自：http://www.erlang.se/doc/programming_rules.shtml\r\n\r\n## 使用 Erlang 进行程序开发 - 编程规则和约定\r\n\r\n### 抽象\r\n\r\n> 这是对编程规则的描述，并建议如何使用 Erlang 编写系统。\r\n\r\n注意：本文档是初步文档，不完整。\r\n\r\n#### 这里没有记录使用EBC“基础系统”的要求，但如果要使用“基础系统”，必须在非常早期的设计阶段遵循。这些要求记录在1/10268-AND 10406 Uen“MAP - 启动和错误恢复”中。\r\n\r\n### 1、目的\r\n\r\n本文列出了在使用 Erlang 指定和编程软件系统时应该考虑的一些方面。它并不试图给出与 Erlang 使用无关的一般规范和设计活动的完整描述。\r\n\r\n### 2、结构和 Erlang 术语\r\n\r\nErlang 系统分为*模块*。模块由*函数*和*属性*组成。函数要么只在模块内可见，要么被*导出*，即它们也可以被其他模块中的其他函数调用。属性以“ - ”开头，并放在模块的开头。\r\n\r\n使用 Erlang 设计的系统中的工作是由*进程*完成的。进程是一个可以在许多模块中使用函数的工作。进程通过发送消息相互通信。进程接收发送给它们的消息，进程可以决定它准备接收哪些消息。其他消息排队，直到接收进程准备接收它们。\r\n\r\n进程可以通过建立到它的链接来监督另一个进程的存在。当进程终止时，它会自动将退出信号发送到与其链接的进程。接收退出信号的进程的默认行为是终止并将信号传播到其链接进程。进程可以通过捕获出口来更改此默认行为，这会导致发送到进程的所有退出信号变为消息。\r\n\r\n纯函数是一个函数，它在给定相同参数的情况下返回相同的值，而不管函数调用的上下文如何。这是我们通常对数学函数的期望。也就是说不纯的功能有副作用。\r\n\r\n如果函数 a）发送消息 b）接收消息 c）调用 exit d）调用任何改变进程环境或操作模式的 BIF，通常会出现副作用（例如 get/1，put/2，erase/1，process_flag/2 等）。\r\n\r\n*警告*：本文档包含错误代码的示例。\r\n\r\n### 3、SW 工程原理\r\n\r\n#### 3.1 从模块导出尽可能少的函数\r\n\r\n模块是 Erlang 中的基本代码结构实体。模块可以包含大量函数，但只能从模块外部调用模块导出列表中包含的函数。\r\n\r\n从外部看，模块的复杂性取决于从模块导出的函数的数量。导出一个或两个函数的模块通常比导出许多函数的模块更容易理解。\r\n\r\n导出/非导出函数的比率较低的模块是可取的，因为模块的用户只需要了解从模块导出的函数的功能。\r\n\r\n此外，如果外部接口保持不变，模块中代码的编写者或维护者可以以任何适当的方式改变模块的内部结构。\r\n\r\n#### 3.2 尝试减少模块间依赖性\r\n\r\n与仅在几个不同模块中调用函数的模块相比，在许多不同模块中调用函数的模块将更难以维护。\r\n\r\n这是因为每次我们对模块接口进行更改时，我们都必须检查代码中调用此模块的所有位置。减少模块之间的相互依赖性简化了维护这些模块的问题。\r\n\r\n我们可以通过减少从给定模块调用的不同模块的数量来简化系统结构。\r\n\r\n还要注意，期望模块间调用依赖性形成树而不是循环图。例：\r\n![好](/images/module-dep-ok.gif)\r\n\r\n但不是\r\n\r\n![坏](/images/module-dep-bad.gif)\r\n\r\n#### 3.3 将常用代码放入库中\r\n\r\n应将常用代码放入库中。库应该是相关函数的集合。应该尽力确保库包含相同类型的函数。因此，诸如仅包含用于操纵列表的函数的列表的库是一个不错的选择，而包含用于操纵列表和用于数学的函数的组合的库，lists_and_maths 是非常糟糕的选择。\r\n\r\n最好的库函数没有副作用。具有副作用函数的库限制了可重用性。\r\n\r\n#### 3.4 将“棘手”或“脏”代码隔离到单独的模块中\r\n\r\n通常可以通过使用干净和脏代码的混合来解决问题。将干净和脏的代码分成单独的模块。\r\n\r\n脏代码是做坏事的代码。例：\r\n- 使用进程字典。\r\n- 使用 erlang:process_info/1 用于奇怪的目的。\r\n\r\n专注于尝试最大化干净代码的数量，并尽量减少脏代码的数量。隔离脏代码并清楚地评论或以其他方式记录与此部分代码相关的所有副作用和问题。\r\n\r\n#### 3.5 不要假设调用者将对函数的结果做什么\r\n\r\n不要假设函数被调用的原因或者函数的调用者希望对结果做什么。\r\n\r\n例如，假设我们使用某些可能无效的参数调用例程。例程的实现者不应该在参数无效时对函数的调用者希望发生什么做出任何假设。\r\n\r\n因此我们不应该写这样的代码\r\n\r\n```erlang\r\ndo_something(Args) ->\r\n    case check_args(Args) of\r\n        ok -> \r\n            {ok, do_it(Args)};\r\n        {error, What} ->\r\n            String = format_the_error(What),\r\n            io:format(\"* error:~s\\n\", [String]), %% 不要这样做\r\n            error\r\n    end.\r\n```\r\n\r\n而是这样写：\r\n\r\n```erlang\r\ndo_something(Args) ->\r\n    case check_args(Args) of\r\n        ok -> \r\n            {ok, do_it(Args)};\r\n        {error, What} ->\r\n            {error, What}\r\n    end.\r\n\r\nerror_report({error, What}) ->\r\n    format_the_error(What).\r\n```\r\n\r\n在前一种情况下，错误字符串始终打印在标准输出上，在后一种情况下，错误描述符将返回给应用程序。应用程序现在可以决定如何处理此错误描述符。\r\n\r\n通过调用 error_report/1，应用程序可以将错误描述符转换为可打印的字符串，并在需要时将其打印出来。但这可能不是理想的行为 - 在任何情况下，决定如何处理结果都留给调用者。\r\n\r\n#### 3.6 抽象出代码或行为的常见模式 \r\n\r\n每当在代码中的两个或多个位置具有相同的代码模式时，尝试将其与公共函数隔离并调用此函数，而不是将代码放在两个不同的位置。复制的代码需要很多维护。\r\n\r\n如果您在代码中的两个或多个位置看到类似的代码模式（即几乎相同），则值得花一些时间来查看是否有人不能稍微改变问题以使不同的情况相同，然后写入少量额外的 代码来描述两者之间的差异。\r\n\r\n避免“复制”和“粘贴”编程，使用函数！\r\n\r\n#### 3.7 自顶向下\r\n\r\n使用自上而下的方式编写程序，而不是自下而上（从详细信息开始）。自上而下是一种不断接近实现细节的好方法，最终定义了原始函数。代码将独立于表示，因为在设计更高级别的代码时不知道表示。\r\n\r\n#### 3.8 不要优化代码\r\n\r\n不要在第一阶段优化代码。首先让它正确，然后(如果必要)让它快速(同时保持正确)。\r\n\r\n#### 3.9 使用“最小惊讶”原则\r\n\r\n系统应始终以对用户造成“最小惊讶”的方式作出响应 - 即，用户应该能够预测当他们做某事时会发生什么并且不会对结果感到惊讶。\r\n\r\n这与一致性有关，这是一个一致的系统，其中不同的模块以类似的方式执行操作比每个模块以不同方式执行操作的系统更容易理解。\r\n\r\n如果你对函数的作用感到惊讶，你的函数可以解决错误的问题，也可能名字错误。\r\n\r\n#### 3.10 尽量消除副作用\r\n\r\nErlang 有几个具有副作用的原语。使用它们的函数不能轻易地重复使用，因为它们会导致对环境的永久性更改，并且在调用此类例程之前必须知道进程的确切状态。\r\n\r\n使用无副作用的代码尽可能多地编写代码。\r\n\r\n最大化纯函数的数量。\r\n\r\n收集具有副作用的功能并清楚地记录所有副作用。\r\n\r\n有点小心，大多数代码都可以以无副作用的方式编写 - 这将使系统更易于维护，测试和理解。\r\n\r\n#### 3.11 不允许私有数据结构“泄漏”出模块\r\n\r\n最好通过一个简单的例子来说明这一点。我们定义了一个名为 queue 的简单模块 - 来实现队列：\r\n\r\n```erlang\r\n-module(queue).\r\n-export([add/2, fetch/1]).\r\n\r\nadd(Item, Q) ->\r\n    lists:append(Q, [Item]).\r\n\r\nfetch(H|T) ->\r\n    {ok, H, T};\r\nfetch([]) -> \r\n    empty.\r\n```\r\n\r\n这将队列作为列表实现，遗憾的是，用户必须知道该队列被表示为列表。使用它的典型程序可能包含以下代码片段：\r\n\r\n```erlang\r\nNewQ = [], % 不要这样做\r\nQueue1 = queue:add(joe, NewQ), \r\nQueue2 = queue:add(mike, Queue1), ....\r\n```\r\n\r\n这很糟糕 - 因为用户a）需要知道队列被表示为列表而b）实现者不能改变队列的内部表示（他们可能希望稍后这样做以提供更好的模块版本） 。\r\n\r\n更好的是：\r\n\r\n```erlang\r\n-module(queue).\r\n-export([new/0, add/2, fetch/1]).\r\n\r\nnew() ->\r\n    [].\r\n\r\nadd(Item, Q) ->\r\n    lists:append(Q, [Item]).\r\n\r\nfetch([H|T]) ->\r\n    {ok, H, T};\r\nfetch([]) ->\r\n    empty.\r\n```\r\n\r\n现在我们可以写：\r\n\r\n```erlang\r\nNewQ = queue:new(), \r\nQueue1 = queue:add(joe, NewQ), \r\nQueue2 = queue:add(mike, Queue1), ...\r\n```\r\n\r\n哪个更好，并纠正这个问题。现在假设用户需要知道队列的长度，他们可能会想写：\r\n\r\n```erlang\r\nLen = length(Queue) % 不要这样做\r\n```\r\n\r\n因为他们知道队列被表示为列表。再次，这是糟糕的编程实践，导致代码很难维护和理解。如果需要知道队列的长度，则必须将长度函数添加到模块中，因此：\r\n\r\n```erlang\r\n-module(queue).\r\n-export([new/0, add/2, fetch/1, len/1]).\r\n\r\nnew() -> [].\r\n\r\nadd(Item, Q) ->\r\n    lists:append(Q, [Item]).\r\n\r\nfetch([H|T]) ->\r\n    {ok, H, T};\r\n\r\nfetch([]) ->\r\n    empty.\r\n\r\nlen(Q) ->\r\n    length(Q).\r\n```\r\n\r\n现在用户可以调用 queue:len(Queue) 代替。\r\n\r\n这里我们说我们“抽象出”队列的所有细节（队列实际上是所谓的“抽象数据类型”）。\r\n\r\n为什么我们会遇到这些麻烦？ - 抽象出实现的内部细节的做法允许我们改变实现而不改变调用我们已经改变的模块中的函数的模块的代码。因此，例如，更好的队列实现如下：\r\n\r\n```erlang\r\n-module(queue).\r\n-export([new/0, add/2, fetch/1, len/1]).\r\n\r\nnew() ->\r\n    {[], []}.\r\n\r\nadd(Item, {X, Y}) -> % 更快地添加元素\r\n    {[Item|X], Y}.\r\n\r\nfetch({X, [H|T]}) ->\r\n    {ok, H, {X, Y}}.\r\n\r\nfetch({[], []}) ->\r\n    empty;\r\n\r\nfetch({X, []}) ->\r\n    % 有时只执行这个繁重的计算。\r\n    fetch({[], lists:reverse(X)}).\r\n\r\nlen({X, Y}) ->\r\n    length(X) + length(Y).\r\n```\r\n\r\n#### 3.12 使代码尽可能具有确定性\r\n\r\n无论程序运行多少次，确定性程序总是以相同的方式运行。非确定性程序可能在每次运行时提供不同的结果。出于调试目的，最好使事物尽可能确定。这有助于使错误重现。\r\n\r\n例如，假设一个进程必须启动五个并行进程，然后检查它们是否已正确启动，进一步假设启动这五个进程的顺序无关紧要。\r\n\r\n然后，我们可以选择并行启动所有五个，然后检查它们是否已正确启动，但最好一次启动一个并检查每个启动是否正确，然后再启动下一个。\r\n\r\n#### 3.13 不要“防守”编程\r\n\r\n防御性程序是程序员不“信任”输入数据到他们正在编程的系统部分的程序。通常，不应将输入数据测试到函数的正确性。系统中的大多数代码都应该假设所讨论的函数的输入数据是正确的。只有一小部分代码应该实际执行任何数据检查。这通常是在数据第一次“进入”系统时完成的，一旦检查了数据，因为它进入系统后应该假定它是正确的。\r\n\r\n例：\r\n\r\n```erlang\r\n%% Args: Option is all|normal\r\nget_server_usage_info(Option, AsciiPid) ->\r\n    Pid = list_to_pid(AsciiPid),\r\n    case Option of\r\n        all -> get_all_info(Pid);\r\n        normal -> get_normal_info(Pid)\r\n    end.\r\n```\r\n\r\n如果 Option 既不正常也不是全部，该函数将崩溃，它应该这样做。呼叫者负责提供正确的输入。\r\n\r\n#### 3.14 使用设备驱动程序隔离硬件接口\r\n\r\n应通过使用设备驱动程序将硬件与系统隔离。设备驱动程序应该实现硬件接口，使硬件看起来像是 Erlang 进程。应该使硬件看起来和行为像普通的 Erlang 进程一样。硬件应该看起来接收和发送正常的 Erlang 消息，并且应该在发生错误时以传统方式响应。\r\n\r\n#### 3.15 在同一个函数中执行和撤消操作\r\n\r\n假设我们有一个程序打开一个文件，用它做一些事情并稍后关闭它。这应编码为：\r\n\r\n```erlang\r\ndo_something_with(File) ->\r\n    case file:open(File, read) of,\r\n        {ok, Stream} ->\r\n            doit(Stream),\r\n            file:close(Stream) % The correct solution\r\n        Error -> Error\r\n    end.\r\n```\r\n\r\n请注意在同一例程中打开文件（file:open）和关闭文件（file:close）的对称性。下面的解决方案更难以遵循，并且关闭哪个文件并不明显。不要这样编程：\r\n\r\n```erlang\r\ndo_something_with(File) -> \r\n  case file:open(File, read) of, \r\n    {ok, Stream} ->\r\n      doit(Stream)\r\n    Error -> Error\r\n  end.\r\n\r\ndoit(Stream) -> \r\n  ...., \r\n  func234(...,Stream,...).\r\n  ...\r\n\r\nfunc234(..., Stream, ...) ->\r\n  ...,\r\n  file:close(Stream) %% 不要这样做\r\n```\r\n\r\n### 4、错误处理\r\n\r\n#### 4.1 单独的错误处理和正常的案例代码\r\n\r\n不要使用设计用于处理异常的代码来填充“正常情况”的代码。你应该尽可能只编程正常情况。如果正常情况的代码失败，您的进程应该报告错误并尽快崩溃。不要尝试修复错误并继续。应该在不同的过程中处理错误（参见第15页的“每个过程应该只有一个”角色“）\r\n\r\n清除错误恢复代码和正常案例代码应大大简化整个系统设计。\r\n\r\n检测到软件或硬件错误时生成的错误日志将在稍后阶段用于诊断和更正错误。应保留对此过程有帮助的任何信息的永久记录。\r\n\r\n#### 4.2 识别错误内核\r\n\r\n系统设计的基本要素之一是确定系统的哪个部分必须是正确的，以及系统的哪个部分不必是正确的。\r\n\r\n在传统的操作系统设计中，假定系统的内核是并且必须是正确的，而所有用户应用程序不一定必须是正确的。如果用户应用程序失败，则仅涉及发生故障的应用程序，但不应影响整个系统的完整性。\r\n\r\n系统设计的第一部分必须是识别必须正确的系统部分;我们称之为错误内核。错误内核通常具有某种实时内存驻留数据库，用于存储硬件状态。\r\n\r\n### 5、进程，服务器和消息\r\n\r\n#### 5.1 在一个模块中实现进程\r\n\r\n实现单个进程的代码应包含在一个模块中。进程可以调用任何库例程中的函数，但进程的“顶部循环”的代码应该包含在单个模块中。进程顶部循环的代码不应分成几个模块 - 这将使控制流程极难理解。这并不意味着不应该使用通用服务器库，这些库用于帮助构建控制流。\r\n\r\n相反，应该在单个模块中实现不超过一种进程的代码。包含几个不同过程的代码的模块可能非常难以理解。应将每个单独流程的代码分解为单独的模块。\r\n\r\n#### 5.2 使用进程来构建系统\r\n\r\n进程是基本的系统结构元素。但是，当可以使用函数调用时，不要使用进程和消息传递。\r\n\r\n#### 5.3 注册进程\r\n\r\n注册的进程应使用与模块相同的名称进行注册。这样可以轻松找到进程的代码。只注册应该存在很长时间的进程。\r\n\r\n#### 5.4 为系统中的每个真正并发活动分配一个并行进程\r\n\r\n在决定是否使用顺序或并行进程实现事物时，应该使用问题的内在结构所隐含的结构。主要规则是： “使用一个并行进程来模拟现实世界中每个真正的并发活动”\r\n\r\n如果并行进程的数量与现实世界中真正并行活动的数量之间存在一对一的映射，则程序将易于理解。\r\n\r\n#### 5.5 每个进程应该只有一个“角色”\r\n\r\n进程可以在系统中具有不同的角色，例如在客户端 - 服务器模型中。\r\n\r\n进程应该尽可能只有一个角色，即它可以是客户端或服务器但不应该组合这些角色。\r\n\r\n进程可能具有的其他角色是：\r\n\r\n- 主管：监视其他进程并在失败时重新启动它们。\r\n- 工人：正常的工作进程（可能有错误）。\r\n- 值得信赖的工人：不允许有错误。\r\n\r\n#### 5.6 尽可能使用服务器和协议处理程序的通用函数\r\n\r\n在许多情况下，最好使用通用服务器程序，例如标准库中实现的 generic 服务器。一致使用一小组通用服务器将大大简化整个系统结构。\r\n\r\n对于系统中的大多数协议处理软件也是如此。\r\n\r\n#### 5.7 标记消息\r\n\r\n应标记所有消息。这使得 receive 语句中的顺序不那么重要，并且新消息的实现更容易。\r\n\r\n不要像这样编程：\r\n\r\n```erlang\r\nloop(State) ->\r\n    receive\r\n        ...\r\n        {Mod, Funcs, Args} -> % 不要这样做\r\n            apply(Mod, Funcs, Args),\r\n            loop(State);\r\n        ...\r\n    end.\r\n```\r\n\r\n如果将新消息 {get_status_info, From, Option} 置于 {Mod, Func, Args} 消息下方，则会引发冲突。\r\n\r\n如果消息是同步的，则返回消息应使用新原子标记，描述返回的消息。示例：如果传入消息标记为 get_status_info，则返回的消息可以标记为 status_info。选择不同标签的一个原因是使调试更容易。\r\n\r\n这是一个很好的解决方案：\r\n\r\n```erlang\r\nloop(State) ->\r\n    receive\r\n        ...\r\n        {execute, Mod, Funcs, Args} -> % 使用标记的消息。\r\n            apply(Mod, Funcs, Args),\r\n            loop(State);\r\n        {get_status_info, From, Option} ->\r\n            From ! {status_info, get_status_info(Option, State)},\r\n            loop(State);\r\n        ...\r\n    end.\r\n```\r\n\r\n#### 5.8 刷新未知消息\r\n\r\n每个服务器在至少一个 receive 语句中应该有一个 Other 选项。这是为了避免填充消息队列。例：\r\n\r\n```erlang\r\nmain_loop() ->\r\n    receive\r\n        {msg1, Msg1} ->\r\n            ...,\r\n            main_loop();\r\n        {msg2, Msg2} ->\r\n            ...\r\n            main_loop();\r\n        Other -> %刷新消息队列。\r\n            error_logger:error_msg(\r\n                \"Error: Process ~w got unknown msg ~w~n.\",\r\n                [self(), Other]),\r\n            main_loop()\r\n    end.\r\n```\r\n\r\n#### 5.9 编写尾递归服务器\r\n\r\n所有服务器必须是尾递归的，否则服务器将占用内存，直到系统用完为止。\r\n\r\n不要像这样编程：\r\n\r\n```erlang\r\nloop() ->\r\n    receive\r\n        {msg1, Msg1} ->\r\n            ...,\r\n            loop();\r\n        stop ->\r\n            true;\r\n        Other ->\r\n            error_logger:log({error, {process_got_other, self(), Other}}),\r\n            loop\r\n    end,\r\n    io:format(\"Server going down\"). % 不要这样做！\r\n                    % 这不是尾递归\r\n```\r\n\r\n这是一个正确的解决方案：\r\n\r\n```erlang\r\nloop() ->\r\n    receive\r\n        {msg1, Msg1} ->\r\n            ...\r\n            loop();\r\n        stop ->\r\n            io:format(\"Server going down\");\r\n        Other ->\r\n            error_logger:log({error, {process_got_other, self(), Other}}),\r\n            loop()\r\n    end. % 这是尾递归\r\n```\r\n\r\n如果您使用某种服务器库，例如 generic ，则会自动避免出现此错误。\r\n\r\n#### 5.10 接口函数\r\n\r\n尽可能使用接口函数，避免直接发送消息。封装传递到接口函数的消息。有些情况下你不能这样做。\r\n\r\n消息协议是内部信息，应该隐藏到其他模块。\r\n\r\n接口函数示例：\r\n\r\n```erlang\r\n-module(fileserver).\r\n-export([start/0, stop/0, open_file/1, ...]).\r\n\r\nopen_file(FileName) ->\r\n    fileserver ! {open_file_request, FileName},\r\n    receive\r\n        {open_file_response, Result} -> Result\r\n    end.\r\n\r\n...<code>...\r\n```\r\n\r\n#### 5.11 超时\r\n\r\n在 receive 语句中使用 after 要小心。确保在以后收到消息时处理该情况（请参见第 16 页的“刷新未知消息”）。\r\n\r\n#### 5.12 陷阱退出\r\n\r\n尽可能少的进程应该捕获退出信号。进程要么退出，要么不退出。对于进程来说，“切换”捕获出口通常是非常糟糕的做法。\r\n\r\n### 6、各种 Erlang 特定约定\r\n\r\n#### 6.1 使用记录作为主要数据结构\r\n\r\n使用记录作为主要数据结构。记录是标记的元组，并在 Erlang 版本 4.3 及其后引入（参见 EPK/NP 95:034）。它类似于 C 中的 struct 或 Pascal 中的 record。如果要在多个模块中使用该记录，则应将其定义放在模块中包含的头文件（带后缀.hrl）中。如果记录仅在一个模块中使用，则记录的定义应位于定义模块的文件的开头。\r\n\r\nErlang 的记录功能可用于确保数据结构的跨模块一致性，因此在模块之间传递数据结构时应由接口函数使用。\r\n\r\n#### 6.2 使用选择器和构造函数\r\n\r\n使用记录功能提供的选择器和构造函数来管理记录实例。不要使用明确假设记录是元组的匹配。例：\r\n\r\n```erlang\r\ndemo() ->\r\n    P = #person{name = \"Joe\", age = 29},\r\n    #person{name = Name1} = P, % 使用匹配，或......\r\n    Name2 = P#person.name. % 像这样使用选择器。\r\n```\r\n\r\n不要像这样编程：\r\n\r\n```erlang\r\ndemo() ->\r\n    P = #person{name = \"Joe\", age = 29},\r\n    {person, Name, _Age, _Phone, _Misc} = P. % 不要这样做\r\n```\r\n\r\n#### 6.3 使用标记的返回值\r\n\r\n使用标记的返回值。\r\n\r\n不要像这样编程：\r\n\r\n```erlang\r\nkeysearch(Key, [{Key, Value}|_Tail]) ->\r\n    Value; %% 不要返回未标记的值！\r\nkeysearch(Key, [{_WrongKey, _WrongValue} | Tail]) ->\r\n    keysearch(Key, Tail);\r\nKeysearch(Key, []) ->\r\n    false.\r\n```\r\n\r\n然后 {Key, Value} 不能包含 false 值。这是正确的解决方案：\r\n\r\n```erlang\r\nkeysearch(Key, [{Key, Value} | _Tail]) ->\r\n    {value, Value}; %% 正确。返回标记值。\r\nkeysearch(Key, [{_WrongKey, _WrongValue}, | Tail]) ->\r\n    keysearch(Key, Tail);\r\nkeysearch(Key, []) ->\r\n    false.\r\n```\r\n\r\n#### 6.4 小心使用捕获和抛异常\r\n\r\n除非你确切知道自己在做什么，否则不要使用 catch 和 throw！使用 catch 和 throw 尽可能少。\r\n\r\n当程序处理复杂且不可靠的输入（来自外部世界，而不是来自您自己的可靠程序）时，catch 和 throw 可能很有用，这可能会导致代码中很多地方出现错误。一个例子是编译器。\r\n\r\n#### 6.5 小心使用进程字典\r\n\r\n不要使用 get 和 put 等。除非你确切知道你在做什么！尽可能少地使用 get 和 put 等。\r\n\r\n可以通过引入新参数来重写使用进程字典的函数。\r\n\r\n例： 不要像这样编程：\r\n\r\n```erlang\r\ntokenize([H|T]) ->\r\n    ...\r\ntokenize([]) ->\r\n    case get_characters_from_device(get(device)) of % 不要使用 get/1！\r\n        eof -> [];\r\n        {value, Chars} ->\r\n            tokenize(Chars)\r\n    end.\r\n```\r\n\r\n正确的解决方案：\r\n\r\n```erlang\r\ntokenize(_Device, [H|T]) ->\r\n    ...;\r\ntokenize(Device, []) ->\r\n    case get_characters_from_device(Device) of % 这个更好\r\n        eof -> [];\r\n        {value, Chars} ->\r\n            tokenize(Device, Chars)\r\n    end.\r\n```\r\n\r\n他使用 get 和 put 会导致函数在不同的场合使用相同的输入调用时表现不同。这使得代码难以阅读，因为它是非确定性的。调试将更复杂，因为使用 get 和 put 的函数不仅是其参数的函数，还是进程字典的函数。Erlang 中的许多运行时错误（例如 bad_match ）包含函数的参数，但不包括进程字典。\r\n\r\n#### 6.6、不要使用导入\r\n\r\n不要使用 -import，使用它会使代码更难阅读，因为您无法直接查看函数定义的模块。使用 exref（交叉引用工具）查找模块依赖项。\r\n\r\n#### 6.7 导出函数\r\n\r\n区分函数的导出原因。可以导出函数，原因如下（例如）：\r\n\r\n- 它是模块的用户界面。\r\n- 它是其他模块的接口函数。\r\n- 它从 apply，spawn 等调用，但仅在其模块中调用。\r\n\r\n使用不同的 -export 分组并相应地注释它们。例：\r\n\r\n```erlang\r\n%% 用户界面\r\n-export([help/0, start/0, stop/0, info/1]).\r\n\r\n%% 模块间导入\r\n-export([make_pid/1, make_pid/3]).\r\n-export([process_abbrevs/0, print_info/5]).\r\n\r\n%% 导出仅在模块内使用\r\n-export([init/1, info_log_impl/1]).\r\n```\r\n\r\n### 7、具体的词汇和风格的约定。\r\n\r\n#### 7.1 不要编写深层嵌套代码\r\n\r\n嵌套代码是包含其他case / if / receive语句中的case / if / receive语句的代码。编写深层嵌套代码是一种糟糕的编程风格 - 代码倾向于在页面中向右移动并很快变得不可读。尝试将大多数代码限制为最多两个缩进级别。这可以通过将代码分成更短的函数来实现。\r\n\r\n#### 7.2 不要写非常大的模块\r\n\r\n模块不应包含超过 400 行的源代码。最好分成几个小模块而不是一个大模块。\r\n\r\n#### 7.3 不要写很长的函数\r\n\r\n不要编写超过 15 到 20 行代码的函数。将大函数分成几个较小的函数。不要通过写长行来解决问题。\r\n\r\n#### 7.4 不要写很长的行\r\n\r\n不要写很长的行。一行不应超过 80 个字符。 （例如，它将适合A4页面。）\r\n\r\n在 Erlang 4.3 及其后，字符串常量将自动连接。例：\r\n\r\n```erlang\r\nio:format(\"Name: ~s, Age: ~w,Phone: ~w ~n\"\r\n        \"Dictionary: ~w.~n\", [Name, Age, Phone, Dict])\r\n```\r\n\r\n#### 7.5 变量名称\r\n\r\n选择有意义的变量名称 - 这非常困难。\r\n\r\n如果变量名称由多个单词组成，请使用“_”或大写字母将它们分开。例如：My_variable 或 MyVariable。\r\n\r\n避免使用“_” 作为无关变量，使用以 “_”开头的变量。例如：_Name。如果您在稍后阶段需要变量的值，则只需删除前导下划线。您将无法找到替换下划线的问题，并且代码将更易于阅读。\r\n\r\n#### 7.6 函数名称\r\n\r\n函数名称必须与函数的名称完全一致。它应该返回函数名隐含的参数类型。它不应该让读者感到惊讶。使用传统函数的常规名称（start，stop，init，main_loop）。\r\n\r\n解决相同问题的不同模块中的函数应具有相同的名称。例如：Module:module_info()。\r\n\r\n错误的函数名称是最常见的编程错误之一 - 很好的选择名称是非常困难的！\r\n\r\n在编写许多不同的函数时，某种命名约定非常有用。例如，名称前缀“is_”可用于表示所讨论的函数返回原子 true 或 false\r\n\r\n```erlang\r\nif_...() -> true | false\r\ncheck_...() -> {ok, ...} || {error, ...}\r\n```\r\n\r\n#### 7.7 模块名称\r\n\r\nErlang 具有扁平模块结构（即模块内没有模块）。但是，我们通常希望模拟分层模块结构的效果。这可以通过具有相同模块前缀的多组相关模块来完成。\r\n\r\n例如，如果使用五个不同且相关的模块实现ISDN处理程序。这些模块的名称应如下：\r\n\r\n```erlang\r\nisdn_init\r\nisdn_partb\r\nisdn_...\r\n```\r\n\r\n#### 7.8 以一致的方式格式化程序\r\n\r\n一致的编程风格将帮助您和其他人理解您的代码。不同的人在缩进，使用空间等方面有不同的风格。例如，您可能希望在元素之间使用单个逗号编写元组：\r\n\r\n```erlang\r\n{12,23,45}\r\n```\r\n\r\n其他人可能会使用逗号后跟空格：\r\n\r\n```erlang\r\n{12, 23, 45}\r\n```\r\n\r\n一旦你采用了风格 - 坚持下去。\r\n\r\n在较大的项目中，应在所有部分使用相同的样式。\r\n\r\n### 8、文档化代码\r\n\r\n#### 8.1 属性代码\r\n\r\n您必须始终正确地归因于模块标头中的所有代码。说出所有有关该模块的想法来自哪里 - 如果您的代码是从其他代码派生出来的，那么说明您从哪里获得此代码以及谁编写代码。\r\n\r\n永远不要窃取代码 - 窃取代码是从其他模块编辑代码并忘记说谁编写原始代码。\r\n\r\n有用属性的示例如下：\r\n\r\n```erlang\r\n-revision('Revision: 1.14 ').\r\n-created('Date: 1995/01/01 11:21:11 ').\r\n-created_by('eklas@erlang').\r\n-modified('Date: 1995/01/05 13:04:07 ').\r\n-modified_by('mbj@erlang').\r\n```\r\n\r\n#### 8.2 在代码中提供参考规范\r\n\r\n在代码中提供与理解代码相关的任何文档的交叉引用。例如，如果代码实现某些通信协议或硬件接口，则将文档和页码的精确引用提供给用于编写代码的文档。\r\n\r\n#### 8.3 记录所有错误\r\n\r\n所有错误都应与单独文档中的含义的英文说明一起列出（请参阅第32页的“错误消息”。）\r\n\r\n错误是指系统检测到的错误。\r\n\r\n在程序中检测到逻辑错误的位置调用错误记录器：\r\n\r\n```erlang\r\nerror_logger:error_msg(Format, {Descriptor, Arg1, Arg2, ....})\r\n```\r\n\r\n并确保将 {Descriptor, Arg1, ...} 行添加到错误消息文档中。\r\n\r\n#### 8.4 记录消息中的所有主要数据结构\r\n\r\n在系统的不同部分之间发送消息时，使用标记的元组作为主要数据结构。\r\n\r\nErlang 的记录功能（在 Erlang 版本 4.3 s及其后版本中引入）可用于确保数据结构的跨模块一致性。\r\n\r\n应记录所有这些数据结构的英文描述（参见第32页的“消息描述”）。\r\n\r\n#### 8.5 注释\r\n\r\n注释应清晰简洁，避免不必要的冗长。确保注释与代码保持同步。检查注释是否增加了对代码的理解。注释应以英文撰写。\r\n\r\n关于模块的注释应该没有缩进，并以三个百分比的字符（%%%）开头，（参见第29页的“文件头，描述”）。\r\n\r\n关于函数的注释应该没有缩进，并以两个百分比字符（%%）开头，（参见第27页的“注释每个函数”）。\r\n\r\nErlang 代码中的注释应以一个百分比字符（%）开头。如果一行只包含注释，则它应缩进为 Erlang 代码。这种评论应放在它所引用的陈述之上。如果注释可以与语句放在同一行，则首选。\r\n\r\n```erlang\r\n%% Comment about function\r\nsome_useful_functions(UsefulArgugument) ->\r\n  another_functions(UsefulArgugument),    % Comment at end of line\r\n  % Comment about complicated_stmnt at the same level of indentation\r\n  complicated_stmnt,\r\n......\r\n```\r\n\r\n#### 8.6、注释每个函数\r\n\r\n要记录的重要事项是：\r\n\r\n- 函数的目的。\r\n- 函数的有效输入域。也就是说，函数参数的数据结构及其含义。\r\n- 函数输出的域。也就是说，返回值的所有可能数据结构及其含义。\r\n- 如果函数实现了复杂的算法，请对其进行描述。\r\n- 可能由exit / 1，throw / 1或任何非明显的运行时错误产生的故障和退出信号的可能原因。注意失败和返回错误之间的区别。\r\n- 函数的任何副作用。\r\n\r\n例如：\r\n\r\n```erlang\r\n%%----------------------------------------------------------------------\r\n%% 函数: get_server_statistics/2\r\n%% 目的: 从进程中获取各种信息.\r\n%% 参数:   Option is normal|all.\r\n%% 返回: 列表 {Key, Value} \r\n%%     or {error, Reason} (如果进程死掉)\r\n%%----------------------------------------------------------------------\r\nget_server_statistics(Option, Pid) when pid(Pid) ->\r\n```\r\n\r\n#### 8.7 数据结构\r\n\r\n记录应与计划文本描述一起定义。例：\r\n\r\n```erlang\r\n%% File: my_data_structures.h\r\n\r\n%%---------------------------------------------------------------------\r\n%% Data Type: person\r\n%% where:\r\n%%    name: A string (default is undefined).\r\n%%    age: An integer (default is undefined).\r\n%%    phone: A list of integers (default is []).\r\n%%    dict:     A dictionary containing various information about the person. \r\n%%       A {Key, Value} list (default is the empty list).\r\n%%----------------------------------------------------------------------\r\n-record(person, {name, age, phone = [], dict = []}).\r\n```\r\n\r\n#### 8.8 文件头，版权所有\r\n\r\n每个源代码文件必须以版权信息开头，例如：\r\n\r\n```erlang\r\n%%%--------------------------------------------------------------------- \r\n%%% Copyright Ericsson Telecom AB 1996\r\n%%%\r\n%%% All rights reserved. No part of this computer programs(s) may be \r\n%%% used, reproduced,stored in any retrieval system, or transmitted,\r\n%%% in any form or by any means, electronic, mechanical, photocopying,\r\n%%% recording, or otherwise without prior written permission of \r\n%%% Ericsson Telecom AB.\r\n%%%--------------------------------------------------------------------- \r\n```\r\n\r\n#### 8.9 文件头，修订历史\r\n\r\n每个源代码文件都必须记录其修订历史记录，该历史记录显示了谁在处理文件以及他们对文件做了什么。\r\n\r\n```erlang\r\n%%%--------------------------------------------------------------------- \r\n%%% Revision History\r\n%%%--------------------------------------------------------------------- \r\n%%% Rev PA1 Date 960230 Author Fred Bloggs (ETXXXXX)\r\n%%% Intitial pre release. Functions for adding and deleting foobars\r\n%%% are incomplete\r\n%%%--------------------------------------------------------------------- \r\n%%% Rev A Date 960230 Author Johanna Johansson (ETXYYY)\r\n%%% Added functions for adding and deleting foobars and changed \r\n%%% data structures of foobars to allow for the needs of the Baz\r\n%%% signalling system\r\n%%%--------------------------------------------------------------------- \r\n```\r\n\r\n#### 8.10 文件头，描述\r\n\r\n每个文件必须以文件中包含的模块的简短描述和所有导出函数的简要描述开头。\r\n\r\n```erlang\r\n%%%--------------------------------------------------------------------- \r\n%%% Description module foobar_data_manipulation\r\n%%%--------------------------------------------------------------------- \r\n%%% Foobars are the basic elements in the Baz signalling system. The\r\n%%% functions below are for manipulating that data of foobars and for\r\n%%% etc etc etc\r\n%%%--------------------------------------------------------------------- \r\n%%% Exports\r\n%%%--------------------------------------------------------------------- \r\n%%% create_foobar(Parent, Type)\r\n%%%   returns a new foobar object\r\n%%%   etc etc etc\r\n%%%--------------------------------------------------------------------- \r\n```\r\n\r\n*如果您知道任何弱点，错误，经过严格测试的函数，请在特别注释中记下它们，不要试图隐藏它们。如果模块的任何部分不完整，请添加特殊注释。* 添加有关对模块的未来维护者有帮助的任何内容的注释。如果您正在编写的模块的产品是成功的，那么在未来可能永远不会见到的人的十年内，它仍然可能会被更改和改进。\r\n\r\n#### 8.11 不要注释掉旧代码 - 删除它\r\n\r\n在修订历史记录中添加注释。请记住，源代码控制系统将帮助您！\r\n\r\n#### 8.12 使用源代码控制系统\r\n\r\n所有非平凡项目都必须使用源代码控制系统（如 RCS，CVS 或 Clearcase）来跟踪所有模块。\r\n\r\n### 9、最常见的错误：\r\n\r\n- 编写跨越多页的函数（请参阅第23页的“不要写很长的功能”）。\r\n- 使用深度嵌套的if、receive、case 等编写函数（请参见第23页的“不要编写深层嵌套代码”）。\r\n- 编写输入错误的函数（请参见第19页的“使用标记的返回值”）。\r\n- 函数名称不能反映函数的作用（参见第24页的“函数s名称”）。\r\n- 无意义的变量名称（请参见第23页的“变量名称”）。\r\n- 在不需要时处理进程（请参阅第14页的“为系统中的每个真正并发活动分配一个并行进程”）。\r\n- 选择错误的数据结构（错误表示）。\r\n- 糟糕的注释或根本没有注释（总是记录参数和返回值）。\r\n- 未缩进的代码。\r\n- 使用put / get（请参阅第20页的“小心使用进程字典”。）。\r\n- 无法控制消息队列（请参见第16页的“刷新未知消息”和第18页的“超时”）。\r\n\r\n### 所需文件\r\n\r\n本节描述了设计和维护使用Erlang编程的系统所必需的一些系统级文档。\r\n\r\n#### 10.1 模块描述\r\n\r\n每个模块一章。包含每个模块的描述，以及所有导出的函数，如下所示：\r\n\r\n- 函数参数的含义和数据结构\r\n- 返回值的含义和数据结构。\r\n- 函数的目的\r\n- 可能由于显式调用exit / 1而产生的失败和退出信号的可能原因。\r\n\r\n稍后定义的文档格式：\r\n\r\n#### 10.2 消息描述\r\n\r\n除一个模块内定义的消息之外的所有进程间消息的格式。\r\n\r\n稍后定义的文档格式：\r\n\r\n#### 10.3 进程\r\n\r\n系统中所有已注册服务器的描述及其接口和用途。\r\n\r\n动态进程及其接口的描述。\r\n\r\n稍后定义的文档格式：\r\n\r\n#### 10.4 错误消息\r\n\r\n错误消息的描述\r\n\r\n稍后定义的文档格式：\r\n","source":"source\\_posts\\erlang-programming-rules.md"},{"title":"在 ReasonReact 中创建全局状态","description":"在 ReasonReact 中创建全局状态","created":"2018/06/21","author":"lanqy","link":"2018/06/21/creating-global-state-in-reasonreact","htmlDir":"website\\2018\\06\\21\\creating-global-state-in-reasonreact","htmlFile":"website\\2018\\06\\21\\creating-global-state-in-reasonreact\\index.html","body":"# 在 ReasonReact 中创建全局状态\r\n\r\n译自：https://medium.com/@Hehk/creating-global-state-in-reasonreact-f84701c6ab6\r\n\r\n默认情况下，ReasonReact 为通过使用 Reducer 组件管理有状态组件提供了一个解决方案。Reducer 组件对于管理整个系统中的小部分状态非常好，但在更大的应用程序中遇到一些严重问题。具有更持久的全局状态，使用减速器体系结构并将状态提升到组件之外将提供两全其美。\r\n\r\n## 设置一个基本的 Reducer 组件\r\n\r\nReasonReact 减速器组件是管理 ReasonReact 应用程序中的状态的基本方式。他们通过建立一个 state ，一系列 actions 和一个 reducer 来实现。\r\n\r\n- state：组件的当前状态\r\n- action：一组可以修改状态的动作\r\n- reducer：一个函数，它需要一个动作和一个状态来计算一个新的状态。\r\n\r\n```ocaml\r\ntype state = {count: int};\r\n\r\n/* the actions */\r\ntype action = \r\n    | Increment\r\n    | Decrement;\r\n\r\nlet component = ReasonReact.reducerComponent(\"Counter\");\r\n\r\nlet make = (_children) => {\r\n    ...component,\r\n    /* the state */\r\n    initialState: () => {\r\n        count: 0\r\n    },\r\n\r\n    /* the reducer */\r\n\r\n    reducer: (action, state) => \r\n        switch action {\r\n            | Increment => ReasonReact.Update({count: state.count + 1})\r\n            | Decrement => ReasonReact.Update({count: state.count - 1})\r\n        },\r\n    render: ({state, send}) =>\r\n        <div>\r\n            <h1> (ReasonReact.string(string_of_int(state.count))) </h1>\r\n            <button onClick=((_e) => send(Increment))> (ReasonReact.string(\"+\")) </button>\r\n            <button onClick=((_e) => send(Decrement))> (ReasonReact.string(\"-\")) </button>\r\n        </div>\r\n}\r\n```\r\n\r\n这个组件是一个简单的计数器，它通过reducer组件体系结构进行变异。\r\n\r\n1. 用户点击“+”按钮，发送增量动作\r\n2. 减速器在动作和当前状态下被触发\r\n3. Reducer以新状态返回ReasonReact.Update\r\n\r\n就是这样，（除了背景布线）这个减速器组件是如何经历变异的。\r\n\r\n一个更复杂的例子是待办事项列表。\r\n\r\n```ocaml\r\ntype filter = \r\n    | Completed\r\n    | UnCompleted\r\n    | None;\r\n\r\ntype item = {\r\n    name: string,\r\n    completed: bool\r\n};\r\n\r\ntype state = {\r\n    input: string,\r\n    items: list(item),\r\n    filter\r\n};\r\n\r\nlet initialState = () => {\r\n    input: \"test\",\r\n    items: [{name: \"initial item\", completed: true}, {name: \"kewl item\", completed: false}],\r\n    filter: None\r\n}\r\n\r\ntype action = \r\n    | AddItem(item)\r\n    | RemoveItem(item)\r\n    | ChangeInput(string)\r\n    | ToggleItem(string)\r\n    | ChangeFilter(filter);\r\n    \r\nlet reducer = (action, state) =>\r\n    switch action {\r\n        | AddItem(item) => ReasonReact.Update({...state, items: [item, ...state.items], input: \"\"})\r\n        | RemoveItem(item) =>\r\n            ReasonReact.Update({...state, items: List.filter((elem: item) => elem.name != item.name, state.items)})\r\n        | ChangeInput(input) => ReasonReact.Update({...state, input})\r\n        | ToggleItem(name) => ReasonReact.Update({\r\n            ...state,\r\n            items: List.map((item) => name == item.name ? {...item, completed: !item.completed }: item, state.items)\r\n        })\r\n        | ChangeFilter(filter) => ReasonReact.Update({...state, filter})\r\n    };\r\n\r\nlet createItem = (~name, ()) => {name, completed: false};\r\n\r\nlet component = ReasonReact.reducerComponent(\"App\");\r\n\r\nlet make = (_children) => {\r\n    ...component,\r\n    render: ({state, send}) => \r\n        <div>\r\n            <input value=state.input onChange=((e) => send(ChangeInput(Obj.magic(e)##target##value))) />\r\n            <button onClick=((_e) => send(AddItem(createItem(~name=state.input, ()))))>\r\n                (ReasonReact.string(\"add\"))s\r\n            </button>\r\n        </div>\r\n}\r\n\r\n```\r\n\r\n虽然这个例子中有很多代码，但系统实际上相当简单。所有操作都是 actions，它们通过 reducer 映射到简单的状态更改。如果你感到困惑，我会建议你走进一个动作的生命周期，这些部分应该是有意义的。\r\n\r\n我强烈建议您阅读文档，他们会详细解释不同类型的更新以及与 reducer 组件交互的更有趣方式。https://reasonml.github.io/reason-react/docs/en/state-actions-reducer.html\r\n\r\n## 减速器组件的缺点\r\n\r\n上述示例的最大问题是状态本质上与组件绑定。例如，如果删除组件，则状态将丢失，如果丢失状态，组件将从其初始状态重新启动。在处理路由等问题时，这种短暂的状态成为一个巨大的问题，因为无法在URL更改之间维护您的状态。\r\n\r\n## 你怎么解决这个问题\r\n\r\n全局状态，通过将状态从这些短暂的组件中移出，我们可以创建一个可以轻松处理被删除和重新创建的应用程序。\r\n\r\n怎么样？简单，减速器组件！ ：P\r\n\r\n上面的体系结构可以通过创建处理状态的父组件向上移动到组件树中，并且仅向下传递我们获得两全其美所需的内容。减速器组件模型和状态与短暂组件分离。\r\n\r\n```ocaml\r\ntype element =\r\n  | Todo\r\n  | Counter;\r\n\r\n/* 将 state 合并为一个全球 state */\r\ntype state = {\r\n  todo: Todo.state,\r\n  counter: Counter.state,\r\n  activeElement: element\r\n};\r\n\r\n/* 将来自 todo 和 counter 的动作组合到全局动作包装器中 */\r\ntype action =\r\n  | Todo(Todo.action)\r\n  | Counter(Counter.action)\r\n  | ChangeElement(element);\r\n\r\nlet component = ReasonReact.reducerComponent(\"App\");\r\n\r\nlet make = (_children) => {\r\n  ...component,\r\n  /* 结合所有初始状态 */\r\n  initialState: () => {todo: Todo.initialState(), counter: Counter.initialState(), activeElement: Todo},\r\n  /* 让组件减速器处理状态部分 */\r\n  reducer: (action, state) =>\r\n    switch action {\r\n    | Todo(todoAction) => ReasonReact.Update({...state, todo: Todo.reducer(todoAction, state.todo)})\r\n    | Counter(counterAction) =>\r\n      ReasonReact.Update({...state, counter: Counter.reducer_2(counterAction, state.counter)})\r\n    | ChangeElement(element) => ReasonReact.Update({...state, activeElement: element})\r\n    },\r\n  render: ({state, send}) =>\r\n    <div>\r\n      <button onClick=((_e) => send(ChangeElement(Todo)))> (ReasonReact.stringToElement(\"todo\")) </button>\r\n      <button onClick=((_e) => send(ChangeElement(Counter)))> (ReasonReact.stringToElement(\"counter\")) </button>\r\n      <h1>(ReasonReact.stringToElement(\"Component\"))</h1>\r\n      (\r\n        /* 将一段状态传递给组件 */\r\n        switch state.activeElement {\r\n        | Todo => <Todo todoState=state.todo dispatch=((action) => send(Todo(action))) />\r\n        | Counter => <Counter counterState=state.counter dispatch=((action) => send(Counter(action))) />\r\n        }\r\n      )\r\n    </div>\r\n};\r\n```\r\n\r\n这确实需要对原始组件进行微小修改。\r\n\r\n```ocaml\r\ntype state = {count: int};\r\n\r\n/* 将初始状态移出组件 */\r\nlet initialState = () => {count: 0};\r\n\r\ntype action =\r\n  | Increment\r\n  | Decrement;\r\n\r\n/* 将 reducer 移出组件 */\r\nlet reducer = (action, state) =>\r\n  switch action {\r\n  | Increment => {count: state.count + 1}\r\n  | Decrement => {count: state.count - 1}\r\n  };\r\n\r\nlet component = ReasonReact.statelessComponent(\"Counter\");\r\n\r\nlet make = (~dispatch, ~counterState, _children) => {\r\n  ...component,\r\n  render: (_self) =>\r\n    <div>\r\n      <h1> (ReasonReact.stringToElement(string_of_int(counterState.count))) </h1>\r\n      /* 使用传入的调度函数而不是self.send */\r\n      <button onClick=((_e) => dispatch(Increment))> (ReasonReact.stringToElement(\"+\")) </button>\r\n      <button onClick=((_e) => dispatch(Decrement))> (ReasonReact.stringToElement(\"-\")) </button>\r\n    </div>\r\n};\r\n```\r\n如果你想看到 todo 组件，它在最后链接的源代码中，应用程序托管在http://hehk.github.io/example-reason-react-global-state\r\n\r\n正如您所看到的，这些更改非常小，我所做的只是创建一个具有子状态并集的父组件，并让它负责更新该新状态。我们也只是改变原始组件中的一些函数调用来使用新的调度函数，我们是金色的。\r\n\r\n![示例演示截图](/images/1__kAXzPNzq0y1fSyyOjOzOA.gif)\r\n\r\n管用!\r\n\r\n## 优点\r\n\r\n- 这将状态与组件分离，您实际上并不需要将 reducer 和初始状态放在同一模块中。它们可能完全不同，处理方式不同。例如，您可以创建一个包含状态，操作和缩减器的语言模块，但没有特定的语言组件，其状态只会传递给组件\r\n- 您现在可以通过删除和重新创建元素来持续存在\r\n\r\n## 这个方法有问题\r\n\r\n- 这个解决方案相当简单，可能会很快变得难看。\r\n- 您必须通过 props 将状态显式传递给组件。 **您可以在州周围创建一个 observable，并将所有子组件订阅为一种可能的解决方法。 **\r\n- 除了通用更新之外的任何更改都需要重写，目前只有子减速器返回状态。你可以让他们返回一个状态和更新类型的元组，但这也只是一个更多的样板。\r\n\r\n我希望在 Reason / OCaml 上有一个更好的人最终会推出一个优雅的解决方案来打破这个代码，但是，就目前而言，我认为这是一种创建全局状态的简单方法。\r\n\r\n## 关闭笔记\r\n\r\n感谢阅读，我是新来写博客文章，所以希望它并不可怕。我之所以写这篇文章，是因为我是工作范例的忠实粉丝，我找不到更有趣的状态管理。如果您认为有什么不对或可以更好地解释，请告诉我。\r\n\r\n如果您想了解有关使用 reducer 组件的更多信息，请访问https://reasonml.github.io/reason-react/docs/en/state-actions-reducer.html 查看文档。\r\n\r\n\r\n此帖子的所有代码均来自以下示例应用：https://github.com/Hehk/example-reason-react-global-state\r\n","source":"source\\_posts\\creating-global-state-in-reasonreact.md"},{"title":"ReasonML PPX","created":"2018/06/15","description":"ReasonML PPX","author":"lanqy","link":"2018/06/15/reasonml-ppx","htmlDir":"website\\2018\\06\\15\\reasonml-ppx","htmlFile":"website\\2018\\06\\15\\reasonml-ppx\\index.html","body":"# ReasonML PPX\r\n\r\n译自：https://blog.hackages.io/reasonml-ppx-8ecd663d5640\r\n\r\n自从我第一次见到 [Reason](https://reasonml.github.io/) 后，我看到了 “PPX” 这个词。我想知道 PPX 是什么，它做了什么以及如何构建 PPX 。我努力了一下收集方式和原因，所以我想和你分享我的经验。\r\n\r\n## 什么是 PPX\r\n\r\nPPX 重写器是一个接受序列化抽象语法树（AST）并输出另一个可能被修改的 AST 的程序。\r\n\r\n所以，PPX 的目标只是修改 AST ，例如，我们可以在这个 [Github](https://github.com/jaredly/ppx_autoserialize) 项目中看到，添加一个通用的方法：\r\n\r\n```ocaml\r\ntype myThing = {\r\n    something: int\r\n};\r\n\r\nlet myValue = {something: 10};\r\n/* 哦，神奇的 myThing__to_devtools 可用! */\r\n\r\nJs.log(myThing__to_devtools myValue);\r\n```\r\n\r\n你可以真正做到一个或多个 PPX 链接。他们非常强大。例如，您可以使用它将 Reason JSX 翻译成 ReactJS 能够理解的内容。这就是 reactjs_jsx_ppx 所做的。\r\n\r\n## 构建一个 PPX\r\n\r\n为了更好地理解 PPX 如何工作，我们来构建一个 PPX。我们将其称为 ppx_test，它会将 [%test] 转换为 42。\r\n\r\n## 配置 BuckleScript 构建\r\n\r\n您应该先配置 [BuckleScript](https://bucklescript.github.io/bucklescript/Manual.html#_first_example_by_hand_without_samples) 构建，方法是更新 bsconfig.json 并指定在构建过程中使用哪个 PPX ：\r\n\r\n```json\r\n{\r\n  \"name\" : \"build-a-ppx\",\r\n  \"ppx-flags\": [\"ppx_test/ppx\"],\r\n  \"sources\": \"src\"\r\n}\r\n```\r\n正如 bsconfig.json 的文档所述，您应该传递一个 package_name / binary 并且 BuckleScript 将在您的 node_modules 中查找它。所以，通过这个配置，我们应该在 node_modules / ppx_test / ppx 中有一个二进制 PPX。只需在你的 node_modules 中创建一个 ppx_test 目录。我们将在其中编写我们的 ppx_test.re 文件。\r\n\r\n## 写 PPX \r\n\r\nPPX 是类型为 Ast_mapper.mapper 的映射器。这个映射器类型只是一个包含 ParseTree 数据类型的很多映射器函数签名的记录。它看起来像这样：\r\n\r\n```ocaml\r\ntype mapper = {\r\n    attribute: mapper => Parsetree.attribute => Parsetree.attribute,\r\n    case: mapper => Parsetree.case => Parsetree.case,\r\n    cases: mapper => list Parsetree.case => list Parsetree.case,\r\n    /* 还有很多其他的mapper函数类型 */\r\n}\r\n```\r\n\r\nAst_mapper 模块已经为我们提供了一个默认映射器：\r\n\r\nAst_mapper.default_mapper（类型为 Ast_mapper.mapper ）。\r\n\r\n```ocaml\r\nlet Ast_mapper.default_mapper: Ast_mapper.mapper;\r\n```\r\n\r\n我们将继承这个默认的映射器来创建我们的 PPX ，并且只覆盖将 [%test] 转换为 42 所需的内容。\r\n\r\n```ocaml\r\n/* ppx_test.re */\r\nopen Asttypes;\r\nopen Parsetree;\r\nopen Ast_mapper;\r\n\r\nlet test_mapper  argv => {\r\n    ...default_mapper, /* 我们扩展了 default_mapper */\r\n    /* 并覆盖 'expr' 属性 */\r\n    expr: fun mapper expr => \r\n    /* 如果表达式是 [%测试] */\r\n\r\n    switch expr {\r\n        | {pexp_desc: Pexp_extension {text: \"test\"} (PStr []) [@implicit_arity]} =>\r\n        /* 然后换成 42 */\r\n            Ast_helper.Exp.constant (Const_int 42)\r\n        | other => default_mapper.expr mapper other\r\n    }\r\n};\r\n\r\nlet () = register \"ppx_test\" test_mapper;\r\n\r\n```\r\n\r\n我们扩展 default_mapper 并覆盖 'expr'属性。如果参数中给出的表达式匹配 [%test] ，则返回 42 .否则，返回 default_mapper 实现。\r\n\r\n## 构建 PPX\r\n\r\nBuckleScript 需要一个二进制文件：node_modules / packages_name / binary_file。在我们的例子中：node_modules / ppx_test / ppx。\r\n\r\n关于 ReasonML 编译如何在这里有一个很好的介绍。让我们看看我们如何在二进制文件中逐步构建我们的 .re 文件：\r\n\r\n```ocaml\r\n// 1. 构建 OCaml 文件\r\n\r\nocamlc -o outputfile yourOcamlFile.ml\r\n\r\n/*\r\n2. 构建 ReasonML 文件\r\n\r\n如果你想构建 ReasonML 文件，你需要通过带有 pp 标志的预处理器来传递它。\r\nrefmt 是 Reason reformat（它随 [reason-cli](https://github.com/reasonml/reason-cli) 提供）。在这种情况下，它将打印ReasonML文件的二进制文件。-impl 告诉编译器 .re 应该被认为是一个普通的 .ml（ OCaml 文件）\r\n*/\r\nocamlc -pp \"refmt --print binary\" -o outputFile -impl yourReasonFile.re\r\n\r\n/*\r\n3.使通用模块可用 我们需要 OCaml Common 模块。 -I 搜索依赖关系，'+' 使其相对于 OCaml 目录\r\n*/\r\n\r\nocamlc -pp \"refmt --print binary\" -o ppx -I +compiler-libs ocamlcommon.cma -impl ppx_test.re\r\n\r\n```\r\n\r\n用最后一条命令，我们生成我们的 ppx 二进制文件。所以我们现在有了 node_modules / ppx_test / ppx\r\n\r\n## 使用魔法\r\n\r\n```ocaml\r\nrender: fun _ => {\r\n    <div>\r\n        (ReasonReact.stringToElement (string_of_int [%test]))\r\n    </div>\r\n}\r\n```\r\n\r\n我们拥有它。当我们用 bsb -make-world 运行我们的项目时。 BuckleScript 将读取 bsconfig.json 中的构建配置，然后通过在我们的 node_modules 中查找来注册我们的 PPX。\r\n\r\n> 您可以在我们的网站上找到更多关于 Hackages 的信息。我们是一家社区驱动的公司，提供围绕 JavaScript 的最新框架和技术的高级培训。我们也乐于[贡献开源资源](https://github.com/hackages)，并组织全欧各地的免费社区活动！通过https://hackages.io 查看我们即将举办的活动。","source":"source\\_posts\\reasonml-ppx.md"},{"title":"ReasonML：为 NPM 包创建绑定","created":"2018/06/15","description":"ReasonML：为 NPM 包创建绑定","author":"lanqy","link":"2018/06/15/reasonml-create-bindings-for-npm-package","htmlDir":"website\\2018\\06\\15\\reasonml-create-bindings-for-npm-package","htmlFile":"website\\2018\\06\\15\\reasonml-create-bindings-for-npm-package\\index.html","body":"# ReasonML：为 NPM 包创建绑定\r\n\r\n译自：https://medium.com/@DmytroGladkyi/reasonml-create-bindings-for-npm-package-b8a3c6d0703e\r\n\r\nReasonML 正在上升。最新的 https://www.reason-conf.com/ 表明，很多人都对 Facebook 这种语言感兴趣。您可以非常容易地将 ReasonML 添加到现有的 JavaScript / TypeScript 项目中，并获得强类型语言的全部好处，但很多库都是用 JS 编写的，并发布到 NPM 。要从 ReasonML 使用它们，您必须提供绑定到包。为不同的库创建了很多绑定，例如：[MomentJS 的绑定](https://github.com/reasonml-community/bs-moment)。\r\n\r\n在这篇文章中，我将向您展示如何从头开始创建绑定，以及如何在您的 ReasonML 项目中使用它们：\r\n\r\n```ocaml\r\n[@bs.module \"semver\"] [@bs.val]\r\nexternal clean : string => Js.nullable(string) = \"clean\";\r\n\r\nlet clean = a => clean(a) |> Js.Nuellable.toOption;\r\n\r\n/***** COMPARISON START *****/\r\n[@bs.module \"semver\"] [@bs.val] external gt : (string, string,) => bool = \"gt\";\r\n\r\nlet gt = (a, b) => gt(a, b);\r\n[@bs.module \"semver\"] [@bs.val]\r\nexternal gte : (string, string) => bool = \"gte\";\r\n\r\n```\r\n\r\n## 入门\r\n\r\nReasonML 提供了一个从 ReasonML 到 JavaScript 世界的非常薄的绑定层。官方的 BuckleScript 文档是一个很好的起点。\r\n\r\n我们将为 NPM 官方的 semver 软件包编写绑定。\r\n\r\n这个包暴露了不同的函数，我们也可以实例化 Semver 类，就像在这个 JavaScript 例子中一样：\r\n\r\n```ocaml\r\nconst semver = require('semver')\r\nsemver.valid('1.2.3') // '1.2.3'\r\nsemver.valid('a.b.c') // null\r\nsemver.clean('  =v1.2.3   ') // '1.2.3'\r\nsemver.satisfies('1.2.3', '1.x || >=2.5.0 || 5.0.0 - 7.2.3') // true\r\n```\r\n\r\n#### 创建新的 NPM 包\r\n\r\n运行命令\r\n\r\n```ocaml\r\nnpm init\r\n```\r\n\r\n这将启动一个向导，创建一个新的 NPM 包。提供你想要的任何信息，只要给它一个带有前缀 'bs'（ BuckleScript ）的好名字。 `bs`是 BuckleScript 或 ReasonML 绑定的社区约定。\r\n\r\n创建一个文件夹 'src'：\r\n\r\n```ocaml\r\nmkdir src\r\n```\r\n\r\n它将包含我们绑定的所有源文件。\r\n\r\n创建一个文件夹'__tests__'：\r\n\r\n```ocaml\r\nmkdir __tests__\r\n```\r\n\r\n它将包含由 [bs-jest 库](https://github.com/glennsl/bs-jest) 执行的绑定测试。\r\n\r\n#### 添加 bsconfig.json\r\n\r\n为了使我们的包与 ReasonML 编译器一起工作，我们必须添加一个 bsconfig.json。\r\n\r\n```ocaml\r\n{\r\n  \"name\": \"@gladimdim/bs-semver\",\r\n  \"version\": \"0.2.0\",\r\n    \"sources\": [\r\n\t{\r\n\t    \"dir\" : \"src\",\r\n\t    \"subdirs\" : true\r\n\t},\r\n\t{\r\n\t    \"dir\": \"__tests__\",\r\n\t    \"type\": \"dev\"\r\n\t}\r\n    ],\r\n  \"package-specs\": {\r\n    \"module\": \"commonjs\",\r\n    \"in-source\": true\r\n  },\r\n  \"suffix\": \".bs.js\",\r\n  \"bs-dependencies\": [\r\n  ],\r\n    \"bs-dev-dependencies\": [\"@glennsl/bs-jest\"],\r\n  \"warnings\": {\r\n    \"error\" : \"+101\"\r\n  },\r\n  \"refmt\": 3\r\n}\r\n```\r\n\r\n最重要的导入属性：\r\n\r\n```ocaml\r\nname: '@gladimdim/bs-semver'\r\n```\r\n\r\n必须与 package.json 中的完全相同。\r\n\r\n```ocaml\r\nsources: [...src....__tests__....]\r\n```\r\n\r\n指定要编译为 JavaScript 代码的文件夹。测试文件夹的类型为 “`dev`”，所以它不会出现在建议中，也不会被编译进软件包中。\r\n\r\n#### 编辑 package.json\r\n\r\n现在打开package.json，我们必须为它添加一些绑定特定的属性\r\n\r\n```ocaml\r\n\"script\": {\r\n    \"clean\": \"bsb -clean-world\",\r\n    \"build\": \"bsb -make-world\",\r\n    \"watch\": \"bsb -make-world -w\",\r\n    \"test\": \"jest\"\r\n},\r\n```\r\n\r\n这些是脚本，用于构建，编译，测试和运行监视器。\r\n\r\n提供 dev 依赖：\r\n\r\n```ocaml\r\n\"devDependencies\": { \r\n  \"bs-platform\": \"^3.0.0\",  \r\n  \"jest\": \"22.1.2\", \r\n  \"@glennsl/bs-jest\": \"0.3.2\" \r\n},\r\n```\r\n\r\n请注意，您必须提供像 'jest' 这样的'真正' JavaScript NPM 包装代码，因为它们包含真实代码，在测试或编译任务期间，这些代码将被来自 'bs-jest' 的绑定使用。\r\n\r\n现在告诉 NPM 包含哪些文件：\r\n\r\n```ocaml\r\n\"files\": [\r\n    \"src/semver.re\",\r\n    \"bsconfig.json\"\r\n]\r\n```\r\n\r\n这是应该发布给 NPM 注册管理机构的内容。包含 bsconfig.json 非常重要，因为它已被最终用户的构建过程所使用。\r\n\r\n#### 指定目标NPM软件包的 Peer Dependencies\r\n\r\n当我们为 semver 包创建绑定时，我们必须告诉 NPM 使其成为对等关系。我们软件包的最终用户将不得不为我们提供这种对等关系。\r\n\r\n```ocaml\r\n\"peerDependencies\": {    \"semver\": \"^5.5.0\"  },\r\n```\r\n\r\n## 如何编写绑定\r\n\r\n在 src 文件夹中，创建一个名为 semver.re 的文件。这将是我们的主要和唯一的绑定文件。\r\n\r\n让我们为函数 'clean' 编写绑定，它作为 semver 包中的独立函数公开。\r\n\r\n在我们编写 `clean` 函数的主体之前，我们需要深入到可怕的JS世界：\r\n\r\n***您必须始终在运行时检查这些函数在实际中返回什么***。\r\n\r\n每个 npm 软件包页面都有一个 “Test With RunKit” 按钮，您可以在不安装软件包的情况下使用它来调用函数：\r\n\r\n![1_j4hBNwdBskluPQKGKLPKUA.png](/images/1_j4hBNwdBskluPQKGKLPKUA.png)\r\n\r\n函数 'clean' 的问题如下：它可能会返回一个有效的 semver 字符串;如果无法解析输入的 semver 版本，则返回 null。所以，从 ReasonML 的角度来看，这个函数的结果是一个 Option。它要么返回字符串，要么无返回（ None ）。\r\n\r\n我们使用指令 @bs.module 和 @bs.val 来指示下一个函数没有 ReasonML 主体。相反，它将从 JavaScript 世界中获取。欲了解更多信息，请阅读官方文档：\r\n\r\nhttps://bucklescript.github.io/docs/en/intro-to-external.html\r\n\r\n```ocaml\r\n[@bs.module \"semver\"] [@bs.val]\r\nexternal clean : string => Js.nullable(string) = \"clean\";\r\nlet clean = a => clean(a) |> Js.Nullable.toOption;\r\n```\r\n\r\n第二行中的类型签名意味着以下内容：函数 'clean' 接受一个字符串作为输入参数并输出一个字符串或 null。指令 @bs.module “semver” 和 “clean” 将把它转换成 JavaScript：\r\n\r\n```ocaml\r\nsemver.clean()\r\n```\r\n\r\n我们可以保持原样，但我们希望使这个函数的返回类型更具有 ReasonML -规范，并使用 Option 类型。这就是为什么在＃3 行我们有这个函数的主体。它以下面的方式读取：函数 'clean' 将参数 a，发送到 'clean'（来自 semver 包的 JavaScript 函数），然后将结果传送到 toOption 转换器。\r\n\r\nReasonML 将继承“ external clean ”声明中的类型定义，因此您不必重复它们。\r\n\r\n我们的 ReasonML 函数 'clean' 的输出将是一个 String 类型的 Option 。\r\n\r\n我们来写一下绑定测试。使用以下内容在`__tests__`文件夹中创建一个文件 semver_spec.re：\r\n\r\n```ocaml\r\nopen Jest;\r\n\r\nlet () = \r\n    describe(\r\n        \"semver\",\r\n        ExpectJs.(\r\n            () => {\r\n                test(\"#clean\", () =>\r\n                    expect(\r\n                        Semver.clean(\"  =1.5.0   \")\r\n                        |> (\r\n                            result =>\r\n                                switch (result) {\r\n                                | Some(v) => v\r\n                                | None => raise(Not_found)\r\n                                }\r\n                        ),\r\n                    )\r\n                    |> toBe(\"1.5.0\")\r\n                );\r\n            }\r\n        ),\r\n    );\r\n\r\n```\r\n\r\nsemver 模块将从我们的 semver.re 文件中自动加载。请记住，我们不测试 Semver 功能，我们测试绑定。\r\n\r\n所以我们只需要验证一下，我们的绑定返回的是可选类型，结果是字符串。\r\n\r\n我们可以继续覆盖从官方文档到 semver 的其他简单方法：https://github.com/npm/node-semver\r\n\r\n## 如何为 'string' 枚举创建类型\r\n\r\n函数 semver.cmp(a, c, b) 接受3个参数：第一个版本，操作（字符串），第二个版本。\r\n\r\n绑定到它看起来像这样：\r\n\r\n```ocaml\r\n[@bs.module \"semver\"] [@bs.val]\r\nexternal cmp : (string, string, string) => bool = \"cmp\";\r\n```\r\n\r\n但是，名为“操作”的第二个参数可以是仅来自特定“操作”集的字符串。例如：“<，>，≤，≥，==，！==”等等。\r\n\r\nReasonML 中的用法如下所示：\r\n\r\n```ocaml\r\nSemver.cmp(\"1.5.0\", \"<\", \"2.3.5\");\r\n```\r\n\r\n通过定义第二个参数“<”，作为一个字符串，它使我们有可能犯下以下错误：\r\n\r\n```ocaml\r\nSemver.cmp(\"1.5.0\", \"hello\", \"2.3.5\");\r\n```\r\n\r\n我们可以把它作为一个字符串类型，但是在 ReasonML 中，我总是喜欢为这些重要的参数设置类型。\r\n\r\n我们必须引入一个只对'cmp'方法字符串有效的类型：\r\n\r\n```ocaml\r\ntype comparator = \r\n    | LooseEqual \r\n    | LooseNotEqual \r\n    | Equal \r\n    | Empty \r\n    | NotEqual\r\n    | Gt\r\n    | Gte\r\n    | Lt\r\n    | Lte;\r\n```\r\n\r\n编写一个将这些类型转换为字符串的函数，因为JavaScript需要一个字符串作为输入：\r\n\r\n```ocaml\r\nlet comparatorToString = comparator : string =>\r\n    switch (comparator) {\r\n        | LooseEqual => \"==\"\r\n        | LooseNotEqual => \"!==\"\r\n        | Equal => \"===\"\r\n        | Empty => \"\"\r\n        | NotEqual => \"!==\"\r\n        | Gt => \">\"\r\n        | Gte => \">=\"\r\n        | Lt => \"<\"\r\n        | Lte => \"<=\"\r\n    };\r\n```\r\n\r\n现在，增强我们的绑定：\r\n\r\n```ocaml\r\n[@bs.module \"semver\"] [@bs.val]\r\nexternal cmp : (string, string, string) => bool = \"cmp\";\r\n\r\nlet cmp = (a: string, c: comparator, b: string) =>\r\n    cmp(a, c |> comparatorToString, b);\r\n```\r\n\r\n这个 ReasonML 代码将返回一个编译错误：\r\n\r\n```ocaml\r\nSemver.cmp(\"1.5.0\", \"hello\", \"2.3.0\");\r\n```\r\n\r\n我们必须重用提供的类型 Semver.Gt  ：\r\n\r\n```ocaml\r\nSemver.cmp(\"1.5.0\", Semver.Gt, \"2.3.0\");\r\n```\r\n\r\n该绑定将将  Semver.Gt  转换为 “>” 并将其发送到外部“真实” JavaScript 函数。\r\n\r\n## 为 Semver 类创建类型\r\n\r\nSemver 包还提供了一个实例化 Semver 类的可能性：\r\n\r\n```ocaml\r\nconst s = new semver(\"1.5.0\");\r\ns.minor(); // 5\r\n```\r\n\r\n我们可以在 ReasonML 中定义一个类类型来覆盖所有的 'semver' 对象属性：\r\n\r\n```ocaml\r\nclass type semverInstance = \r\n    [@bs]\r\n    {\r\n        pub inc: tRelease => semverInstance;\r\n        pub version: string;\r\n        pub major: int;\r\n        pub minor: int;\r\n        pub patch: int;\r\n        pub raw: string;\r\n        pub build: array(string);\r\n        pub prerelease: array(string)\r\n    };\r\n```\r\n\r\n然后，我们添加 'createSemver' 函数，这将帮助我们使所有类型安全：\r\n\r\n```ocaml\r\ntype tSemver = Js.t(semverInstance);\r\n\r\n[@bs.new] [@bs.module] external createSemver : string => tSemver = \"semver\";\r\n```\r\n\r\n用法：\r\n\r\n```ocaml\r\nlet a = Semver.createSemver(\"1.5.0\");\r\nJs.log(a##minor); // 5\r\n```\r\n\r\n## 总结\r\n\r\n我希望这篇文章能够帮助你为其他软件包创建自己的类型。有很多很好的绑定 https://github.com/reasonml-community/bs-moment， https://github.com/glennsl/bs-jest 您可以查看它们的源代码，以获取关于如何编写绑定的更多见解。这实际上是我就是这么做的:-)\r\n\r\n## ReasonML 周报\r\n\r\n要获取有关ReasonML的最新消息，您可以按照我们的 twitter：https://twitter.com/@WeeklyReason 并订阅我们的每周新闻简报：https://news.reasonml.online。\r\n\r\nGitHub repo bs-semver 绑定： https://github.com/gladimdim/bs-semver\r\n","source":"source\\_posts\\reasonml-create-bindings-for-npm-package.md"},{"title":"如何将 BuckleScript / ReasonML 对象绑定到 JavaScript 对象","description":"如何将 BuckleScript / ReasonML 对象绑定到 JavaScript 对象","created":"2018/06/15","author":"lanqy","link":"2018/06/15/how-to-bind-bucklescript-reasonml-objects-to-javascript-objects","htmlDir":"website\\2018\\06\\15\\how-to-bind-bucklescript-reasonml-objects-to-javascript-objects","htmlFile":"website\\2018\\06\\15\\how-to-bind-bucklescript-reasonml-objects-to-javascript-objects\\index.html","body":"\r\n# 如何将 BuckleScript / ReasonML 对象绑定到 JavaScript 对象。\r\n\r\n> 注1：当我在本文中说 BuckleScript 时，我指的是 OCaml。\r\n> 注2：JavaScript对象与 BuckleScript / ReasonML中的 Object 不同。\r\n\r\n尽管它们本身支持面向对象的风格，但 BuckleScript / ReasonML 是函数式语言，这意味着它们不鼓励使用类的概念。相反，要在 BuckleScript / ReasonML 中创建 JavaScript 对象，可以使用 Js.Dict 或 Record 类型。当需要可变数量的 keys 时，应使用前者。后者用于键被固定并且其类型被预先确定的情况。\r\n\r\n## 使用 Js.Dict 创建一个对象\r\n\r\n\r\n```ocaml\r\nlet myDict = Js.Dict.empty ()\r\nlet _ Js.Dict.set myDict \"myKey1\" 100\r\nlet _ Js.Dict.set myDict \"myKey2\" 200\r\n\r\nlet myDict2 = Js.Dict.empty ()\r\nlet _ Js.Dict.set myDict2 \"myKey1\" 100\r\nlet _ Js.Dict.set myDict2 \"myKey2\" \"hello\" (* 错误，值必须是相同的类型 *)\r\n```\r\n\\*用 BuckleScript Js.Dict 创建 JavaScript 对象\\*\r\n\r\n```ocaml\r\nlet myDict = Js.Dict.empty();\r\nJs.Dict.set(myDict, \"myKey1\", 100);\r\nJs.Dict.set(myDict, \"myKey2\", 200);\r\n\r\nlet myDict2 = Js.Dict.empty();\r\nJs.Dict.set(myDict2, \"myKey1\", 100);\r\nJs.Dict.set(myDict2, \"myKey2\", \"hello\"); /* 错误，值必须是相同的类型 */\r\n\r\n```\r\n\r\n\\* 上面代码片段的 ReasonML 对应部分。\\*\r\n\r\nJs.Dict 是一个 JavaScript 字典，我们可以将任何值作为值，但是，强类型系统要求其值必须是相同的类型。我们创建的字典将直接转换为普通的 JavaScript 对象。\r\n\r\n如果我们想要在 Js.Dict 中存储多个类型的值，我们可以使用嵌套的 Js.Dict 结构或变体类型来实现。这看起来可能很麻烦，但这是对型号安全的一种折衷。\r\n\r\n现在，让我们看看如何在 Js.Dict 中存储变量类型的值。\r\n\r\n```ocaml\r\ntype myVariantType = \r\n    | Nothing\r\n    | Something of int\r\n    | LotOfThing of int array\r\n    [@@bs.deriving accessors]\r\n\r\nlet myDict = Js.Dict.empty ()\r\nlet _ = Js.Dict.set myDict \"foo\" Nothing\r\nlet _ = Js.Dict.set myDict \"bar\" ((Something (1)))\r\nlet _ = Js.Dict.set myDict \"foobar\" ((LotOfThing ([|1;2;3|])))\r\n```\r\n\\* 代码片段显示了如何在Dictionary对象中存储变体类型 \\*\r\n\r\n```ocaml\r\n[@bs.deriving accessors]\r\ntype myVariantType = \r\n    | Nothing\r\n    | Something(int)\r\n    | LotOfThing(array(int));\r\n\r\nlet myDict = Js.Dict.empty();\r\nJs.Dict.set(myDict, \"foo\", Nothing);\r\nJs.Dict.set(myDict, \"bar\", Something(1));\r\nJs.Dict.set(myDict, \"foobar\", LotOfThing([|1,2,3|]));\r\n```\r\n\\* 上述代码片段的ReasonML对象 \\*\r\n\r\nVariant 类型的值不会按原样存储在 JavaScript 对象中，但它们会被转换并转换为普通的 JavaScript 对象，如下所示：\r\n\r\n```ocaml\r\nvar myDict = { };\r\n\r\nmyDict[\"foo\"] = /* Nothing */0;\r\nmyDict[\"bar\"] = /* Something */Block.__(0, [1]);\r\nmyDict[\"foobar\"] = /* LotOfThing */Block.__(1, [/* array */[\r\n      1,\r\n      2,\r\n      3\r\n    ]]);\r\n```\r\n\r\n`Nothing` 变成 `0`, `Something` 变成 `Block.__(0, [1]);` 和 `LotOfThing` 变成 `Blocks.__(1, [[1,2,3]]);`\r\n\r\n这意味着我们在运行时不会有 Variant 类型的值。通过不查看注释来运行代码，我们无法取回 Variant 的名称。这就是注解 `accessors` 在那里的原因。它将根据每种变体类型绑定变量，以便我们可以自然地在 JavaScript 中使用 Variant，例如 `myDict[\"foo\"] = nothing;` 代替 `myDict[\"foo\"] = /* Nothing */0;`\r\n\r\n## 使用 Record 创建一个对象\r\n\r\n虽然我们使用 Js.Dict 来存储相同类型的键和值（称为字段），并且它可能具有可变数量的字段。[一个对象可以被定义为一个记录](https://bucklescript.github.io/docs/en/object.html#object-as-record)\r\n\r\n- 具有已知数量的字段\r\n- 可能包含或可能不包含异构类型的值\r\n\r\n与 Variant 略有不同，可以使用 type 关键字使用[以下语法](https://realworldocaml.org/v1/en/html/records.html)定义 Record：\r\n\r\n```ocaml\r\ntype <记录名称> =\r\n  { <字段> : <类型> ;\r\n    <字段> : <类型> ;\r\n    ...\r\n  }\r\n```\r\n\r\n例如，\r\n\r\n```ocaml\r\ntype person = {\r\n    name: string;\r\n    age: int;\r\n    job: string;\r\n}\r\n\r\nlet p = {name = \"John\"; age = 20; job = \"jobless\"}\r\nlet _ = Js.log p\r\n```\r\n\r\n上面的代码产生了一个 [\"John\", 20, \"jobless\"] 的数组，这并不是我们想要的。要保留键，我们必须使用对象语法将我们的 Record 包装在 JavaScript 对象类型 Js.t 中。\r\n\r\n```ocaml\r\ntype person = <name: string; age: int; job: string> Js.t\r\n```\r\n\r\n这里的角括号是在 BuckleScript 中创建对象。请注意，这与典型的基于类的面向对象语言不同，它不需要 Class 的概念。对于来自其他世界的人来说，这可能看起来很奇怪，但是[在 OCaml 类型中并不等于类](https://realworldocaml.org/v1/en/html/objects.html#ocaml-objects)。一个对象可以在没有类的情况下创建。\r\n\r\n为了创建，我们可以使用 person 类型的对象\r\n\r\n```ocaml\r\nlet p = object\r\n    method name = \"John\"\r\n    method age = 20\r\n    method job = \"jobless\"\r\nend;;\r\n```\r\n\r\n不，这不是一个错字。我们想要暴露给外部世界的属性被定义为方法。这是未包装在 Js.t 中的对象的原始 OCaml 语法。但是，BuckleScript 将所有 JavaScript 对象解除为 Js.t. 它通过提供 bs.obj s注释帮助我们避免语法负担。所以，上面的代码将成为\r\n\r\n```ocaml\r\nlet p = [%bs.obj {name=\"John\";age=20;job=\"jobless\"}]\r\n```\r\n\r\nReasonML 将语法糖带到另一个层面。要定义一个 JavaScript 绑定：\r\n\r\n```ocaml\r\ntype person = {\r\n    .\r\n    \"name\": string,\r\n    \"age\": int,\r\n    \"job\": string,\r\n};\r\n```\r\n\r\n并在 ReasonML 中创建 JavaScript 对象：\r\n\r\n```ocaml\r\nlet p = {\"name\": \"John\", \"age\": 20, \"job\": \"jobless\"};\r\n```\r\n\r\n## 类\r\n\r\n在 ES6 中引入的 JavaScript 类仅仅是使用基于原型的继承和函数闭包的功能。\r\n\r\n> [类语法不会为 JavaScript 引入新的面向对象的继承模型。](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)\r\n\r\n他们[不鼓励使用](https://bucklescript.github.io/docs/en/class.html#bind-to-js-classes)：\r\n\r\n> 通常，更喜欢使用先前的对象部分的特征来绑定到 JS 对象。\r\n\r\n最后，本文旨在讨论如何将 BuckleScript / ReasonML 对象绑定到 JavaScript 对象，但到目前为止，我们所做的仅仅是定义使 OCaml 类型系统识别我们要使用的对象的结构。\r\n\r\n`external` 是我们想要将值绑定到 JavaScript 值时使用的关键字。例如\r\n\r\n```ocaml\r\nexternal johb : person = \"john\" [@@bs.val]\r\n```\r\n\r\n这意味着我们将 john 绑定到 JavaScript 变量名称 john 并且它有一个 person 类型。\r\n\r\n## 总结\r\n\r\n使用 JavaScript 对象时，可能会试图将其与（Js.t）框一起使用。但是，为了获得 OCaml 类型系统的全部好处，我们宁愿将 Js.t 转换为本地结构。\r\n","source":"source\\_posts\\how-to-bind-bucklescript-reasonml-objects-to-javascript-objects.md"},{"title":"Reason 入门手册","created":"2018/05/30","description":"Reason 入门手册","author":"lanqy","link":"2018/05/30/reason-in-nutshell-getting-started-guide","htmlDir":"website\\2018\\05\\30\\reason-in-nutshell-getting-started-guide","htmlFile":"website\\2018\\05\\30\\reason-in-nutshell-getting-started-guide\\index.html","body":"# Reason 入门手册\r\n\r\n译自：https://zaiste.net/reason_in_nutshell_getting_started_guide/\r\n\r\n![Reason](/images/zaiste-reason.png)\r\n\r\n> 本教程旨在提供对 Reason 的全面但相对较短的介绍。\r\n\r\n[Reason](https://reasonml.github.io/) 是一种构建在 [OCaml](https://ocaml.org/) 之上的编程语言。它提供了函数式和面向对象的功能，并且具有类型安全性并关注性能。它是在 Facebook 创建的。它的语法与 JavaScript 类似。目的是使 JavaScript 与 JavaScript 程序员的互操作更容易。Reason 可以访问 JavaScript 和 OCaml 生态系统。OCaml 创建于 1996 年，它是一种具有类型推导的函数式编程语言。\r\n\r\nReason 网站包含一个[在线游乐场](https://reasonml.github.io/en/try.html)。它允许使用该语言并直观的查看生成的 JavaScript。它也可以从 OCaml 转换为 Reason。\r\n\r\n## 为什么\r\n\r\n- 在 JavaScript 类型注释中，linting 或统一格式是作为外部依赖项提供的，例如 Flow，TypeScript，ESLint 或 Prettier。Reason 提供了这些功能的开箱即用。这使得开发过程更加简化和方便。\r\n- Reason 提供对 [ReasonReact](https://reasonml.github.io/reason-react/) 的 React 支持。它还支持 JSX 语法（ React 中使用的类似 HTML 的语法）。开箱即用\r\n- Reason 还有生成本机二进制文件的能力。生成的代码是高性能的。没有虚拟机开销。它提供了一个便于部署过程的二进制文件。\r\n\r\n## 它是如何工作的\r\n\r\nReason 被编译为 OCaml 的抽象语法树。这使 Reason 成为一个转译器。 OCaml 不能直接在浏览器中运行。AST 可以转换为各种目标。可以使用 BuckleScript 将 AST 编译为 JavaScript。它还提供了 OCaml 和 JavaScript 生态系统之间的互操作。\r\n\r\nBuckleScript 速度极快，可生成可读的 JavaScript。它还提供了外部函数接口（FFI）以允许与 JavaScript 现有库的互操作性。检查[BuckleScript 基准](https://github.com/neonsquare/bucklescript-benchmark)。 BuckleScript 由 Messanger 团队在 Facebook 上使用，在 WebAssembly spec 解释器上由 Google 使用。在这里检查 Bucklescript 演示。 BuckleScript 由 [Hongbo Zhang](https://twitter.com/bobzhang1988/) 创建。\r\n\r\n## 你好 Reason\r\n\r\n我们将使用 BuckleScript 生成一个 Reason 项目。该工具提供即时可用的项目模板，称为 `themes`。\r\n\r\n我们先从全局安装 `bs-platform` 开始：\r\n\r\n```ocaml\r\nnpm install -g bs-platform\r\n```\r\n\r\n我们现在可以使用 `bs-platform` 提供的 `bsb` 二进制文件生成项目脚手架。我们将使用 `basic-reason` 模板从最基本的 Reason 项目结构开始。\r\n\r\n```ocaml\r\nbsb -init reason-1 -theme basic-reason\r\n```\r\n\r\n```ocaml\r\nMaking directory reason-1\r\nSymlink bs-platform in /Users/zaiste/code/reason-1\r\n```\r\n\r\n以下是通过 BuckleScript 从 `basic-reason` 模板生成的 Reason 目录结构：\r\n\r\n```ocaml\r\n.\r\n├── README.md\r\n├── bsconfig.json\r\n├── lib\r\n├── node_modules\r\n├── package.json\r\n└── src\r\n    └── Demo.re\r\n```\r\n\r\n`bsconfig.json` 包含 Reason 项目的 BuckleScript 配置。它允许指定要通过源编译的文件，通过 `bs-dependencies` 的 BuckleScript 依赖关系，编译器的附加标志等等。\r\n\r\n下一步是构建项目。这将采取 Reason 代码并通过 BuckleScript 传递它以生成 JavaScript。默认情况下，编译器将以 Node.js 为目标。\r\n\r\n```ocaml\r\nnpm run build\r\n```\r\n\r\n```ocaml\r\n(* 输出 *)\r\n> reason-1@0.1.0 build /Users/zaiste/code/reason-1\r\n> bsb -make-world\r\n\r\nninja: Entering directory `lib/bs'\r\n[3/3] Building src/Demo.mlast.d\r\n[1/1] Building src/Demo-MyFirstReasonml.cmj\r\n```\r\n\r\n最后，我们可以使用 `node` 来运行 由 BuckleScript 生成的文件。\r\n\r\n```ocaml\r\nnode src/Demo.bs.js\r\n\r\n(* 将输出 Hello, BuckleScript and Reason! *)\r\n```\r\n\r\n## 语法 101\r\n\r\n在本节中，我将详细介绍我发现的特殊的，新的或不同的语法元素。\r\n\r\n### 模块\r\n\r\nReason 文件是模块。在 JavaScript 或类似的编程语言中没有 `require` 或 `import` 语句。模块定义必须以模块名称作为前缀以在外部工作。该功能来自 OCaml 。因此，您可以自由移动文件系统中的模块文件，而无需修改代码。\r\n\r\n### 函数\r\n\r\n函数使用 `let` 和 `=>` 来定义。\r\n\r\n```ocaml\r\nlet greet = name =>\r\n    Js.log(\"Hello, \" ++ name ++ \"!\");\r\n\r\ngreet(\"Zaiste\");\r\n```\r\n\r\n`++` 运算符用于连接字符串。\r\n\r\n函数的输入参数可以被标记。这使得函数调用更加明确：传入的值不再需要遵循函数定义中的参数顺序。用 `~` 作为参数名称的前缀使其标记。\r\n\r\n```ocaml\r\nlet greet = (~name, ~location) =>\r\n    Js.log(\"Hello, \" ++ name ++ \"! You're in \" ++ location);\r\n\r\ngreet(~location=\"Vienna\", ~name=\"Zaiste\");\r\n```\r\n\r\n### 数据结构\r\n\r\n#### 变体\r\n\r\n变体是一个数据结构，它保存来自一组固定值的值。这也被称为标记或不相交联合或代数数据类型。变体中的每个案例都必须大写。可选，它可以接收参数。\r\n\r\n```ocaml\r\ntype animal = \r\n    | Dog\r\n    | Cat\r\n    | Bird;\r\n```\r\n\r\n#### 记录\r\n\r\n这是一个记录\r\n\r\n```ocaml\r\nlet p = {\r\n    name: \"Zaiste\",\r\n    age: 13\r\n}\r\n```\r\n\r\n记录需要明确的类型定义。\r\n\r\n```ocaml\r\ntype person = {\r\n    name: string,\r\n    age: int\r\n}\r\n```\r\n\r\n在模块的作用域中，类型将被继承：p 绑定将被识别为 `person` 类型。在模块之外，您可以通过在文件名前添加前缀来引用该类型。\r\n\r\n```ocaml\r\nlet p: Person.person = {\r\n    name: \"Sean\",\r\n    age: 12\r\n}\r\n```\r\n\r\n有一个约定为每个类型创建一个模块并将类型命名为 `t` 以避免重复，即用 `Person.t` 代替 `Person.person`。\r\n\r\n### 异步编程和 Promise\r\n\r\n通过 BuckleScript 提供的内置 Promise 支持，作为 JS.Promise 模块提供。以下是使用 [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) 进行 API 调用的示例：\r\n\r\n```ocaml\r\nJs.Promise.(\r\n    Fetch.fetch(endpoint)\r\n    |> then_(Fetch.Response.json)\r\n    |> then_(json => doSomethingOnReponse(json) |> resolve)\r\n)\r\n```\r\n\r\n您需要使用 `then_` ，因为 `then` 是 OCaml 中的保留字。\r\n\r\n### 模式匹配\r\n\r\n模式匹配是基于提供值的形状的调度机制。在 Reason 中，模式匹配是通过 `switch` 语句实现的。它可以与变体类型或解构机制一起使用。\r\n\r\n```ocaml\r\nswitch pet {\r\n    | Dog => \"woof\"\r\n    | Cat => \"meow\"\r\n    | Bird => \"chirp\"\r\n};\r\n```\r\n\r\n我们可以使用模式匹配进行列表解构：\r\n\r\n```ocaml\r\nlet numbers = [\"1\", \"2\", \"3\", \"4\"];\r\nswitch numbers {\r\n    | [] => \"Empty\"\r\n    | [n1] => \"Only one number: \" ++ n1\r\n    | [n1, n2] => \"Only two numbers\"\r\n    | [n1, _, n3, ...rest] => \"At least three numbers\"\r\n}\r\n```\r\n\r\n或者，我们可以将其用于记录解构\r\n\r\n```ocaml\r\nlet project = {\r\n    name: \"Huncwot\",\r\n    size: 101101,\r\n    forks: 42,\r\n    deps: [{name: \"axios\"}, {name: \"sqlite3\"}]\r\n};\r\n\r\nswitch project {\r\n    | {name: \"Huncwot\", deps} => \"Matching by `name`\"\r\n    | {location, years: [{name: \"axios\"}, ...rest]} => \"Matching by one of `deps`\"\r\n    | project => \"Any other situation\"\r\n}\r\n```\r\n\r\n### 可选值\r\n\r\noption() 是 Reason 中描述 “ `nullable` (可空)” 值的内置变量：\r\n\r\n```ocaml\r\ntype option('a) = None | Some('a);\r\n```\r\n\r\n### 不同\r\n\r\n- `unit` 意味着“无”\r\n- `unit => unit` 是一个函数的签名，它不接受任何输入参数并且不返回任何值;主要用于回调函数\r\n\r\n## Reason 中的 React\r\n\r\n### 你好 ReasonReact\r\n\r\n[ReasonReact](https://reasonml.github.io/reason-react/) 是一个 Reason 中用于创建 React 应用程序的内置功能。\r\n\r\n我们使用 BuckleScript 及其 `React` 模板创建一个 ReasonReact 项目。\r\n\r\n```ocaml\r\nbsb -init reasonreact-1 -theme react\r\n```\r\n\r\nReason 团队推荐 ReasonReact 项目脚手架使用此方法。也可以使用带有 [reason-scripts](https://github.com/reasonml-community/reason-scripts) 模板的 yarn 来获得更完整的起点。\r\n\r\nReasonReact 提供了两种类型的组件：`statelessComponent` 和 `reducerComponent`。与 `stateless` (无状态)组件相反，`reducer` (减速器)组件是有状态的，提供类似 Redux 的 `reducer`。\r\n\r\n```ocaml\r\nlet s = ReasonReact.string;\r\n\r\nlet component = ReasonReact.statelessComponent(\"App\");\r\n\r\nlet make = (~message, _children) => {\r\n    ...component,\r\n    render: _self => \r\n        <h1 className=\"header\">(s(message))</h1>\r\n}\r\n```\r\n\r\n如前所述 `~` 指定一个带标号的参数来自由排序函数的输入参数。绑定名称中的 `_` 告诉编译器该函数的主体中未使用该参数。扩展运算符（`...`）与 `component` (组件)一起意味着我们扩展了现有的组件。在这个例子中，我们也重写（覆盖）了 `render` 函数。\r\n\r\nReason 中的 JSX 比 React 更严格：我们需要使用 `ReasonReact.string()` 显式包装字符串。\r\n\r\n### 构建非平凡的 ReasonReact 应用程序\r\n\r\n让我们构建一个超越显示预定义数据的 ReasonReact 应用程序。我们将为趋势库创建一个 GitHub 查看器。目的是展示如何与外部 API 集成，如何管理状态以及如何使用 React 的生命周期方法的方法。\r\n\r\n为了这个例子的目的，我们将使用 [reason-scripts](https://github.com/reasonml-community/reason-scripts) 来引导我们的 Reason 项目。\r\n\r\n```ocaml\r\nyarn create react-app reasonreact-github --scripts-version reason-scripts\r\n```\r\n\r\n安装依赖\r\n\r\n```ocaml\r\ncd reasonreact-github\r\nyarn\r\n```\r\n\r\n从以下开始：\r\n\r\n```ocaml\r\nyarn start\r\n```\r\n\r\n***存储库***是这个应用程序的中心概念。我们首先定义一个描述该实体的类型。我们将把它放在一个名为 Repo 的单独模块中。\r\n\r\n```ocaml\r\ntype t = {\r\n    name: string,\r\n    size: int,\r\n    forks: int\r\n};\r\n```\r\n\r\n从现在开始，我们可以从应用程序中的任何 Reason 文件引用此类型的 `Repo.t`，而不需要 requiring（引入）它。\r\n\r\n### 管理状态\r\n\r\n我们已经看到了一个无状态的组件。现在让我们创建一个具有状态的组件。在我们的上下文中，我们将使用 `RepoList` 组件管理从 GitHub 的 API 中获取的趋势库列表。\r\n\r\n首先定义由 `RepoList` 组件管理的状态的类型。\r\n\r\n```ocaml\r\ntype state = {\r\n    repos: list(Repo.t)\r\n}\r\n```\r\n\r\n但是，有一个问题。最初，在从 GitHub API 获取趋势库列表之前，`repos` 是未定义的。Reason 类型系统不允许我们有 `undefined ` (未定义) 的值。我们可以用一个空列表来模拟初始状态，但这不是最优的。空列表还可能意味着我们对提取趋势库的查询没有返回任何结果。\r\n\r\n让我们使用 Reason 的可选值来处理这种情况。\r\n\r\n```ocaml\r\ntype state = {\r\n    repos: option(list(Repo.t))\r\n}\r\n```\r\n\r\n下一步是定义该组件的可能操作。在ReasonReact中， `actions` (操作)表示为变体。现在我们只会有一个名为 `ReposFetched` 的 `action` (操作)。\r\n\r\n```ocaml\r\ntype action = \r\n    | ReposFetched(list(Repo.t));\r\n```\r\n\r\n为了在 ReasonReact 中创建一个有状态的组件，我们需要使用 `reducerComponent()` 函数。\r\n\r\n```ocaml\r\nlet component = ReasonReact.reducerComponent(\"App\");\r\n```\r\n\r\n这样的组件允许定义描述状态如何响应于 `actions` (动作)而被转换的 `reducer` (减速器)。Reducer将当前状态作为输入采取`actions` (动作)并将新状态作为输出返回。`reducer` (减速器)必须是纯粹的函数。\r\n\r\n```ocaml\r\nreducer: (action, _prevState) => {\r\n    switch action {\r\n        | ReposFetched(repos) =>\r\n            ReasonReact.Update({repos: Some(repos)})\r\n    }\r\n};\r\n```\r\n\r\n基于我们在 `reducer()` 方法中收到的参数，我们是模式匹配 `action` (操作)。模式匹配必须是详尽的。所有变体值必须匹配。`reducer` 定义放置在组件的 `main` 函数中。\r\n\r\n为了完成组件的定义，我们来定义它的初始状态：\r\n\r\n```ocaml\r\ninitialState: () => {\r\n    repos: Some([\r\n        {\r\n            name: \"Huncwot\",\r\n            size: 101101,\r\n            forks: 42\r\n        }\r\n    ])\r\n};\r\n```\r\n\r\n### 与 API 集成\r\n\r\n我们将使用 [bs-fetch](https://github.com/reasonml-community/bs-fetch) 从外部 API 获取数据。它是一个 BuckleScript 库，充当 Fetch API 之上的一个薄层。一旦数据被提取，我们将使用 `bs-json` 来提取我们感兴趣的字段。\r\n\r\n开始安装 `bs-fetch` 和 `bs-json`：\r\n\r\n```ocaml\r\nnpm i bs-fetch @glennsl/bs-json\r\n```\r\n\r\n将它们添加到 `bsconfig.json` 中的 `bs-dependencies`：\r\n\r\n```ocaml\r\n{\r\n    \"bs-dependencies\": [\r\n        ...,\r\n        \"bs-fetch\",\r\n        \"@glennsl/bs-json\"\r\n    ]s\r\n}\r\n```\r\n\r\n我们将 Repo 类型定义为一组三个字段：`name`，`size` 和 `forks`。一旦从 GitHub API 获取有效载荷，我们就解析它以提取这三个字段。\r\n\r\n```ocaml\r\nlet parse = json =>\r\n    Json.Decode.{\r\n        name: json |> field(\"name\", string),\r\n        size: json |> field(\"size\", int),\r\n        forks: json |> field(\"forks\", int)\r\n    }\r\n```\r\n\r\n`field` 是 `Json.Decode` 的一个方法。`Json.Decode.{...}`（注意这个点号）打开 `Json.Decode` 模块。它的属性现在可以在这些大括号内使用，而不需要使用 `Json.Decode` 作为前缀。\r\n\r\n由于 GitHub 在 `items` 下返回 `repos` ，我们定义另一个函数来获取该列表。\r\n\r\n```ocaml\r\nlet extract = (fields, json) =>\r\n    Json.Decode.(\r\n        json |> at(field, list(parse))\r\n    );\r\n```\r\n\r\n最后，我们可以发出请求并通过解析函数传递返回的数据：\r\n\r\n```ocaml\r\nlet list = () => \r\n    Js.Promise.(\r\n        Fetch.fetch(endpoint)\r\n        |> then_(Fetch.Response.json)\r\n        |> then_(text => extract([\"items\"], text) |> resolve)\r\n    );\r\n```\r\n\r\n### React 生命周期方法\r\n\r\n让我们使用 `didMount` 生命周期方法触发从 GitHub API 获取存储库。\r\n\r\n```ocaml\r\ndidMount: self => {\r\n    let handle = repos => self.send(ReposFetched(repos));\r\n    Repo.list()\r\n    |> Js.Promise.then_(repos => {\r\n        handle(repos);\r\n        Js.Promise.resolve();\r\n    });\r\n    |> ignore;\r\n};\r\n```\r\n\r\n`handle` 是一个将 `ReposFetched` 操作分派给 `reducer` 的方法。一旦承诺解决，操作将把获取的存储库传送到 `reducer` (减速器)。这将更新我们的状态。\r\n\r\n### 渲染\r\n\r\n由于我们区分了非初始化状态和存储空列表，因此处理初始***加载进度***消息很简单。\r\n\r\n```ocaml\r\nrender: self => {\r\n    <div>\r\n    (\r\n        switch self.state.repos {\r\n            | None => s(\"Loading repositories...\")\r\n            | Some([]) => s(\"Empty list\")\r\n            | Some(repos) =>\r\n            <ul>\r\n            (\r\n                repos\r\n                |> List.map((repo: Repo.t) => <li> (s(repo.name)) </li>)\r\n                |> Array.of_list\r\n                |> ReasonReact.array\r\n            )\r\n            </ul>\r\n        }\r\n    )\r\n    </div>\r\n};\r\n```\r\n\r\n### 错误处理\r\n\r\n无\r\n\r\n### CSS 中的类型\r\n\r\n使用 [bs-css](https://github.com/SentiaAnalytics/bs-css) 的 CSS 类型。\r\n\r\n通过 `yarn` 安装\r\n\r\n```ocaml\r\nyarn add bs-css\r\n```\r\n\r\n并将它添加到 `bsconfig.json` 中的 `bs-dependencies`：\r\n\r\n```ocaml\r\n\"bs-dependencies\": [\r\n  ...,\r\n  \"bs-css\"\r\n]\r\n```\r\n\r\n组件：\r\n\r\n```ocaml\r\nlet style = \r\n    Css.(\r\n        {\r\n            \"header\": style([backgroundColor(rgba(111, 37, 35, 1.0)), display(Flex)]),\r\n            \"title\": style([color(white), fontSize(px(28)), fontWeight(Bold)]),\r\n        }\r\n    );\r\n\r\nlet make = _children => {\r\n    ...component,\r\n    render: _self =>\r\n    <header className=style##header>\r\n        <h1 className=style##title> (s(\"This is title\")) </h1>\r\n    </header>\r\n};\r\n```\r\n\r\n## 词汇\r\n\r\n- `rtop` 是 Reason 的交互式命令行。\r\n- Merlin 是 OCaml 和 Reason 的自动完成服务文件。\r\n- [@bs...] FFI 的 Bucklescript 注释\r\n\r\n## 其他资源\r\n\r\n- [Awesome ReasonML](https://github.com/vramana/awesome-reasonml)\r\n- [Real World OCaml](https://realworldocaml.org/)\r\n- http://2ality.com/archive.html?tag=reasonml\r\n- https://jamesfriend.com.au/a-first-reason-react-app-for-js-developers\r\n- https://github.com/reasonml-community/reason-scripts\r\n- https://dev.to/jlewin_/reasonml-getting-started-53gi\r\n- https://medium.com/@ryyppy/a-quick-look-on-my-reasonml-workflow-with-vscode-637685f9417a\r\n- https://redex.github.io/\r\n- https://github.com/arecvlohe/reasonml-cheat-sheet\r\n- https://news.ycombinator.com/item?id=16500481\r\n- [ReasonTools browser extension](https://github.com/reasonml/reason-tools)\r\n\r\n## 待定\r\n\r\n```ocaml\r\nmodule History = {\r\n    type h;\r\n    [@bs.send] external goBack : h => unit = \"\";\r\n    [@bs.send] external goForward: h => unit = \"\";\r\n    [@bs.send] external go : (h, ~jumps: int) => unit = \"\";\r\n    [@bs.get] external length : h => int = \"\";\r\n};\r\n```\r\n\r\nBuckleScript 允许我们将原始 JavaScript 与 Reason 代码混合使用。\r\n\r\n```ocaml\r\n[%bs.raw {|require('./app.css')|}];\r\n```","source":"source\\_posts\\reason-in-nutshell-getting-started-guide.md"},{"title":"开始使用 ReasonML 和 React Native","description":"开始使用 ReasonML 和 React Native","created":"2018/05/30","author":"lanqy","link":"2018/05/30/getting-started-with-reasonml-and-react-native","htmlDir":"website\\2018\\05\\30\\getting-started-with-reasonml-and-react-native","htmlFile":"website\\2018\\05\\30\\getting-started-with-reasonml-and-react-native\\index.html","body":"\r\n# 开始使用 ReasonML 和 React Native\r\n\r\n译自：https://blog.callstack.io/getting-started-with-reasonml-and-react-native-299476389c3e\r\n\r\n![1_s4A8_PwjA1Ichs6VnVq3Dg.jpeg](/images/1_s4A8_PwjA1Ichs6VnVq3Dg.jpeg)\r\nPhoto by Will O (https://unsplash.com/photos/St4qInZrYC4)\r\n\r\n> 以下是如何开始使用 React Native和 ReasonML 的指南。为了本博文的目的，我假设您已经熟悉 React Native 并部分使用 ReasonML 。如果您尚未接触过 ReasonML，请查看[文档](https://reasonml.github.io/docs/en/global-installation.html)。\r\n\r\n首先安装 [React Native CLI](https://facebook.github.io/react-native/docs/getting-started.html)：\r\n\r\n```ocaml\r\nnpm i -g react-native-cli\r\n```\r\n\r\n现在我们可以初始化一个新的 React Native 项目，就像我们对每个 React Native 应用程序所做的一样：\r\n\r\n```ocaml\r\nreact-native init MyReasonApp\r\n```\r\n\r\n## 添加 “ Reason 部分”\r\n\r\n我们将需要 3 个包：\r\n\r\n- [`bs-platform`](https://bucklescript.github.io/docs/en/what-why.html) - 将 ReasonML / OCaml 编译为干净，可读和高性能的 JavaScript 代码\r\n- [`reason-react`](https://reasonml.github.io/reason-react) - ReactJS 的 Reason 绑定\r\n- [`bs-react-native`](https://github.com/reasonml-community/bs-react-native) - React Native 的 BuckleScript 绑定\r\n\r\n让我们将它们添加到我们的项目中：\r\n\r\n```ocaml\r\nnpm i -P bs-platform reason-react bs-react-native\r\n```\r\n\r\n现在我们需要创建一个 `bsconfig.json` ，它是一个 [BuckleScript 的配置文件](https://bucklescript.github.io/docs/en/build-configuration.html)：\r\n\r\n```ocaml\r\n{\r\n    \"name\": \"my-reason-app\",\r\n    \"bsc-flags\": [\"-bs-no-version-header\", \"-bs-super-errors\"],\r\n    \"refmt\": 3,\r\n    \"bs-dependencies\": [\"reason-react\", \"bs-react-native\"],\r\n    \"reason\": {\r\n        \"react-jsx\": 2\r\n    },\r\n    \"package-specs\": {\r\n        \"module\": \"commonjs\",\r\n        \"in-source\": true\r\n    },\r\n    \"sources\": [\r\n        {\r\n            \"dir\": \"src\",\r\n            \"subdirs\": true\r\n        }\r\n    ]\r\n}\r\n```\r\n\r\n让我们在这里停一分钟。有几个不同于通常的设置。\r\n\r\n首先是 [`\"subdirs\": true`](https://bucklescript.github.io/docs/en/build-configuration.html#sources)，使得 BuckleScript 知道它应该检查应该编译的代码的子目录。\r\n\r\n另一个是 [`\"in-source\": true`](https://bucklescript.github.io/docs/en/build-configuration.html#package-specs) ，这个非常方便，与源文件一起生成输出（默认情况下，它们输出到 `lib/js` 目录下）。当我们引用 `.js` 文件或资源文件时，这非常有用。\r\n\r\n没有它，要导入一个图像，你会参考它：\r\n\r\n```ocaml\r\n<Image\r\n  style=Styles.icon\r\n  source=(\r\n    Required(Packager.require(\"../../../assets/right.png\"))\r\n  )\r\n/>\r\n```\r\n\r\n使用 `\"in-source\": true` ，它会看起来像：\r\n\r\n```ocaml\r\n<Image\r\n  style=Styles.icon\r\n  source=(Required(Packager.require(\"./assets/right.png\")))\r\n/>\r\n```\r\n\r\n我更喜欢后者，因此我启用了该选项。\r\n\r\n## React Native 中的 ReasonML\r\n\r\n我们完成了配置，回顾一下，我们添加了三个软件包：`bs-platform`，`reason-react` 和 `bs-react-native`。然后我们添加了 `BuckleScript` 的配置文件 `bsconfig.json`，就是这样！ 🎉\r\n\r\n\r\n现在我们来写一些 Reason 吧！\r\n\r\n正如我们之前在 `bsconfig.json` 中定义的，我们将把所有的 ReasonML 代码保存在 `src` 目录中。在新创建的 `src` 目录中（在我们项目的根目录中），让我们添加`App.re` ，它可能看起来像这样：\r\n\r\n\r\n```ocaml\r\nopen BsReactNative;\r\n\r\n/* 这里我们定义一些样式 */\r\nmodule Styles = {\r\n    open Style;\r\n\r\n    let container = \r\n        style([\r\n            flex(1.),\r\n            justifyContent(Center),\r\n            alignItems(Center),\r\n            backgroundColor(String(\"tomato\")),\r\n        ]);\r\n    let text = style([color(String(\"#fff\")), fontSize(Float(24.))]);\r\n};\r\n\r\nmodule Main = {\r\n    let component = ReasonReact.statelessComponent(\"Main\");\r\n\r\n    let make = _children => {\r\n        ...component,\r\n        render: _self =>\r\n            <View style=Styles.container>\r\n                <Text style=Styles.text>\r\n                    (ReasonReact.string(\"Let's play with ReasonML!\"))\r\n                </Text>\r\n            </View>,\r\n    };\r\n};\r\n\r\nlet app = () => <Main />;\r\n```\r\n\r\n我还从项目的根目录中删除了 `App.js`（这是由 React Native CLI 生成的文件）。\r\n\r\n我们需要做的最后一件事是将我们编译好的 `App` 导入到 `index.js` 中：\r\n\r\n```ocaml\r\nimport { AppRegistry } from 'react-native';\r\nimport { app } from './src/App';\r\n\r\n/*\r\n 如果 \"in-source\" 选项为 false (默认为 false )，您将以这种方式导入app:\r\n import { app } from \"./lib/js/src/App.js\";\r\n*/\r\n\r\nAppRegistry.registerComponent('MyReasonApp', () => app);\r\n```\r\n\r\n最后，我们可以通过运行来编译代码:\r\n\r\n```ocaml\r\nnpm run watch\r\n```\r\n\r\n这将监视您对 Reason 代码所做的任何更改并进行编译（如果没有错误的话）。\r\n\r\n现在让我们开始运行 React Native 应用程序：\r\n\r\n```ocaml\r\nreact-native run-ios\r\n```\r\n\r\n你应该看到：\r\n\r\n![1_tsDhHE5u-a4v8Url4lXlUw.png](/images/1_tsDhHE5u-a4v8Url4lXlUw.png)\r\n\r\n快乐 hacking ! 🎉\r\n\r\n这里是与上述设置的 repo 链接：\r\n\r\nhttps://github.com/knowbody/ReasonReactNativeApp\r\n\r\n... \r\n\r\n[在 Twitter 上关注 Mateusz Zatorski](https://twitter.com/matzatorski)\r\n","source":"source\\_posts\\getting-started-with-reasonml-and-react-native.md"},{"title":"ReasonML - React 为首要目标","created":"2018/05/28","description":"ReasonML - React 为首要目标","author":"lanqy","link":"2018/05/28/reasonml-react-as-first-intended","htmlDir":"website\\2018\\05\\28\\reasonml-react-as-first-intended","htmlFile":"website\\2018\\05\\28\\reasonml-react-as-first-intended\\index.html","body":"# ReasonML - React 为首要目标\r\n\r\n译自：https://www.imaginarycloud.com/blog/reasonml-react-as-first-intended/\r\n\r\nReasonML 是 [Facebook](https://www.facebook.com/) 用来开发 React 应用程序并将其作为 JavaScript 的未来版本推广的新技术（[他们说](https://reasonml.github.io/docs/en/what-and-why.html)ES2030）。在这篇文章中，我将简要介绍一下这项技术。\r\n\r\n## 简而言之，ReasonML是：\r\n\r\n- 一种编写 React 应用程序的新方法;\r\n- OCaml语义的JavaScript友好语法;\r\n- 静态类型 - 带有类型推断;\r\n- 函数式，但不是纯粹的;\r\n- 主要编译为JavaScript;\r\n- 由 Facebook 和 Bloomberg。\r\n\r\n## 以前的 React 与现在的 React 的不同\r\n\r\nReact 的编程风格比面向对象编程更接近函数式。因此，发现[第一个 React 原型没有在 JavaScript 中实现，而是在 Standard ML中实现](https://reasonml.github.io/docs/en/what-and-why.html)，这并不奇怪。\r\n\r\n但是，随着原型开始成熟，作者决定将其移植到 JavaScript 并从那里继续，因为没有成熟的 JavaScript 转换器，也因为当时世界还没有准备好接受这种非主流的编程语言和风格。\r\n\r\n因此，React作为与JavaScript编程语言相关的技术而广受欢迎。\r\n\r\n尽管在 [JavaScript 生态系统](https://www.imaginarycloud.com/blog/a-javascript-ecosystem-overview/)中取得了这些成功，但有些人开始觉得幕后还有其他相关项目正在发生 - 例如 Redux，[Elm](https://www.imaginarycloud.com/blog/elm-javascript-reinvented-1-overview/) 和 Purescript，开始受到欢迎，从而推动社区的思维更接近 React 最初函数式和静态类型的根源。\r\n\r\n这使得 Facebook 相信将 React 本身拉近根本是可行和方便的。如果他们没有那么多已经完成的工作，他们不会这么做。\r\n\r\n#### Bucklescript\r\n\r\n一些公司正在开发这样的任务关键用户界面, 使用动态或渐进式语言可能会造成无法承受的损失。\r\n\r\n[Bloomberg](https://www.bloomberg.com/) 就是这样的公司之一，对 Bloomberg 而言，[张宏波正在尝试 JavaScript 运行时](https://www.techatbloomberg.com/blog/release-1-7-story-behind-bucklescript/)，他意识到将 OCaml 编译器移植到 JavaScript 并在浏览器上运行并不困难。\r\n\r\n```ocaml\r\n\r\n(* Bucklescript / O'Caml 中的阶乘实现 *)\r\n\r\nlet rec factorial n = \r\n    if n <= 0 then\r\n        1\r\n    else\r\n        n * fact(n - 1)\r\n\r\n```\r\n现实情况是，***OCaml编译器已经非常模块化***，并且用JavaScript生成的后端替换它的本地代码生成的后端并不是很难。有了这样的后端，甚至可以将OCaml编译器编译为JavaScript，从而***[自行托管Bucklescript编译器](https://bucklescript.github.io/bucklescript-playground/#Quick_Sort)***并在浏览器中运行它。\r\n\r\nBucklescript 诞生并且更好，它由 Bloomberg 以开源软件的形式发布。\r\n\r\n```ocaml\r\n(* Bucklescript / O'Caml 中的 FizzBu​​zz 实现 *)\r\n\r\nlet fizzbuzz i = \r\n    match i mod 3, i mod 5 with\r\n    | 0, 0 -> \"FizzBuzz\"\r\n    | 0, _ -> \"Fizz\"\r\n    | _, 0 -> \"Buzz\"\r\n    | _ -> string_of_int i\r\n\r\nlet _ = for i = 1 to 100 do\r\n    print_endline(fizzbuzz i)\r\ndone\r\n\r\n```\r\n\r\n需要注意的是，原始的 OCaml 编译器已经由 [Institut National de Recherche en Informatique et Automatique（INRIA）](https://en.wikipedia.org/wiki/French_Institute_for_Research_in_Computer_Science_and_Automation)进行了数十年的开发和优化，并且它是用于如此严重的类型检查语言的最快编译器之一。\r\n\r\n## ReasonML\r\n\r\n所以，***如果 Facebook 打算让静态类型的 React 生态系统被打入，Bucklescript 肯定是一个很好的候选***，因为他们似乎相信 JavaScript 以其流行的花括号语法对 React 的成功负有主要责任。\r\n\r\n```ocaml\r\n\r\n// ReasonML 中的阶乘实现\r\n\r\nlet rec factorial = (x) => \r\n    if(x <= 0) {\r\n        1;\r\n    } else {\r\n        x * factorial(x - 1);\r\n    };\r\n\r\n```\r\n\r\n然而，他们并不足够简单地将 Bucklescript 与其 OCaml 语法相结合。他们相当保守 OCaml 的语义; Bucklescript 后端和尽可能多的 JavaScript 语法。\r\n\r\n***为了保持 JavaScript 语法，他们创建了一个额外的解析器***，处理一种叫做 ReasonML 的新语言，它简直就是 OCaml，带有类似 JavaScript 的花括号语法。\r\n\r\n```ocaml\r\n\r\n// ReasonML 中的 FizzBuzz 实现\r\n\r\nlet fizzbuzz = (i) =>\r\n    switch ([i mod 3, i mod 5]) {\r\n        | [0, 0] => \"FizzBuzz\"\r\n        | [0, _] => \"Fizz\"\r\n        | [_, 0] => \"Buzz\"\r\n        | _ => string_of_int(i)\r\n    };\r\n\r\n    for(i in 1 to 100) {\r\n        print_endline(fizzbuzz(i));\r\n    };\r\n\r\n```\r\n\r\n***其结果与 JavaScript 非常相似***，以至于某些 JavaScript 代码可以被编译器直接处理，就好像它是 ReasonML 一样，立即享受静态类型编译器带来的好处，而无需更改任何代码。\r\n\r\n```ocaml\r\n\r\n// 有效的 ReasonML 和 Javascript 代码\r\n\r\nlet add = (a, b) => a + b;\r\nadd(4, 6);\r\n\r\n```\r\n\r\n## ReasonReact\r\n\r\n除了语言和编译器本身的工作之外，Facebook 还致力于开发围绕其 React 框架的 ReasonML 包装以及一些附加功能。\r\n\r\n它被称为 [Reason React](https://reasonml.github.io/reason-react/) 并且已经开发，因此可以很[容易地将 JavaScript React 组件](https://reasonml.github.io/reason-react/docs/en/reason-using-js.html)与 Reason 组件在同一个 ReactJS 或 Reason 应用程序中混合使用。\r\n\r\n应该注意的是，[Reason React] 不仅仅是 React 的包装，还提供了外部函数库，如 [Redux](https://redux.js.org/introduction) 和 [Immutable](https://facebook.github.io/immutable-js/)。\r\n\r\n## Redux 有什么用？\r\n\r\n*** Redux 是一名在 React 项目中非常流行的状态管理器***。 简而言之，它允许将应用程序域逻辑组织为一组组合的 reducer 函数，这些函数旨在表示应用程序的状态应该如何转换为外部事件（如用户交互）。\r\n\r\n***使用 ReasonML 时，我们不再需要 Redux。*** ReasonReact 无状态组件已经提供了 reducer 中构建的概念，旨在解决 Redux 用于解决的问题。\r\n\r\n```ocaml\r\n/*  \r\n    * ReasonReact 中的简单递增计数器  \r\n    * 尝试：http://bit.ly/counter-button-sample  \r\n*/\r\n\r\ntype state = {count: int};\r\n\r\ntype action = \r\n    | Click;\r\n\r\nlet component = ReasonReact.reducerComponent(\"Counter\");\r\n\r\nmodule Counter = {\r\n    let make = _children => {\r\n        ...component,\r\n\r\n        initialState: () => {count: 0},\r\n\r\n        reducer: (action, state) => \r\n            switch (action) {\r\n                | Click => ReasonReact.Update({count: state.count + 1})\r\n            },\r\n        \r\n        render: self => {\r\n            let message = \r\n                \"Clicked\"\r\n                ++ string_of_int(self.state.count)\r\n                ++ \" times(s)\";\r\n                <div>\r\n                    <button onClick=(_event => self.send(Click))>\r\n                    (ReasonReact.string(message))\r\n                    </button>\r\n                </div>;\r\n        },\r\n    };\r\n};\r\n\r\n\r\n```\r\n\r\n## 如何不可变？\r\n\r\n以前由 Immutable 提供的功能是在语言级别实现的。 ReasonML（和 OCaml ）操作默认是不可变的，因此避免了使用外部库的认知和性能开销。\r\n\r\n## 如何将 Reason 与 elm 进行比较？\r\n\r\n前一段时间，我写了一系列关于 [elm 语言 的文章](https://www.imaginarycloud.com/blog/elm-javascript-reinvented-1-overview/)，他们彼此没有什么不同。\r\n\r\n分析它们之间的深度差异超出了本文的预期范围，但总而言之，***它们源于对函数纯度的不同立场以及两个项目的不同成熟度水平***。\r\n\r\n下面你可以找到他们的特征如何匹配的表格摘要：\r\n\r\n共同的特征:\r\n\r\n- 函数式编程;\r\n- 编译成 JavaScript ;\r\n- 安全;\r\n- 短反馈回路;\r\n- 易于测试和反应堆;\r\n- 全覆盖，推断的静态类型。\r\n\r\n差异：\r\n\r\n特性 | Reason | Elm \r\n------------ | ------------- | -------------\r\n函数纯度 | 不纯粹 | 纯粹\r\n语法 | 基于Javascript的 - 可选 ML 为基础 | 更简洁;基于 ML 的语法\r\nJS 交互 | 更简单 - 不太安全 | 安全 - 更多的模板\r\n测试难易度 | 由于最终缺乏函数纯度，因此可能有些代码用 Reason 可能更难以测试 | 由于其函数纯度，始终易于测试\r\nReact 兼容 | 是 | 否\r\n处理JS的副作用 | 通过编写命令式代码很容易处理副作用 | 有时很难优雅地处理\r\n多态性 | 参数化和 OO 式 Ad-hoc | 参数型和行型\r\n编译速度 | 非常快 | 较慢\r\n目标平台 | Javscript、OCaml Bytecode; Native code(AMD; INTEl ; ARM & PowerPC) | Javascript\r\n\r\n行业 / 学术支持 | Facebook;Blooberg; INRIA | Evan Czaplicki(作者)；Prezi NoRedInk\r\n\r\n## 编译为本地代码\r\n\r\n正如您在上面的表格中注意到的那样，它提到了 ReasonML 可以编译为本地代码。这可以通过将 ReasonML语法层与剩余的原始 OCaml 编译器（包括原始本机代码后端）一起使用来完成。\r\n\r\n***这里有很多潜力***，最终允许在后端和前端之间共享原因代码，并将后端编译为本机代码。\r\n\r\n## 现实世界的 Reason\r\n\r\nReasonML 的旗舰应用程序是 Facebook Messenger，最初是一个使用 ReactJS 的应用程序，已逐步迁移到 ReasonML。此外，Reason 文档页面中列出了大量[其他项目和公司](https://reasonml.github.io/en/users-of-reason.html)。\r\n\r\n## 结论\r\n\r\n***ReasonML似乎是对 Elm 框架所探讨的相同概念的一种新尝试***。即便如此，从营销和技术观点来看，这个项目及其支持者所采取的选择似乎更有希望。\r\n\r\n虽然 Elm 看起来是一个建立在创新理念基础上的美丽原型，但 ***ReasonML 似乎是企业级的实现***，恰到好处地站在巨人的肩膀上，并吸引主流的品味。","source":"source\\_posts\\reasonml-react-as-first-intended.md"},{"title":"ReasonML 入门","created":"2018/05/28","description":"ReasonML 入门","author":"lanqy","link":"2018/05/28/reasonml-getting-started","htmlDir":"website\\2018\\05\\28\\reasonml-getting-started","htmlFile":"website\\2018\\05\\28\\reasonml-getting-started\\index.html","body":"# ReasonML 入门\r\n\r\n译自： https://dev.to/jlewin_/reasonml-getting-started-53gi\r\n\r\n\r\n在本教程中，我们将使用Reason构建一个小型天气应用程序。有一个链接到页面底部的源代码。本教程假设您对React有基本的了解，因为我们将使用ReasonReact绑定来构建应用程序。如果您以前没有使用过 React，那么[这篇文章](https://dev.to/tylermcginnis/a-comprehensive-guide-to-reactjs-in-2018--4nbc)是一个很好的开始。\r\n\r\n## 什么是 Reason\r\n\r\nReason 是 OCaml 的新语法，由 Facebook 开发，受 JavaScript 影响很大。它有 100％ 的类型覆盖率，这导致了一个非常强大的类型系统。\r\n\r\nReason 也适用于跨平台开发。我们可以使用 BuckleScript 将我们的代码编译成（可读的）JavaScript，从而打开整个 Web 平台。感谢 OCaml，它也可以使用 Reason 进行本地开发。\r\n\r\n此外，Reason 还可以访问整个 JS 和 OCaml 生态系统，并提供 ReasonReact 以使用 ReactJS 构建 UI 组件。文档中有一个[有用的页面](https://reasonml.github.io/docs/en/what-and-why.html)，可以更详细地解释优势！\r\n\r\n## 要求\r\n\r\n首先，让我们确保我们安装了正确的工具。\r\n\r\n我们将使用 Create React App 引导项目。如果您之前没有使用过，请通过运行 `npm i -g create-react-app` 进行安装。还有两个我们需要开始的软件包：\r\n\r\n- Reason CLI: Reason 工具链。[检查安装文档](https://github.com/reasonml/reason-cli#1-choose-your-platform)。\r\n- 在撰写本文时，macOS用户可以通过运行 `npm i -g reason-cli@3.1.0-darwin`。\r\n- BuckleScript: `npm i -g bs-platform`。\r\n\r\n我也使用 [vscode-reasonml](https://github.com/reasonml-editor/vscode-reasonml) 编辑器插件。如果您使用的是其他编辑器，请检查[插件列表](https://reasonml.github.io/docs/en/editor-plugins.html)以找到适合您的插件。\r\n\r\n## 我们的第一个组件\r\n\r\n要开始，我们将为我们的应用程序创建样板代码：\r\n\r\n`create-react-app weather-app --scripts-version reason-scripts`\r\n\r\n这给了我们一个基本的 App 组件：\r\n\r\n```ocaml\r\n[%bs.raw {|require('./app.css')|}];\r\n\r\n[@bs.module] external logo : string = \"./logo.svg\";\r\n\r\nlet component = ReasonReact.statelessComponent(\"App\");\r\n\r\nlet make = (~message, _children) => {\r\n    ...component,\r\n    render: (_self) =>\r\n        <div className=\"App\">\r\n            <div className=\"App-header\">\r\n                <img src=logo className=\"App-logo\" alt=\"logo\" />\r\n                <h2> (ReasonReact.stringToElement(message)) </h2>\r\n            </div>\r\n            <p className=\"App-intro\">\r\n                (ReasonReact.stringToElement(\"To get started, edit\"))\r\n                <code> (ReasonReact.stringToElement(\" src/app.re \")) </code>\r\n                (ReasonReact.stringToElement(\"and save to reload.\"))\r\n            </p>\r\n        </div>\r\n};\r\n```\r\n\r\n我们可以使用 `yarn start` 开始编译和运行。我们来看看一些有趣的部分......\r\n\r\n```ocaml\r\n[%bs.raw {|require('./app.css')|}];\r\n```\r\n\r\nBuckleScript 允许我们将原始的 JavaScript 代码混合到我们的代码中，从一个一行代码到一个完整的库(如果我们只是在 hacking)。这应该很少使用，但是在我们开始的时候可以快速开始。\r\n\r\n```ocaml\r\nlet component = ReasonReact.statelessComponent(\"App\");\r\n```\r\n\r\n我们将使用两种类型的ReasonReact组件：`statelessComponent` 和 `reducerComponent`。无状态组件按照他们在锡上所说的话做。 Reducer组件是有状态的，并且内置了类似 Redux 的 reducers。 我们稍后再讨论。\r\n\r\n```ocaml\r\nlet make = (~message, _children) => { ... }\r\n```\r\n这是定义我们组件的方法。 这两个参数具有不同的符号：`〜` 是一个带标签的参数，意味着我们可以通过名称引用参数，而 `_` 是一种更明确的方式显示参数未被使用（否则编译器会给我们一个警告）。\r\n\r\n`...component` 扩展运算符意味着我们的 make 函数正在构建我们刚定义的组件，覆盖默认值。\r\n\r\n```ocaml\r\n<h2> (ReasonReact.stringToElement(message)) </h2>\r\n```\r\n\r\nJSX 中的 Reason 比正常的 React 更严格。我们不能仅仅编写 `<h2> {message} </h2>`，而是必须将 `message` 字符串显式转换为 JSX 元素。\r\n\r\n稍后我们将构建自己的组件时，我们将使用此样板。\r\n\r\n## Reason 中的类型\r\n\r\n我们创建一个新文件 `WeatherData.re`。这将为我们的天气记录定义数据结构和任何相关方法。首先，我们来创建一个类型：\r\n\r\n```ocaml\r\ntype weather = {\r\n    summary: string,\r\n    temp: float\r\n};\r\n```\r\n\r\n在这个文件中，我们可以使用这个数据结构创建新记录，编译器会知道它是一个 Weather 项目。从其他文件中，我们需要告诉编译器该类型是什么。在 Reason 中，[文件可以作为模块引用](https://reasonml.github.io/docs/en/faq.html#i-don-t-see-any-import-or-require-in-my-file-how-does-module-resolution-work)，这意味着我们不必显式导入它们！我们可以这样做：\r\n\r\n```ocaml\r\nlet today: WeatherData.weather = {\r\n    summary: \"Warm throughout the day\",\r\n    temp: 30.5\r\n};\r\n```\r\n\r\n我之前提到 Reason 有 100％ 的类型覆盖率，但我们只定义了我们的 Weather 类型......其余覆盖范围从哪里来？我们可以明确地为每个我们使用的变量定义一个类型，例如：`let greeting: string = \"Hello\"`;但幸运的是 OCaml 系统可以为我们推断类型。所以，如果我们写 `let greeting = \"Hello\"` ;编译器仍然会知道 greeting 是一个字符串。这是 Reason 中的一个关键概念，可确保类型安全。\r\n\r\n## 保持状态\r\n\r\n回到我们的项目，让我们修改app.re，以便它可以存储我们想要显示的数据。这将涉及：\r\n\r\n- 定义我们的状态类型\r\n- 设置我们的初始状态（目前有一些虚拟数据）\r\n- 定义可应用于状态的操作(`actions`)\r\n- 定义组件的 `reducers` 来处理这些事件\r\n\r\n`Actions` 定义了我们可以对操作状态做不同的事情。例如，`Add` 或 `Subtract`。 Reducers 是纯粹的函数，它定义了这些动作如何影响状态，就像在 Redux 中一样。他们采取 `action` 和我们以前的状态作为参数，并返回一个[更新类型](https://reasonml.github.io/reason-react/docs/en/state-actions-reducer.html#state-update-through-reducer)。\r\n\r\n```ocaml\r\ntype state = {\r\n    weather: WeatherData.weather\r\n};\r\n\r\ntype action = \r\n    | WeatherLoaded(WeatherData.weather);\r\n\r\nlet component = ReasonReact.reducerComponent(\"App\");\r\n\r\nlet dummyWeather: WeatherData.weather = {\r\n    summary: \"Warm throughout the day\",\r\n    temp: 30.5\r\n};\r\n\r\nlet make = (_children) => {\r\n    ...component,\r\n\r\n    initaState: () => {\r\n        weather: dummyWeather\r\n    },\r\n\r\n    reducer: (action, _prevState) => {\r\n        switch action {\r\n            | WeatherLoaded(newWeather) =>\r\n              ReasonReact.Update({\r\n                  weather: newWeather\r\n              })\r\n        }\r\n    },\r\n\r\n    render: (self) =>\r\n        <div className=\"App\">\r\n            <p> (ReasonReact.stringToElement(self.state.weather.summary)) </p>\r\n        </div>\r\n};\r\n\r\n```\r\n\r\n这里有两个新的 Reason 概念：变体和模式匹配。\r\n\r\n```ocaml\r\ntype action = \r\n    | WeatherLoaded(WeatherData.weather);\r\n```\r\n\r\n这是一个变体：代表不同值的选择的数据结构（像枚举）。变体中的每个案例都必须大写，并且可以选择接收参数。在 ReasonReact 中，`action` 表示为变体。这些可以与 switch 表达式一起使用：\r\n\r\n```ocaml\r\nswitch action {\r\n    | WeatherLoaded(newWeather) =>\r\n      ReasonReact.Update({...})\r\n}\r\n```\r\n\r\n这是 Reason 中最有用的功能之一。这里我们是基于我们在 `reducer()` 方法中接收到的参数的模式匹配 `action`。如果我们忘记处理一个案例，编译器知道，并会告诉我们！\r\n\r\n![错误提示例子](/images/sfutmltmhu1fmzzjs9zs.png)\r\nReason 编译器捕获未处理的案例。\r\n\r\n在前面的例子中，我们使用解构来访问 newWeather 的值。我们也可以使用它来根据它们包含的值匹配 `actions`。这给了我们一些[非常强大的行为](https://reasonml.github.io/docs/en/pattern-matching.html)！\r\n\r\n## 获取数据\r\n\r\n到目前为止，我们的应用呈现虚拟天气数据 - 现在让我们从 API 中加载它。我们将把获取和解析数据的方法放在我们现有的 WeatherData.re 文件中。\r\n\r\n首先，我们需要安装 [bs-fetch](https://github.com/reasonml-community/bs-fetch) ：`npm i bs-fetch` 和 [bs-json](https://github.com/glennsl/bs-json)：`npm i @glennsl/bs-json`。我们还需要将它们添加到我们的 `bsconfig.json` 中：\r\n\r\n```ocaml\r\n{\r\n    ...\r\n    \"bs-dependencies\": [\r\n        \"bs-fetch\",\r\n        \"@glennsl/bs-json\"\r\n    ]\r\n}\r\n```\r\n\r\n我们将使用 [Yahoo Weather API](https://developer.yahoo.com/weather) 来获取我们的数据。我们的 `getWeather()` 方法将调用 API，然后使用`parseWeatherResultsJson()` 解析结果，然后解析天气项目：\r\n\r\n```ocaml\r\ntype weather = {\r\n    summary: string,\r\n    temp: float\r\n};\r\n\r\nlet url = \"https://query.yahooapis.com/v1/public/yql?q=select%20item.condition%20from%20weather.forecast%20where%20woeid%20in%20(select%20woeid%20from%20geo.places(1)%20where%20text%3D%22london%22)%20AND%20u%3D%22c%22&format=json&env=store%3A%2F%2Fdatatables.org%2Falltableswithkeys\";\r\n\r\nlet parseWeatherJson = json: weather => \r\n    Json.Decode.{\r\n        summary: field(\"text\", string, json),\r\n        temp: float_of_string(field(\"temp\", string, json))\r\n    };\r\n\r\nlet parseWeatherResultsJson = json =>\r\n    Json.parseOrRaise(json) |> Json.Decode.(at([\r\n        \"query\",\r\n        \"results\",\r\n        \"channel\",\r\n        \"item\",\r\n        \"condition\"\r\n    ], parseWeatherJson));\r\n\r\nlet getWeather = () =>\r\n    Js.Promise.(\r\n        Bs_fetch.fetch(url)\r\n            |> then_(Bs_fetch.Response.text)\r\n            |> then_(\r\n                jsonText => {\r\n                    let result = parseWeatherResultsJson(jsonText);\r\n                    resolve(result);\r\n                }\r\n            )\r\n    );\r\n\r\n```\r\n\r\n```ocaml\r\nJosn.parseOrRaise(json) |> Json.Decode.(at([\r\n    ...\r\n], parseWeatherJson));\r\n```\r\n\r\n这会在通过指定字段遍历数据之前解析 JSON 字符串响应。然后它使用 parseWeatherJson() 方法来解析在条件字段中找到的数据。\r\n\r\n```ocaml\r\nJson.Decode.{\r\n    summary: field(\"text\", string, json),\r\n    temp: float_of_string(field(\"temp\", string, json))\r\n};\r\n```\r\n\r\n在这个片段中，字段和字符串是 `Json.Decode` 的属性。这个新的语法“打开” `Json.Decode`，所以它的属性可以在大括号内自由使用（而不是重复`Json.Decode.foo`）。该代码生成一个 `weather` 项目，使用 `text` 和 `temp` 字段分配 `summary` 和 `temp`。\r\n\r\n`float_of_string` 完全符合你的期望：它将字符串中的温度（从API获得）转换为浮点数。\r\n\r\n## 更新状态\r\n\r\n现在我们有一个返回 `promise` 的 `getWeather()` 方法，我们需要在 App 组件加载时调用它。ReasonReact 对 React.js 有一组类似的生命周期方法，但有一些[细微差别](https://reasonml.github.io/reason-react/docs/en/lifecycles.html)。我们将使用 `didMount` 生命周期方法使 API 调用获取天气。\r\n\r\n首先，我们需要改变我们的状态，以表明可能没有状态的天气项目 - 我们将摆脱虚拟数据。 `option()` 是 Reason 中的一个内置变体，它描述了一个“`nullable`（可空）”值：\r\n\r\n```ocaml\r\ntype option('a) = None | Some('a);\r\n```\r\n\r\n我们需要在我们的状态类型和初始状态中指定 `None`，并在 `WeatherLoaded` reducer 中指定 `Some(weather)`：\r\n\r\n```ocaml\r\ntype state = {\r\n    weather: option(WeatherData.weather)\r\n};\r\n\r\n// ...\r\n\r\nlet make = (_children) => {\r\n    ...component,\r\n\r\n    initialState: () => {\r\n        weather: None\r\n    },\r\n\r\n    reducer: (action, _prevState) => {\r\n        switch action {\r\n            | WeatherLoaded(newWeather) =>\r\n              ReasonReact.Update({\r\n                  weather: Some(newWeather)\r\n              })\r\n        }\r\n    },\r\n\r\n    // ...\r\n};\r\n```\r\n\r\n现在，我们实际上可以在组件装入时发出 API 请求。查看下面的代码，`handleWeatherLoaded` 是一个将我们的 `WeatherLoaded` action 分派给 reducer 的方法。\r\n\r\n注意：重要的是从大多数组件生命周期中返回 `ReasonReact.NoUpdate`。reducer 将在下一次改变中处理所有状态变化。\r\n\r\n```ocaml\r\nlet make = (_children) => {\r\n    // ...\r\n\r\n    didMount: (self) => {\r\n        let handleWeatherLoaded = weather => self.send(WeatherLoaded(weather));\r\n        WeatherData.getWeather()\r\n            |> Js.Promise.then_(\r\n                weather => {\r\n                    handleWeatherLoaded(weather);\r\n                    Js.Promise.resolve();\r\n                }\r\n            )\r\n            |> ignore;\r\n\r\n            ReasonReact.NoUpdate;\r\n    },\r\n\r\n    // ...\r\n};\r\n```\r\n\r\n如果我们现在运行我们的应用程序，我们会遇到错误...我们当前正在尝试呈现关于 `self.state.weather` 的信息，但是直到我们收到来自 API 的响应时，它才设置为 None。让我们更新我们的应用程序组件，以便在等待时显示加载消息：\r\n\r\n```ocaml\r\nlet make = (_children) => {\r\n    // ... \r\n\r\n    render: (self) => \r\n        <div className=\"App\">\r\n            <p>\r\n            {\r\n                switch self.state.weather {\r\n                    | None =>\r\n                        ReactReact.stringToElement(\"Loading weather...\");\r\n                    | Some(weather) => \r\n                        ReactReact.stringToElement(weather.summary);\r\n                }\r\n            }\r\n            </p>\r\n        </div>\r\n};\r\n```\r\n\r\n结果...\r\n\r\n![效果图](/images/ezgif-3-cf07dc176b.gif)\r\n\r\n## 错误处理\r\n\r\n我们没有想过的一件事是如果我们无法加载数据会发生什么。如果API停机，或者它返回了我们预料不到的情况呢？我们需要认识到这一点并拒绝承诺：\r\n\r\n```ocaml\r\nlet getWeather = () =>\r\n    Js.Promise.(\r\n        Bs_fetch.fetch(url)\r\n            |> then_(Bs_fetch.Response.text)\r\n            |> then_(\r\n                jsonText => {\r\n                    switch (parseWeatherResultsJson(jsonText)){\r\n                    | exception e => reject(e);\r\n                    | weather => resolve(weather);\r\n                    };\r\n                }\r\n            )\r\n    );\r\n```\r\n\r\n```ocaml\r\nswitch (parseWeatherResultsJson(jsonText)) {\r\n    | exception e => reject(e);\r\n    | weather => resolve(weather);\r\n};\r\n```\r\n\r\n这个 switch 语句试图解析 API 响应。如果发生异常，它会拒绝承诺那个错误。如果解析成功，该承诺将与天气项目一起解决。\r\n\r\n接下来，我们将改变我们的状态，让我们认识到是否发生错误。我们来创建一个新的类型，它向我们之前的 `Some('a)` 或 `None` 添加一个 `Error` 案例。\r\n\r\n```ocaml\r\ntype optionOrError('a) = \r\n    | Some('a)\r\n    | None\r\n    | Error;\r\n\r\ntype state = {\r\n    weather: optionOrError(WeatherData.weather)\r\n};\r\n```\r\n\r\n在这样做的同时，我们还需要向渲染函数添加一个 `Error` 案例 - 我会让你自己添加。最后，我们需要创建一个新的 `action`和 `reducer`，以便在我们的 `getWeather()` 承诺被拒绝时使用。\r\n\r\n```ocaml\r\n// ...\r\ntype action = \r\n    | WeatherLoaded(WeatherData.weather)\r\n    | WeatherError;\r\n\r\nlet make = (_children) => {\r\n    ...component,\r\n\r\n    didMount: (self) => {\r\n        let handleWeatherLoaded = weather => self.send(WeatherLoaded(weather));\r\n        let handleWeatherError = () => self.send(WeatherError);\r\n\r\n        WeatherData.getWeather()\r\n            |> Js.Promise.then_(\r\n                // ...\r\n            )\r\n            |> Js.Promise.catch(\r\n                _err => {\r\n                    handleWeatherError();\r\n                    Js.Promise.resolve();\r\n                }\r\n            )\r\n            |> ignore;\r\n\r\n        ReasonReact.NoUpdate;\r\n    },\r\n\r\n    reducer: (action, _prevState) => {\r\n        switch action {\r\n            | WeatherLoaded(newWeather) =>\r\n                // ...\r\n            | weatherError =>\r\n              ReasonReact.Update({\r\n                  weather: Error\r\n              })\r\n        }\r\n    },\r\n\r\n    // ...\r\n}\r\n\r\n```\r\n\r\n这些是我们已经使用过的概念，但让用户知道是否出现了问题是很有用的。我们不想让他们挂着“加载”消息！\r\n\r\n我们有它，我们的第一个 ReasonReact 网络应用程序。干得不错！我们已经介绍了很多新的概念，但希望您已经看到了使用 Reason 的一些好处。\r\n\r\n如果您发现这个有趣的事情，并希望看到另一篇文章，请点击下面的反应让我知道！ ❤️🦄🔖\r\n\r\n## 扩展阅读\r\n\r\n- [更多的上下文](https://jacklewin.com/2018/getting-started-with-reason)，包括源代码的链接。\r\n- [探索ReasonML和函数式编程](http://reasonmlhub.com/exploring-reasonml) - 一本关于（你猜对了）的免费在线书籍 Reason 和 FP。\r\n\r\n## OSS项目\r\n\r\n- [bs-jest](https://github.com/glennsl/bs-jest) - Jest 的 BuckleScript 绑定。\r\n- [lwt-node](https://github.com/kennetpostigo/lwt-node) - Node.js API的 Reason 实现\r\n- [reason-apollo](https://github.com/apollographql/reason-apollo)绑定 Apollo 客户端和 React Apollo\r\n\r\n## 其他\r\n\r\n- [Discord 频道](https://discord.gg/reasonml)\r\n- [论坛](https://reasonml.chat/)\r\n- [Reason Town](https://reason.town/) - ReasonML 语言和社区的播客\r\n- [Redex](https://redex.github.io/) - Reason 包的索引","source":"source\\_posts\\reasonml-getting-started.md"},{"title":"OCaml 符号ReasonML 中的持久性 React Native Apps","created":"2018/05/28","description":"ReasonML 中的持久性 React Native Apps","author":"lanqy","link":"2018/05/28/persistence-in-reasonml-react-native-apps","htmlDir":"website\\2018\\05\\28\\persistence-in-reasonml-react-native-apps","htmlFile":"website\\2018\\05\\28\\persistence-in-reasonml-react-native-apps\\index.html","body":"# ReasonML 中的持久性 React Native Apps\r\n\r\n译自： https://jwheatley.co/persistence-in-reasonml-react-native-apps/\r\n\r\n> 让我们学习如何通过翻转 `switch` 来保持 ReasonML RN 应用程序中的状态！\r\n\r\n## 什么是ReasonML\r\n\r\nReasonML（或作为非SEO友好缩写的 Reason）是来自 Facebook 的开源项目，它使得 OCaml 易于用于 JS 开发人员。它通过为语言提供更友好的语法并提供与 JS 生态系统互操作性如黄油一样平滑的工具。\r\n\r\nOCaml 有一个超强的类型系统，它可以取代 Flow 或 TypeScript 提供的任何东西，而且 ReasonML 与工具捆绑在一起，可以替代几乎所有的工具来让 JS 每天都可以编写（ESlint→ReasonML / OCaml 类型系统 ，Flow / TS → ReasonML 语法，Prettier → refmt，JS / ES 模块捆绑器 → ReasonML / OCaml 模块，Babel → BuckleScript 等）。\r\n\r\nReasonML 受 Facebook 支持的重要之处在于它通过 ReasonReact 对 React 项目提供一流的支持，所以如果您厌倦了与 Flow 错误作斗争，并且仍然对 TypeScript 如何适应 React 生态系统感到困惑，那么您应该试一试 ReasonML！\r\n\r\n本指南旨在帮助您将状态持久性集成到您的ReasonML React Native 应用程序中，并促进为开发 ReasonReact 应用程序的人创建良好的脱机体验，而无需借助基于 JS 的状态管理解决方案（例如：Redux + Redux-Persist）。\r\n\r\n## 入门\r\n\r\n要开始编写 ReasonReact Native 应用程序，我建议您使用 `create-react-native-app` 路线：\r\n\r\n假设您已经安装了最新版本的 [Node.js](https://nodejs.org/en/)，请在终端中运行这些命令\r\n\r\n```ocaml\r\nnpm install -g create-react-native-app\r\n    create-react-native-app Switcheroo --scripts-version reason-react-native-scripts\r\n    cd Switcheroo\r\n    npm start\r\n    # 最好是，我会在前面的命令前加上`code。 &&`\r\n    # 在运行启动脚本之前在VS代码中打开它\r\n    # 以防止需要额外努力在编辑器中打开\r\n```\r\n\r\n然后，如 CRNA 文档（截至1/1/2018）所详述：\r\n\r\n> 在您的 iOS 或 Android 手机上安装 [Expo](https://expo.io/) 应用程序，并使用终端中的 QR 码打开您的应用程序。在应用程序的“项目”选项卡中查找 QR 扫描仪。\r\n\r\n## UI 脚手架\r\n\r\n现在我们已经启动了开发环境并运行了，现在是时候进入有趣的部分并编写一些代码了!\r\n\r\n对于初学者，您需要创建一个名为Switcheroo.re的新文件，该文件将位于App.re旁边的src文件夹中。这是我们将为我们的切换创建逻辑的地方。\r\n\r\n在这个文件中，我们为一个简单的 RN Switch 组件设置了基础，处理 [ReasonReact](https://reasonml.github.io/reason-react/docs/en/state-actions-reducer.html) 中提供的 `reducerComponent` 构件块的状态。\r\n\r\n```ocaml\r\n\r\n/* Switcheroo.re */\r\n\r\nopen BsReactNative;\r\n\r\ntype state = {toggled: bool};\r\n\r\ntype action = \r\n    | SetSwitchValue(bool);\r\n\r\nlet component = ReactReact.reducerComponent(\"Switcheroo);\r\n\r\nlet make = (_children) => {\r\n    ...component,\r\n    initialState: () => {toggled: false},\r\n    reducer: (action, _state) =>\r\n        switch action {\r\n            | SetSwitchValue(v) => ReasonReact.Update({toggled: v})\r\n        },\r\n    render: (self) =>\r\n        <Switch\r\n            value=self.state.toggled\r\n            onTintColor=\"#DD4C39\"\r\n            onValueChange=((value) => self.reduce(() => SetSwitchValue(value), ()))\r\n        />\r\n};\r\n\r\n```\r\n\r\n在App.re中，您可以用新编写的 Switcheroo 组件替换 View 的内部（下面的代码）。\r\n\r\n```ocaml\r\n\r\n/* App.re */\r\n\r\nopen BsReactNative;\r\n\r\nlet app = () => \r\n    <View style=Style.(style([flex(1.), justifyContent(Center), alignItems(Center)]))>\r\n        <Switcheroo />\r\n    </View>;\r\n```\r\n\r\n很好，我们有一个很酷的 `switch` ，我们可以来回切换，但是为什么当我重新打开应用程序的时候，它不会保持开启? 哦，是的，我们忘记了在本地保存状态;让我们去做吧!\r\n\r\n## 持久性\r\n\r\n要在 React Native中 保持状态，您必须使用 AsyncStorage 模块。这使您可以将序列化数据设置为长期数据存储并在以后检索它，即使应用程序已关闭并由用户重新启动，也可使应用程序停留在其数据上。\r\n\r\n上一节中的关键词是“序列化”，这意味着您的数据必须转换为字符串格式才能保存并从字符串中恢复并解析回实时数据结构以在您的应用中使用它。\r\n\r\n为了在 ReasonML 中做到这一点，我们需要调用 bs-json 的强大功能，它为使用 JSON 结构提供帮助。\r\n\r\n- 首先，您需要运行 `npm i -S bs-json` 来安装软件包。\r\n- 接下来，将它添加到你的 bsconfig.json 的 bs-dependencies 数组中。\r\n- 当你在它的时候，改变你的 bsconfig.json 的名字道具为 “Switcheroo”。\r\n\r\n完成后，bsconfig.json（支持 ReasonML 开发的 BuckleScript 工具链的配置文件）应如下所示：\r\n\r\n```json\r\n{\r\n  \"name\": \"Switcheroo\",\r\n  \"reason\": {\r\n    \"react-jsx\": 2\r\n  },\r\n  \"bsc-flags\": [\"-bs-super-errors\"],\r\n  \"bs-dependencies\": [\"bs-react-native\", \"reason-react\", \"bs-json\"],\r\n  \"sources\": [\r\n    {\r\n      \"dir\": \"src\"\r\n    }\r\n  ],\r\n  \"refmt\": 3\r\n}\r\n```\r\n\r\n现在，让我们支撑我们的持久性函数，并将其设置为在组件更新状态时运行。\r\n\r\n```ocaml\r\nopen BsReactNative;\r\ntype state = {toggled: bool};\r\ntype action =\r\n  | SetSwitchValue(bool);\r\nlet persist = state => {\r\n  /* convert state to JSON */\r\n  /* set it in RN's AsyncStorage */\r\n  ()\r\n};\r\nlet component = ReasonReact.reducerComponent(\"Switcheroo\");\r\nlet make = (_children) => {\r\n  ...component,\r\n  initialState: () => {toggled: false},\r\n  reducer: (action, _state) =>\r\n    switch action {\r\n    | SetSwitchValue(v) => ReasonReact.Update({toggled: v})\r\n    },\r\n  didUpdate: ({newSelf}) => persist(newSelf.state),\r\n  render: (self) =>\r\n    <Switch\r\n      value=self.state.toggled\r\n      onTintColor=\"#DD4C39\"\r\n      onValueChange=((value) => self.reduce(() => SetSwitchValue(value), ()))\r\n    />\r\n};\r\n```\r\n\r\n在这个函数中，我们需要使用 bs-json 将我们的状态编码为 JSON 并将其设置为我们的 AsyncStorage 位置，即 “Switcheroo.state”。\r\n\r\n```ocaml\r\n/* Switcheroo.re (partial) */\r\nlet persist = (state) => {\r\n  /* convert state to JSON */\r\n  let stateAsJson =\r\n    Json.Encode.(object_([(\"toggled\", Js.Json.boolean(Js.Boolean.to_js_boolean(state.toggled)))]))\r\n    |> Js.Json.stringify;\r\n  /* set it in RN's AsyncStorage */\r\n  AsyncStorage.setItem(\r\n    \"Switcheroo.state\",\r\n    stateAsJson,\r\n    ~callback=\r\n      (e) =>\r\n        switch e {\r\n        | None => ()\r\n        | Some(err) => Js.log(err)\r\n        },\r\n    ()\r\n  )\r\n  |> ignore\r\n};\r\n```\r\n\r\n所以，现在，如果您现在查看您的应用程序并翻转开关几次，您会发现没有任何问题（这太棒了！），但是当您刷新应用程序时，您会注意到您的应用程序仍然没有正常工作，捡起它离开的地方。\r\n\r\n## Re-hydration（美化或优化）\r\n\r\n为了重新维护我们的状态，我们需要：\r\n\r\n- 创建一个 re-hydrate `action` 来更新我们 reducerComponent 的状态\r\n- 创建一个 rehydrate 函数，从 AsyncStorage 中检索 JSON 并将其解码为一个 ReasonML 记录\r\n- 设置 Switcheroo 组件在组件激活时调用我们的 Rehydrate 函数\r\n\r\n满足上述步骤的代码在这里：\r\n\r\n```ocaml\r\n/* Switcheroo.re */\r\nopen BsReactNative;\r\nlet storageKey = \"Switcheroo.state\";\r\ntype state = {toggled: bool};\r\ntype action =\r\n  | SetSwitchValue(bool)\r\n  | Rehydrate(state);\r\nlet persist = (state) => {\r\n  /* convert state to JSON */\r\n  let stateAsJson =\r\n    Json.Encode.(object_([(\"toggled\", Js.Json.boolean(Js.Boolean.to_js_boolean(state.toggled)))]))\r\n    |> Js.Json.stringify;\r\n  /* set it in RN's AsyncStorage */\r\n  AsyncStorage.setItem(\r\n    storageKey,\r\n    stateAsJson,\r\n    ~callback=\r\n      (e) =>\r\n        switch e {\r\n        | None => ()\r\n        | Some(err) => Js.log(err)\r\n        },\r\n    ()\r\n  )\r\n  |> ignore\r\n};\r\nlet rehydrate = (self) => {\r\n  Js.Promise.(\r\n    /* begin call to AsyncStorage */\r\n    AsyncStorage.getItem(storageKey, ())\r\n    |> then_(\r\n          (json) =>\r\n            (\r\n              switch json {\r\n              | None => ()\r\n              | Some(s) =>\r\n                /* parse JSON, decode it into a ReasonML Record, and reset the state */\r\n                let parsedJson = Js.Json.parseExn(s);\r\n                let state = Json.Decode.{toggled: parsedJson |> field(\"toggled\", bool)};\r\n                self.ReasonReact.reduce(() => Rehydrate(state), ());\r\n                ()\r\n              }\r\n            )\r\n            |> resolve\r\n        )\r\n    |> ignore\r\n  );\r\n  ReasonReact.NoUpdate\r\n};\r\nlet component = ReasonReact.reducerComponent(\"Switcheroo\");\r\nlet make = (_children) => {\r\n  ...component,\r\n  initialState: () => {toggled: false},\r\n  reducer: (action, _state) =>\r\n    switch action {\r\n    | SetSwitchValue(v) => ReasonReact.Update({toggled: v})\r\n    | Rehydrate(s) => ReasonReact.Update(s)\r\n    },\r\n  didUpdate: ({newSelf}) => persist(newSelf.state),\r\n  didMount: (self) => rehydrate(self),\r\n  render: (self) =>\r\n    <Switch\r\n      value=self.state.toggled\r\n      onTintColor=\"#DD4C39\"\r\n      onValueChange=((value) => self.reduce(() => SetSwitchValue(value), ()))\r\n    />\r\n};\r\n```\r\n\r\n现在，你应该有一个很酷的小应用程序，让你切换一个 ReasonML 主题的开关并保持它的状态。甜！\r\n\r\n有关 ReasonML 中持久化和重新保持 JSON 状态的更复杂示例，请查看我为我的个人健身追踪器编写的代码。\r\n\r\n我希望你从这篇文章中学到了很多东西，并在阅读时享受自己的乐趣！ 欲了解更多内容，你可以在 [Twitter](https://twitter.com/FiberJW) 上关注我！ 这是与我联系并了解我正在做的新事情，我正在探索的新想法或正在学习的新技术的最简单的地方！\r\n\r\n祝你有个好的一天！\r\n\r\n—--- Juwan","source":"source\\_posts\\persistence-in-reasonml-react-native-apps.md"},{"title":"在 ReasonReact中解码 JSON","description":"在 ReasonReact中解码 JSON","created":"2018/05/28","author":"lanqy","link":"2018/05/28/decoding-json-in-reasonreact","htmlDir":"website\\2018\\05\\28\\decoding-json-in-reasonreact","htmlFile":"website\\2018\\05\\28\\decoding-json-in-reasonreact\\index.html","body":"# 在 ReasonReact中解码 JSON\r\n\r\n译自：https://medium.com/@idkjs/decoding-json-in-reasonreact-cff3a07c1200\r\n\r\n![在ReasonReact中解码JSON](/images/1_OizIr4Tc2m6lCGdr9478ew.png)\r\n\r\nReason 是一种新的来自 Facebook 的静态类型函数编程语言，可以编译为 Javascript。ReasonReact 是 React 的一个包装器，可以很容易地在 Reason 中使用。\r\n\r\n我们将构建一个小型单页网络应用程序，通过其步伐放置 Reason React。该应用将显示与 Reason 相关的最佳 Github repos 列表。这是一个足够小的任务，我们可以在几个小时内完成它，但是它也有足够的复杂性使我们可以开始厌倦这种新语言。本教程预期不存在 Reason 的现有知识，但对静态类型的基本熟悉会有所帮助。\r\n\r\n## 一个新项目\r\n\r\n我们将使用使用 `create-react-app` 的 `reason-scripts`，这将为我们的应用程序创建一个起点，该应用程序将被称为 `decode-json`：\r\n\r\n```ocaml\r\nyarn create react-app decoding-reason --script-version reason-scripts\r\n```\r\n通过运行 `yarn start` 来启动项目,在浏览器中打开 `https://localhost:3000`。\r\n\r\n## 记录类型\r\n\r\n我们将解码来自此Github API请求的公共数据的响应：https://api.github.com/search/repositories?q=topic%3Areasonml&type=Repositories 但首先可以使用假数据进行设置。\r\n\r\n创建一个名为 `RepoData.re` 的新文件并将其添加到其中。\r\n\r\n```ocaml\r\ntype repo = {\r\n    full_name: string,\r\n    stargazers_count: int,\r\n    html_url: string\r\n};\r\n```\r\n\r\n## 文件既是模块\r\n\r\n我们已经在文件的顶层定义了我们的类型。\r\n\r\n> 顶层基本上意味着视觉上，没有缩进（非常糟糕的解释方式，但你明白了）。`let foo = 1`不嵌套在其他任何内容中都是顶级的。`let foo = 1`在一个函数体内时，则不是顶层。[@chenglou](https://reasonml.chat/t/bucklescript-top-level-declarations/399/3?u=idkjs)\r\n\r\n在 Reason 中，每个文件都是一个模块，并且使用关键字 `let`，`type` 和 `module` 在文件顶层定义的所有东西都暴露在其他文件（即其他模块）中使用。在这种情况下，其他模块可以将我们的 repo 类型引用为 RepoData.repo。与 Javascript 不同，不需要导入来引用其他模块的东西。\r\n\r\n让我们在 `app.re` 中使用我们的类型。repos 页面只是 repos 列表，列表中的每个项目都包含 repos 名称（链接到 Github 上的 repos）以及 repos 的 stars 数量。我们将定义一些虚拟数据，并在 `App.re` 中绘制一个名为 RepoItem 的新组件来表示 repos 列表中的项目：\r\n\r\n```ocaml\r\n// App.re\r\nlet component = ReasonReact.statelessComponent(\"App\");\r\n\r\nlet make = (_children) => {\r\n    ...component,\r\n    render:(_self) => {\r\n        /* our dummy data */\r\n        let dummyRepo: RepoData.repo = {\r\n            stargazers_count: 27,\r\n            full_name: \"jsdf/reason-react-hacker-news\",\r\n            html_url: \"https://github.com/jsdf/reason-react-hacker-news\"\r\n        };\r\n\r\n        <div className=\"App\">\r\n            <h1>{ReasonReact.stringToElement(\"Reason Projects\")}</h1>\r\n            <RepoItem repo=dummyRepo />\r\n        </div>\r\n    }\r\n};\r\n\r\n```\r\n\r\n在声明开始 `let dummyRepo: RepoData.repo = {...}`，`dummyRepo` 是我们正在定义的常量的名称， `RepoData.repo` 是我们注释它的类型，它来自我们在其中定义它的位置 `RepoData.re`。请记住，该模块在项目的任何地方都可用。Reason 可以推断出我们声明的大部分事物的类型，但是在这里包含注释是很有用的，这样类型分析者可以告诉我们我们的测试数据是否犯了错误。\r\n\r\n## Reason 中的返回值\r\n\r\n请注意，渲染函数的主体现在包含在 `{}` 括号中，因为它包含多个语句。在 Javascript 中，如果我们在 `=>` 箭头函数的主体周围使用大括号，我们需要添加一个返回语句来返回一个值。然而在 Reason 中，函数返回最后一条语句产生的值，这里：\r\n\r\n```ocaml\r\n···\r\n<div className=\"App\">\r\n    <h1>{ReasonReact.stringToElement(\"Reason Projects\")}</h1>\r\n    <RepoItem repo=dummyRepo />\r\n</div>\r\n```\r\n\r\n自动成为返回值。如果你不想从函数返回任何东西，你可以创建最后一个语句 ()（在 [Reason](https://reasonml.github.io/docs/en/function.html#optional-labeled-arguments) 中称为 “unit”）。\r\n\r\n## 在 ReasonReact 中定义组件\r\n\r\n你现在可能会看到一个错误提示，说 RepoItem 文件或模块没有找到。这是因为我们在App组件渲染函数中添加了 `<RepoItem repo=dummyRepo />`，但是我们还没有创建该模块。添加一个名为 `RepoItem.re` 的新文件，包含：\r\n\r\n```ocaml\r\nlet component = ReasonReact.statelessComponent(\"RepoItem\");\r\n\r\nlet make = (~repo: RepoData.repo, _children) => \r\n{\r\n    ...component,\r\n    render: (_self) =>\r\n    <div>{ReasonReact.string(repo.full_name)}</div>\r\n};\r\n```\r\n这里发生了什么？让我们来剖析这个文件中发生了什么。\r\n\r\n每个 Reason React 组件都是一个 Reason 模块，它定义了一个名为 make 的函数，它定义了 props 和 children 参数。props 被指定为[标签参数](https://reasonml.github.io/docs/en/function.html#labeled-arguments)。\r\n\r\n```ocaml\r\nlet compoent = ReasonReact.statelessComponent(\"SomeComponent\");\r\n\r\nlet make = (~someProp, ~anotherProp, _children) => /* some stuff here */;\r\n```\r\n\r\n`make` 函数返回一条记录。此记录中的第一件事通常是 `...component`，其中 `component` 是`ReasonReact.reducerComponent` 或 `ReasonReact.statelessComponent` 的返回值（对于分别使用状态和不使用状态的组件）。如果这看起来有点奇怪，可以把它看作是从 React组件类继承的，就像做 Foo 类的扩展等同于在ReactJS中扩展 `class Foo extends React.Component {...` 一样。\r\n\r\n```ocaml\r\n// RepoItem.re\r\nlet component = ReasonReact.statelessComponent(\"RepoItem\");\r\n\r\nlet make = (~someProp, ~anotherProp, _children) => \r\n    {\r\n        ...component,\r\n        /* render and lifecycle methods go here */\r\n    };\r\n\r\n\r\n```\r\n\r\n记录的其余部分是您可以从 React 中添加渲染函数和您习惯使用的生命周期方法的位置。\r\n\r\n因此，回到 `RepoItem.re`：\r\n\r\n```ocaml\r\nlet compoent = ReasonReact.statelessComponent(\"RepoItem\");\r\n\r\nlet make = (~repo: RepoData.repo, _children) =>\r\n    {\r\n        ...component,\r\n        render: (_self) =>\r\n        <div>{ReasonReact.stringToElement(repo.full_name)}</div>\r\n    }\r\n\r\n```\r\n\r\n我们这里有一个 `stateless component` (无状态的组件)，它接受一个名为repo的属性（注解 RepoData 模块中的类型回购），并渲染一个 div。\r\n\r\n在ReactJS中，你可以使用 this.props 来访问render方法中的组件的属性。在 ReasonReact 中，我们接收属性作为 make 函数的标签参数，我们可以直接在渲染函数中使用它们（就像我们正在访问上面的 repos 属性的 full_name 字段一样）。\r\n\r\nmake 函数也会传递一个 children 参数，但我们并没有在这个组件中使用子元素，所以我们在 _children 参数名称的开始处放置了一个 _ 下划线。这只是让 Reason 知道我们并没有真正使用这个参数。尽管我们没有使用这个参数，但它仍然需要包含在函数参数中，否则会出错。\r\n\r\n接下来，我们将充实渲染函数以呈现 repos 记录的字段：\r\n\r\n```ocaml\r\nlet component = ReasonReact.statelessComponent(\"RepoItem\");\r\n\r\nlet make = (~repo: RepoData.repo, _children) =>\r\n    {\r\n        ...component,\r\n        render: (_self) =>\r\n            <div className=\"RepoItem\">\r\n                <a href=repo.html_url>\r\n                    <h2>{ReasonReact.string(repo.full_name)}</h2>\r\n                </a>\r\n                {ReasonReact.string(string_of_int(repo.stargazers_count) ++ \" stars\")}\r\n            </div>\r\n    };\r\n```\r\n\r\n请注意，我们必须使用 string_of_int 函数将 repo.stargazers_count 的 int 值转换为一个字符串。然后我们使用++字符串连接运算符将它与字符串 “stars” 结合起来。\r\n\r\n现在是保存并查看浏览器进度的好时机。\r\n\r\n![1_rVw1dhPmkJ_cyT63uDbN0g](/images/1_rVw1dhPmkJ_cyT63uDbN0g.png)\r\n\r\n## 有状态的 React 组件又名 reducerComponent 和 Variants\r\n\r\n我们的应用程序将加载一些数据然后渲染它，这意味着我们需要一个地方来加载数据。 React 状态组件似乎是一个明显的选择。所以我们会让我们的应用组件成为有状态的。我们通过将 `ReasonReact.statelessComponent` 更改为 `ReasonReact.reducerComponent` 来完成此操作。\r\n\r\n在 `App.re`：\r\n\r\n```ocaml\r\ntype state = {\r\n    repoData: option(RepoData.repo)\r\n};\r\n\r\n/* 我们的虚拟数据 */\r\n\r\nlet dummyRepo: RepoData.repo = {\r\n    stargazers_count: 27,\r\n    full_name: \"jsdf/reason-react-hacker-news\",\r\n    html_url: \"https://github.com/jsdf/reason-react-hacker-news\",\r\n};\r\n\r\nlet repoItem = (repoData: option(RepoData.repo)) =>\r\n    switch (repoData) {\r\n        | Some(repo) => <RepoItem repo />\r\n        | None => ReasonReact.string(\"Loading\")\r\n    };\r\n\r\nlet make = _children => {\r\n    ...component,\r\n    initialState: () => {\r\n        repoData: Some(dummyRepo)\r\n    },\r\n\r\n    reducer: ((), _) => ReasonReact.NoUpdate,\r\n\r\n    render: ({state:{repoData}}) =>\r\n        <div className=\"App\">\r\n            <h1> (ReasonReact.string(\"Decoding JSON in ReasonReact\")) </h1>\r\n            (repoItem(repoData))\r\n        </div>,\r\n};\r\n\r\n\r\n```\r\n\r\n我们改变了一些关键的东西：我们已经为使用 Reason 的内置 option Variant 类型的组件状态定义了一个类型。这里简单地称为 `state`，`ReasonReact.statelessComponent` 已经成为 `ReasonReact.reducerComponent`，我们已经为组件添加了一个 `initialState` 函数，并且我们已经改变了渲染以将自身作为参数（删除 _ 下划线以便自 self 不再被忽略 ），现在正在使用 `{state：{repoData}` 作为 RepoItem 的属性。什么？！！以下语法称为解构。我们现在正在访问的 `self` 方法有一个 `state` 属性，并且使用 `{state:...}`我们说从上面的第22行开始使用它的状态。\r\n\r\n## 变体！选项\r\n\r\n我们将我们的 `state` 类型定义为：\r\n\r\n```ocaml\r\ntype state = {\r\n    repoData: option(RepoData.repo)\r\n};\r\n```\r\n\r\nReason 中 `option` 是由 “变体” 组成的类型。这基本上意味着这种类型的值可以是已经明确定义的几种可能变化中的一种。在 `option` 的情况下，变体是 `Some` 和 `None` 。`Some` 用于存在值（并且包含值本身），而 `None` 表示没有值（如 Javascript 中的 `null` ）。在这里，我们'包裹' dummyRepo  在 `Some` 变体中，因为我们有一个值。\r\n\r\n该 `option` 告诉我们（和编译器），该 `state` 可以是 `Some` 或 `None` 的任何值。所以当我们使用这种类型时会有 `Some(RepoData.repo)` 或 `None` 。\r\n\r\n那么为什么使用这个包装器，而不是让我们的 `repoData` 字段包含一个值或 null ？Reason 迫使我们在实际使用价值时处理两种可能的情况。这很好，因为这意味着我们不会意外忘记处理'null（空）'情况。请注意，在调用 `ReasonReact.reducerComponent` 之前，必须定义 `state` 类型，否则会出现类似“类型构造函数状态将脱离其作用域”的错误。我们将通过创建一个名为 `repoItem` 的变量来告诉组件在每种情况下应该做什么，并定义在类型状态下定义的变例中我们想要发生的事情。\r\n\r\n## 选项和模式匹配\r\n\r\n当我们定义组件的初始状态时，目前我们已经有了 `repoData` 伪数据，但是一旦我们从服务器加载它，它的初始值将为空。但是，在 Reason 中，您不能像记录 Javascript 那样只是将记录字段的值设为 `null`。相反，可能不存在的事物需要用称为 `option` 的另一种类型“包装”。我们可以改变我们的状态类型来表示如下：\r\n\r\n```ocaml\r\ntype state = {repoData: option(RepoData.repo)};\r\n```\r\n\r\n并且在我们的 `initialState` 函数中，我们将我们的 `repo` 记录包装在 `Some()` 中：\r\n\r\n```ocaml\r\ninitialState: () => {\r\n    repoData: Some(dummyRepo),\r\n}\r\n```\r\n\r\n在上面的代码中，我们使用 `Some` 和 `None` 变体来定义一个 `repoItem`，如果有一些数据，我们将这些数据传递给我们的 `<RepoItem />` 模块，并将它返回给我们组件中的 UI。如果没有数据，我们告诉该函数使用None选项，返回一个 `div `来呈现 “Loading” 到 UI。\r\n\r\n然后在渲染 `div` 中，我们传递当前的 `repoData` ，然后传递给 `renderItem` 函数来处理在每种情况下要做的操作 `Some` 或 `None` 。我们无法直接将 `state.repoData` 作为 `RepoItem` 的 `repo` 的属性，因为它被包装在一个 `option()` 中，但是 `RepoItem` 期待它没有选项包装。那么我们如何解开它呢？我们使用模式匹配。这是 `Reason` 用来涵盖所有可能的情况（或者至少明确地抛出错误）的地方。模式匹配使用 `switch` 语句。然而，与 Javascript 中的 `switch` 语句不同，reason 中的 `switch` 语句可以匹配值的类型（例如 `Some` 和 `None` ），而不仅仅是值本身。我们将改变我们的渲染方法，使用 `switch` 在每种可能的情况下提供逻辑来呈现我们的 `repo` 项目。我们可以通过创建一个函数 `renderItem` 来处理每个 `case` 并根据结果进行渲染。\r\n\r\n```ocaml\r\nrepoItem = (repoData: option(RepoData.repo)) => \r\n    switch (repoData) {\r\n        | Some(repo) => <RepoItem repo />\r\n        | None => ReasonReact.string(\"Loading\")\r\n    };\r\n```\r\n\r\n在这里你可以看到 `switch` 语句有一个 `case` 与 `state.repoData` 类型的 `Some` 类型匹配，并且将实际的 `repo` 记录提取到一个名为 `repo` 的变量中，然后它将它用在 => 右边的表达式中， 返回一个 <RepoItem> 元素。这个表达式只会在 `state.repoData` 是 `Some` 的情况下使用。或者，如果 `state.repoData` 为 `None`，则将显示文本 “Loading”。\r\n\r\n我们将在我们的 div 中调用 repoItem 并将它作为 repoData 解构的 state.repoData。\r\n\r\n```ocaml\r\nrender: ({state: {repoData}}) => \r\n    <div className=\"App\">\r\n        <h1> (ReasonReact.string(\"Decoding JSON in ReasonReact\")) </h1>\r\n        (repoItem(repoData))\r\n    </div>,\r\n```\r\n\r\n如果您运行 `yarn start` 开始，您应该在浏览器中看到与以前相同的输出：\r\n\r\n![1_rVw1dhPmkJ_cyT63uDbN0g](/images/1_rVw1dhPmkJ_cyT63uDbN0g.png)\r\n\r\n## Reducer Components\r\n\r\n那么，为什么 Reason React 中的有状态组件类型称为 reducerComponent ？与 ReactJS 相比，ReasonReact 处理组件状态更改的方式略有不同。如果你已经使用 [Redux](https://redux.js.org/) ，它会看起来很熟悉。如果你还没有，不要担心，这里不需要背景知识。\r\n\r\n基本上，不是像 onClick 那样在事件处理程序中做一堆事情然后调用 `this.setState` ，我们只需要知道我们想要对组件状态做出什么样的改变，然后调用 `self.send` 一个“ `action` ”，它只是一个表示应该发生的状态更改的值，以及我们需要更改的任何信息。这意味着大部分状态变化代码都可以用纯函数隔离，这使得它更容易跟踪，并且更容易编写测试。\r\n\r\n我们可以尝试通过这种方式进行状态更改，方法是首先将 `state` 设置为 `None` ，然后在用户单击按钮后更改状态。这是一个人为的例子，但它对说明状态变化很有用。点击此按钮后，假设我们正在从API加载数据:)。\r\n\r\n首先，我们需要添加一个名为 `action` 的类型，它列举了可能发生在我们组件中的各种可能的状态变化。现在只有一个：`Loaded`，用于加载 repo 数据时：\r\n\r\n```ocaml\r\ntype action = \r\n    | Loaded(RepoData.repo);\r\n```\r\n\r\n之后，我们添加一个 `reducer` 方法，它接受一个这样的动作和当前状态，然后计算并返回更新的状态：\r\n\r\n```ocaml\r\nreducer = (action, _state) => \r\n    switch (action) {\r\n        | Loaded(loadedRepo) =>\r\n            ReasonReact.Update({\r\n                repoData: Some(loadedRepo)\r\n            })\r\n    };\r\n```\r\n\r\n您可以看到，我们的实现是对动作类型进行模式匹配并返回包含新状态的 `ReasonReact.Update`。现在我们只是为 `Loaded` 行动提供一个案例，但在未来，我们可以想象在这里实施其他类型的状态更改，以响应不同的 `action` 变体。\r\n\r\n接下来我们更改 `initialState` ，以无 repo 数据开始：\r\n\r\n```ocaml\r\ninitialState: () => {\r\n    repoData: None\r\n},\r\n```\r\n\r\n最后，我们在渲染函数中添加一个按钮元素。我们使用 `self.send` 方法添加到我们的解构对象中，为按钮的 `onClick` `prop` 创建一个处理函数。\r\n\r\n`send` 采取点击事件调用我们想要使用的动作和它期望的任何值。在这里，`send(Loaded(dummyRepo))`，将点击转换为我们 `reducer` 的动作。像这样的处理程序也可以使用来自 `click` 事件对象的信息，但在这种情况下我们不需要它，所以我们把下划线 `_` 放在它之前忽略它。我们可以创建这样一个按钮：\r\n\r\n```ocaml\r\n<button onClick=(_event => send(Loaded(dummyRepo)))>\r\n    (ReasonReact.string(\"Load Repos\"))\r\n</button>\r\n```\r\n\r\n我们可以显示一条消息，在初始空白状态下（当 `state.repoData` 为 `None` 时）点击按钮来代替呈现的 `RepoItem` ：\r\n\r\n```ocaml\r\nrepoItem = (repoData: option(RepoData.repo)) => \r\n    switch (repoData) {\r\n        | Some(repo) => <RepoItem repo />\r\n        | None => ReasonReact.string(\"Click Button To Load\")\r\n    };\r\n```\r\n\r\n与在 JS React 中调用 `setState` 相比，使用 `action` 和 `reducer` 的额外步骤似乎过于复杂，但随着有状态组件的增长并具有更多可能的状态（它们之间可能存在越来越多的转换），组件很容易成为难以跟踪和无法测试的纠结。 这是 `action-reducer` 模型真正闪耀的地方。\r\n\r\n您可以在 [render-button-detour](https://github.com/idkjs/decoding-json-in-reason-react/tree/render-button-detour) 附带的 repo 中看到此版本的代码。\r\n\r\n好，现在我们知道如何进行状态更改，让我们把它变成一个更现实的应用程序。\r\n\r\n## 使用数组与单个 Repo\r\n\r\n在我们从 JSON 加载数据之前，还需要对组件进行一次更改。我们实际上想要显示 repo 列表，而不仅仅是一个清单，所以我们需要改变我们的状态类型：\r\n\r\n```ocaml\r\ntype state = {\r\n    repoData: option(array(RepoData.repo))\r\n};\r\n```\r\n并对我们的虚拟数据进行相应的更改：\r\n\r\n```ocaml\r\ndummyRepos: array(RepoData.repo) = [|\r\n  {\r\n    stargazers_count: 27,\r\n    full_name: \"jsdf/reason-react-hacker-news\",\r\n    html_url: \"https://github.com/jsdf/reason-react-hacker-news\"\r\n  },\r\n  {\r\n    stargazers_count: 93,\r\n    full_name: \"reasonml/reason-tools\",\r\n    html_url: \"https://github.com/reasonml/reason-tools\"\r\n  }\r\n|];\r\n```\r\n\r\n呃，`[| ... |]` 语法？这是 Reason 的数组字面量语法。如果你没有 `|` 管道字符（所以它看起来像正常的 JS 数组语法），那么你会定义一个 `List` 而不是一个数组。在 Reason 中列表是不可变的，而数组是可变的（如 Javascript 数组），但是如果处理可变数量的元素，则列表更容易处理。无论如何，我们正在使用一个数组。\r\n\r\n我们需要查看代码并将所有引用 `repoData`  的地方都改为 `RepoData.repo`，而不是指定 `array(RepoData.repo)`。\r\n\r\n最后，通过映射 `repos` 数组并为每个 `RepoItem` 创建一个 `<RepoItem />`，我们将改变渲染方法来渲染一个 `RepoItem` 数组而不是一个。 我们必须使用 `ReasonReact.array` 将元素数组转换为元素本身，以便它可以在下面的 JSX 中使用。\r\n\r\n\r\n```ocaml\r\nrepoItems = (repoData: option(array(RepoData.repo))) =>\r\n    switch (repoData) {\r\n        | Some(repo) =>\r\n            ReasonReact.array(\r\n                Array.map(\r\n                    (repo: RepoData.repo) => <RepoItem key=repo.full_name repo />,\r\n                    repos,\r\n                ),\r\n            )\r\n        | None => ReasonReact.string(\"Loading\")\r\n    };\r\n\r\nlet make = _children => {\r\n    ...component,\r\n\r\n    initialState: () => {\r\n        repoData: Some(dummyRepos)\r\n    },\r\n\r\n    reducer: ((), _) => ReasonReact.NoUpdate,\r\n\r\n    render: ({state: {repoData}}) =>\r\n        <div className=\"App\">\r\n            <h1> (ReasonReact.string(\"Decoding JSON in ReasonReact\")) </h1>\r\n            (repoItems(repoData))\r\n        </div>,\r\n};\r\n```\r\n\r\n我在 `repo` 中标记了代码的各个部分。所以在这一点上，你可以检查 [`setting-up-arrays tag`](https://github.com/idkjs/decoding-json-in-reason-react/tree/setting-up-arrays)。\r\n\r\n现在，加载一些真实的数据。\r\n\r\n## BuckleScript\r\n\r\n在获取我们的 JSON 并将其转换为记录之前，首先我们需要安装一些额外的依赖关系。运行：\r\n\r\n```ocaml\r\nnpm install --save bs-fetch @glennsl/bs-json\r\n```\r\n或者\r\n\r\n```ocaml\r\nyarn add bs-fetch @glennsl/bs-json\r\n```\r\n\r\n以下是这些包的作用：[`bs-fetch`](https://github.com/reasonml-community/bs-fetch)：包装浏览器获取 API，以便我们可以从 Reason [`@glennsl/bs-json`](https://github.com/glennsl/bs-json) 中使用它：允许使用将从服务器获取的 JSON 转换为 Reason 记录。\r\n\r\n这些包与我们一直使用的 Reason-to-JS 编译器一起工作，这就是所谓的 [BuckleScript](https://bucklescript.github.io/) 。\r\n\r\n在我们可以使用这些新安装的 BuckleScript 包之前，我们需要让 BuckleScript 知道它们。为此，我们需要对项目根目录下的 `.bsconfig` 文件进行一些更改。在 `bs-dependencies` 部分中，添加 `bs-fetch` 和 `bs-json`：\r\n\r\n```ocaml\r\n{\r\n\"name\": \"reason-scripts\",\r\n\"sources\": [\"src\"],\r\n\"bs-dependencies\": [\r\n    \"reason-react\",\r\n    \"bs-jest\",\"bs-fetch\", // add this\r\n    \"@glennsl/bs-json\" // and this too\r\n],\r\n// ...more stuff\r\n```\r\n\r\n您需要终止并重新启动 `yarn start` / `npm start` 命令，以便构建系统可以获取对 `.bsconfig` 的更改。\r\n\r\n## 读取 JSON\r\n\r\n现在我们已经安装了 `bs-json`，我们可以使用 `Json.Decode` 来读取 JSON 并将其转化为记录。\r\n\r\n我们将在 `RepoData.re` 的末尾定义一个名为 `parseRepoJson` 的函数：\r\n\r\n```ocaml\r\n// RepoData.re\r\n\r\ntype repo = {\r\n    full_name: string,\r\n    stargazers_count: int,\r\n    html_url: string\r\n};\r\n\r\nlet parseRepoJson = (json: Js.Json.t): repo => {\r\n    full_name: Json.Decode.field(\"full_name\", Json.Decode.string, json),\r\n    stargazers_count: Json.Decode.field(\"stargazers_count\", Json.Decode.int, json),\r\n    html_url: Json.Decode.field(\"html_url\", Json.Decode.string, json)\r\n}\r\n\r\n```\r\n\r\n我们定义了一个名为 `parseRepoJson` 的函数，它接受一个名为 `json` 的参数并返回 `RepoData.repo` 类型的值。`Json.Decode` 模块提供了一组函数，我们将它们组合在一起来提取 JSON 的字段，并确保我们得到的值是正确的类型。\r\n\r\n## 不要重复自己\r\n\r\n这看起来有点罗嗦。我们是否真的必须一遍又一遍地写 `Json.Decode` ？\r\n\r\n不，Reason 有一些方便的语法来帮助我们，当我们需要一次又一次地引用特定模块的输出时。一种选择是“打开”模块，这意味着它的所有输出在当前作用域都可用，所以我们可以抛弃 `Json.Decode` 限定符：\r\n\r\n```ocaml\r\nJson.Decode;\r\n\r\nlet parseRepoJson = (json: repo) =>\r\n{\r\n    full_name: field(\"full_name\", string, json),\r\n    stargazers_count: field(\"stargazers\", int, json),\r\n    html_url: field(\"html_url\", string, json)\r\n};\r\n\r\n```\r\n\r\n但是，如果打开多个模块，这会引起名称冲突的风险。另一种选择是使用模块名称，后跟一个句点`.`在表达之前。在表达式内部，我们可以使用模块的任何导出，而不用模块名称进行限定：\r\n\r\n```ocaml\r\nlet parseRepoJson = (json: Js.Json.t): repo =>\r\nJson.Decode.{\r\n    full_name: field(\"full_name\", string, json),\r\n    stargazers_count: field(\"stargazers_count\", int, json),\r\n    html_url: field(\"html_url\", string, json),\r\n};\r\n```\r\n\r\n注意 `(json: Js.Json.t):repo`。在这里，我们输入预期的 json 值作为 `Js.Json.t`，也就是说传入的 `repo` `json` 类型必须是(json:Js.Json.t)。请参阅 [@nikgraf](https://twitter.com/@nikgraf) 的 [egghead系列 Reason 类型参数视频](https://egghead.io/lessons/reason-type-parameters-in-reason) 以了解更多信息。事实上，如果你对Reason感兴趣并且没有看过，现在就去看看，然后再回来。然后每周观看一次，直到你找到它。每次你都会学到一些东西。\r\n\r\n现在让我们通过添加一些代码来测试它，该代码定义了一个 JSON 字符串并使用我们的 `parseRepoJson` 函数来解析它。\r\n\r\n在app.re中：\r\n\r\n```ocaml\r\ndummyRepos: array(RepoData.repo) = [|\r\n    RepoData.parseRepoJson(\r\n        Js.Json.parseExn(\r\n            {js|\r\n                {\r\n                    \"stargazers_count\": 93,\r\n                    \"full_name\": \"reasonml/reason-tools\",\r\n                    \"html_url\": \"https://github.com/reasonml/reason-tools\"\r\n                }\r\n            |js}\r\n        )\r\n    )\r\n|];\r\n```\r\n\r\n不要担心理解什么 `Js.Json.parseExn` 或奇怪的 `{js | ... | js}` 的东西（这是一个可选的[字符串字面量语法](https://bucklescript.github.io/bucklescript/Manual.html#_bucklescript_annotations_for_unicode_and_js_ffi_support)）。返回到浏览器，您应该看到从该 JSON 输入成功呈现页面。\r\n\r\n![1_vJeQUw9FWZBb2lK_muJnaQ.png](/images/1_vJeQUw9FWZBb2lK_muJnaQ.png)\r\n\r\n请参阅 repo 标签 [bs-json-parsing](https://github.com/idkjs/decoding-json-in-reason-react/tree/bs-json-parsing)。\r\n\r\n## 获取数据\r\n\r\n请参阅 [fetching-data](https://github.com/idkjs/decoding-json-in-reason-react/tree/fetching-data)\r\n\r\n查看 [Github API 响应](https://api.github.com/search/repositories?q=topic%3Areasonml&type=Repositories)的形式，我们对items 字段感兴趣。\r\n\r\n![1_Tc7TgXVmGv4i_xt4Lz4dxA.png](/images/1_Tc7TgXVmGv4i_xt4Lz4dxA.png)\r\n\r\n该字段包含一个 repos 数组。我们将添加另一个函数，它使用我们的 `parseRepoJson` 函数将 items 字段解析为一个记录数组。\r\n\r\n在 `RepoData.re`中：\r\n\r\n```ocaml\r\nparseReposResponseJson = json => \r\n    Json.Decode.field(\"items\", Json.Decode.array(parseRepoJson), json);\r\n```\r\n\r\n最后，我们将使用 `bs-fetch` 包来向 API 发送 HTTP 请求。\r\n\r\n但首先，更多的新语法！我保证这是最后一点。管道运算符 `|>` 只是将 `|>` 运算符左边的表达式的结果取出来，并使用该值调用 `|>` 运算符右边的函数。\r\n\r\n例如，以下代码：\r\n\r\n```ocaml\r\n(doThing3(doThing2(doThing1(arg))));\r\n```\r\n\r\n通过管道运算符，我们可以做到：\r\n\r\n```ocaml\r\narg |> doThing1 |> doThing2 |> doThing3\r\n```\r\n\r\n\r\n这让我们可以模拟类似 Javascript 中的 Promises 的链式 API ，不同之处在于 `Js.Promise.then_` 是我们用 promise 作为参数调用的函数，而不是 promise 对象上的方法。\r\n\r\n在 `RepoData.re` 中：\r\n\r\n```ocaml\r\n\r\nlet reposUrl = \"https://api.github.com/search/repositories?q=topic%3Areasonml&type=Repositories\";\r\n\r\nlet fetchRepos = () => {\r\n    Fetch.fetch(reposUrl)\r\n    |> Js.Promise.then_(Fetch.Response.text)\r\n    |> Js.Promise.then_(\r\n        jsonText =>\r\n            Js.Promise.resolve(parseReposResponseJson(Js.Json.parseExn(jsonText)))\r\n    );\r\n}\r\n\r\n```\r\n\r\n我们可以通过暂时打开 `Js.Promise` 来使 Promise 链式 `fetchRepos` 更简洁：\r\n\r\n```ocaml\r\nfetchRepos = () =>\r\n    Js.Promise.(\r\n        Fetch.fetch(reposUrl)\r\n        |> then_(Fetch.Response.text)\r\n        |> then_(\r\n            jsonText =>\r\n                resolve(parseReposResponseJson(Js.Json.parseExn(jsonText)))\r\n        )\r\n    );\r\n```\r\n\r\n最后，回到 `App.re` 中，我们将添加一些代码来加载数据并将其存储在组件状态中：\r\n\r\n```ocaml\r\ntype state = {\r\n    repoData: option(array(RepoData.repo))\r\n};\r\n\r\ntype action = \r\n    | Loaded(array(RepoData.repo));\r\n\r\nlet component = ReasonReact.reducerComponent(\"App\");\r\n\r\nlet dummyRepos: array(RepoData.repo) = [|\r\n    RepoData.parseRepoJson(\r\n        Js.Json.parseExn(\r\n            {js|\r\n                {\r\n                    \"stargazers_count\": 93,\r\n                    \"full_name\": \"reasonml/reason-tools\",\r\n                    \"html_url\": \"https://github.com/reasonml/reason-tools\"\r\n                }\r\n            |js},\r\n        ),\r\n    ),\r\n|];\r\n\r\nlet repoItems = (repoData: option(array(RepoData.repo))) =>\r\n    switch (repoData) {\r\n        | Some(repos) =>\r\n            ReasonReact.array(\r\n                Array.map(\r\n                    (repo: RepoData.repo) => <RepoItem key=repo.full_name repo />,\r\n                    repos,\r\n                ),\r\n            )\r\n        | None => ReasonReact.string(\"Loading\")\r\n    };\r\n\r\nlet reducer = (action, _state) => \r\n    switch (action) {\r\n        | Loaded(loadedRepo) => ReasonReact.Update({\r\n            repoData: Some(loadedRepo)\r\n        })\r\n    };\r\n\r\nlet make = _children => {\r\n    ...component,\r\n    initialState: () => {\r\n        repoData: None\r\n    },\r\n\r\n    didMount: self => {\r\n        let handleReposLoaded = repoData => self.send(Loaded(repoData));\r\n\r\n        RepoData.fetchRepos()\r\n        |> Js.Promise.then_(repoData => {\r\n                handleReposLoaded(repoData);\r\n                Js.Promise.resolve();\r\n            })\r\n        |> ignore;\r\n    },\r\n\r\n    reducer,\r\n\r\n    render: ({state: {repoData}}) =>\r\n        <div className=\"App\">\r\n            <h1> (ReasonReact.string(\"Decoding JSON in ReasonReact\")) </h1>\r\n            (repoItems(repoData))\r\n        </div>,\r\n};\r\n\r\n```\r\n\r\n首先我们实现 `didMount` 生命周期方法。我们使用 `self.send` 创建一个名为 `handleReposLoaded` 的函数来处理我们加载的数据并更新组件状态。我们将在我们的 `RepoData.fetchRepos()` 函数中调用它，并将它传递给期望的 `repoData` 值。 `handleReposLoaded` 然后将该值传递给 `self.send`，我们将它传递给定义的 `action` 类型。***self.send 与 `action` 类型一起使用以便使用它，请确保您已经定义了要使用它的 `action` 。*** 因此，使用我们的 `RepoData.fetchRepos()` 函数，我们加载数据。就像 Javascript中的链式 Promise ，我们将其传递到 `Js.Promise.then_` 中，在那里我们用加载的数据调用 `handleReposLoaded` 函数，更新组件状态。\r\n\r\n我们通过返回 `Js.Promise.resolve()` 来结束 promise 链。定义 promise 链的整个表达式然后 `|>` 传送到一个称为 `ignore` 的特殊函数，它只是告诉 Reason 我们不打算对 promise 链表达式计算的值做任何事情（我们只关心副作用 它具有调用更新函数的功能）。\r\n\r\n这就是它在浏览器中的样子：\r\n\r\n![1_lYil0QkDtiH1PQLDrXvg3g.png](/images/1_lYil0QkDtiH1PQLDrXvg3g.png)\r\n\r\n## 添加一些 CSS\r\n\r\n让我们回到 `index.re`。将此代码添加到文件的顶部：\r\n\r\n```ocaml\r\n[%bs.raw {|\r\nrequire('./index.css');\r\n|}];\r\n```\r\n\r\n这`%bs.raw` 的东西允许我们在 `{|` 和 `|}` 之间加入一些简单的 Javascript 代码。在这种情况下，我们只是使用它来以通常的 Webpack 方式包含一个 CSS 文件。保存后，您应该看到应用于应用的一些样式更改。您可以打开为我们制作的 `create-react-app` 的 `index.css` 文件，并根据您的内容定制样式。让我们添加一些 `margin`，以便 ui 不会被推到左侧。打开 `index.css` 并将其更改为：\r\n\r\n```ocaml\r\n{\r\n    margin:2em;\r\n    padding:0;\r\n    font-family: sans-serif;\r\n}\r\n```\r\n\r\n您还可以通过传递使用 [`ReactDOMRe.Style.make`](https://reasonml.github.io/reason-react/docs/en/style.html#docsNav) 创建的样式属性，在 React 组件中使用内联样式：\r\n\r\n```ocaml\r\nstyle={ReactDOMRe.Style.make(~color=\"red\", ~fontSize=\"68px\")()}\r\n```\r\n\r\n就是这样！\r\n\r\n你可以在[这里](https://decoding-json-in-reason-react.netlify.com/)看到完成的应用程序。完整的源代码在 [Github](https://github.com/idkjs/decoding-json-in-reason-react) 上可用。\r\n\r\n## 奖金：使用 Netlify 和 git 子树部署 Demo。\r\n\r\n然后 `yarn build` 生成以获得项目的生产版本。\r\n\r\n从项目的 `.gitignore` 文件中删除 `build` （它由 create-react-app 默认忽略）。\r\n\r\n将以下命令添加到 package.json 的脚本键值中：\r\n\r\n```ocaml\r\n...\r\n    \"deploy\": \"git subtree push --prefix build origin gh-pages\",\r\n...\r\n```\r\n\r\n确保 git 知道你的子树（你的网站的子文件夹）。运行：\r\n\r\n```ocaml\r\nadd build && git commit -m \"Initial dist subtree commit\"\r\n```\r\n\r\n运行 `yarn deploy`。\r\n\r\n如果没有，请注册 Netlify 。登录后，点击大蓝 “Git的新站点” 按钮。\r\n\r\n选择您的 repo，将目录更改为您的 gh-pages 目录，然后单击 “Deploy Site” 按钮。\r\n\r\n![1_UbMYnovAa1GUt0PYsO7x9A.png](/images/1_UbMYnovAa1GUt0PYsO7x9A.png)\r\n\r\n## 谢谢！\r\n\r\n如果您对本文有任何反馈，可以发推文给我：[@_idkjs](https://www.twitter.com/@_idkjs)。感谢 [@ur_friend_james](https://www.twitter.com/@ur_friend_james) 的原始帖子，可以在[这里](https://jamesfriend.com.au/a-first-reason-react-app-for-js-developers)找到。\r\n","source":"source\\_posts\\decoding-json-in-reasonreact.md"},{"title":"Webpack 给初学者","created":"2018/05/25","description":"Webpack 给初学者","author":"lanqy","link":"2018/05/25/webpack-for-beginners","htmlDir":"website\\2018\\05\\25\\webpack-for-beginners","htmlFile":"website\\2018\\05\\25\\webpack-for-beginners\\index.html","body":"# Webpack 给初学者\r\n### Webpack 是什么？\r\nWebpack是一个模块打包和压缩工具\r\n### 什么是模块打包？\r\n模块打包就是把多个Javascript文件打包和压缩成一个单独的Javascript文件\r\n### 怎样使用？\r\n开始创建一个项目\r\n```shell\r\n$ mkdir try-webpack && cd try-webpack && mkdir src && npm init -y\r\n$ touch index.html && touch src/main.js && touch webpack.config.js\r\n```\r\n如果你是Windows用户，可以通过<a href=\"https://git-scm.com/downloads\" target=\"_blank\">git bash</a>运行上面的命令。现在我们开始全局安装webpack:\r\n\r\n```javascript\r\n$ npm install -g webpack\r\n```\r\n\r\n我们通过一个简单的配置文件开始我们所有的前端项目，打开`webpack.config.js`文件，复制下面的代码粘贴到`webpack.config.js`中\r\n\r\n```javascript\r\nmodule.exports = {\r\n  devtool: 'cheap-module-eval-source-map',\r\n  entry: \"./src/main.js\",\r\n  output: {\r\n    path: __dirname + \"/dist\",\r\n    filename: \"bundle.js\"\r\n  }\r\n};\r\n```\r\n\r\n这个文件告诉webpack我们的应用入口点在哪里，以及在哪个目录输出打包后的代码，通过命令行运行`webpack`,在dist目录下就会生成bundle.js文件。到目前为止，我们到应用是相当无聊的，我是<a href=\"http://mithril.js.org/\" target=\"_blank\">Mithril.js</a>的忠实粉丝,因此我们通过<a href=\"http://mithril.js.org/\" target=\"_blank\">Mithril.js</a>来做一些东西，首先通过npm来安装这个库。\r\n\r\n```javascript\r\n$ npm install --save mithril\r\n```\r\n现在打开`src/main.js`输入如下代码：\r\n\r\n```javascript\r\nvar m = require('mithril');\r\n\r\nvar app = {\r\n  view: function() {\r\n    return m('div', 'hello world!')\r\n  }\r\n}\r\n\r\nm.mount(document.getElementById('app'), app)\r\n```\r\n打开index.html,输入如下代码（请记得引入打包后的bundle.js文件）:\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <title>Webpack Tutorial</title>\r\n</head>\r\n<body>\r\n  <div id=\"app\"></div>\r\n  <script src=\"dist/bundle.js\"></script>\r\n</body>\r\n</html>\r\n```\r\n接着通过命令行运行`webpack`生成新的包（bundle.js文件），现在在浏览器中打开index.html,你将看到`hello world!` 。\r\n如果你做到来这一步，那么恭喜你！你已经理解基本的webpack了。<br/>\r\n\r\n让我们来稍微重构一下我们的app，我们来本地化我们的应用程序，这个要求我们把所有文本放在一个集中的地方，创建一个新的文件`src/resources.json`,这个文件里包含如下的JSON：\r\n```json\r\n{\r\n  \"en-US\": {\r\n    \"HELLO_WORLD\": \"hello world!\"\r\n  }\r\n}\r\n```\r\n\r\n回到`src/main.js`文件，通过json文件加载我们的信息（修改该文件为)：\r\n\r\n```javascript\r\nvar m = require('mithril');\r\nvar resources = require('./resources.json')\r\n\r\nvar app = {\r\n  view: function() {\r\n    return m('div', resources['en-US'].HELLO_WORLD)\r\n  }\r\n}\r\n\r\nm.mount(document.getElementById('app'), app)\r\n```\r\n\r\n<br/>\r\n如果你迫不及待的想在命令行运行`webpack`，你将会看到类似于如下的错误信息\r\n\r\n```javascript\r\nERROR in ./src/main.js\r\nModule not found: Error: Cannot resolve 'file' or 'directory' ./resources.json in /../../try-webpack/src\r\n @ ./src/main.js 2:16-43\r\n ```\r\n\r\n这个是loaders(加载器)报的错误，加载器是非常方便的工具，它可以使我们处理不同类型的内容。\r\n<br/>\r\n加载器可以用于转换ES2015成ES5，转换React JSX，编译TypeScript，加载Handlebars模版，加载和执行CSS，编译CSS预处理SASS，等等。有数以百计的加载器为不同的目的而诞生，现在我们只需要关心`json-loader`这个加载器。\r\n<br/>\r\n同样，我们通过npm来安装`json-loader`：\r\n```shell\r\n$ npm install --save-dev json-loader\r\n```\r\n我们需要修改一下我们的`webpack.config.js`文件，引入我们的加载器，具体如下：\r\n\r\n```javascript\r\nmodule.exports = {\r\n  devtool: 'cheap-module-eval-source-map',\r\n  entry: \"./src/main.js\",\r\n  output: {\r\n    path: __dirname + \"/dist\",\r\n    filename: \"bundle.js\"\r\n  },\r\n  module: {\r\n    loaders: [\r\n      { test: /\\.json$/, loader: 'json-loader' }\r\n    ]\r\n  }\r\n};\r\n```\r\n再一次运行`webpack`,你的应用应该可以启动和运行了，如果你厌倦了每次输入WebPack，你也可以运行`webpack -w`来激活文件自动检测功能，这样当任何文件修改时自动重新打包。\r\n\r\n<br/>\r\n让我们来做最后一件事，您可能已经注意到了生成包是相当大的，对于这样一个简单的应用程序来说，多出来的文件大小时由于`webpack.config.js`文件中`devtool:cheap-module-eval-source-map`这行造成的。这行为我们包生成源码地图（source maps），并映射到原始文件，方便查看源码和调试。当我们发布生产时，我们必须确保没有这行代码，怎样去掉这行取决于你自己，但是现在我们仅仅手工删除这一行代码。让我们也安装本地的webpack，这样我们才可以使用UglifyJsPlugin插件。\r\n<br/>\r\n安装本地webpack\r\n\r\n```shell\r\n$ npm install --save-dev webpack\r\n```\r\n\r\n当我们准备把项目发布生成时，我们需要压缩打包的代码，Webpack可以帮你完成，让我们最后一次修改`webpack.config.js`文件：\r\n\r\n```javascript\r\nvar webpack = require('webpack');\r\n\r\nmodule.exports = {\r\n  entry: \"./src/main.js\",\r\n  output: {\r\n    path: __dirname + \"/dist\",\r\n    filename: \"bundle.js\"\r\n  },\r\n  module: {\r\n    loaders: [\r\n      { test: /\\.json$/, loader: 'json-loader' }\r\n    ]\r\n  },\r\n  plugins: [\r\n    new webpack.optimize.UglifyJsPlugin({\r\n      compress: {\r\n        warnings: false\r\n      }\r\n    })\r\n  ]\r\n};\r\n```\r\n再一次运行 `webpack` 生成发布生成的压缩文件（bundle.js），如果以上你漏掉来哪一步，请在github上查看<a href=\"https://github.com/rwhitmire/webpack-demo\">webpack-demo</a>,或者在Twitter上随时联系作者<a href=\"https://twitter.com/ry_js\">@ry_js</a>。\r\n\r\n注：本文翻译自 <a href=\"http://rwhitmire.com/2016/04/09/webpack-for-beginners.html\">Webpack for Beginners</a>,已经在Twitter上征得原作者的同意。另外为了方便理解，我加上来一些我自己的理解（不是直译），第一次尝试翻译，有不对的地方欢迎指正，谢谢！：）\r\n","source":"source\\_posts\\webpack-for-beginners.md"},{"title":"Reason 中的多态性与普通变体","created":"2018/05/25","description":"Reason 中的多态性与普通变体","author":"lanqy","link":"2018/05/25/polymorphic-variants","htmlDir":"website\\2018\\05\\25\\polymorphic-variants","htmlFile":"website\\2018\\05\\25\\polymorphic-variants\\index.html","body":"# Reason 中的多态性与普通变体\r\n\r\n译自： http://blog.klipse.tech/reason/2018/03/12/blog-reason-types.html\r\n\r\n## 介绍\r\n\r\n变体是 Reasonml 最酷的特性之一。\r\n\r\n在[官方文档](https://reasonml.github.io/docs/en/variant.html)中，他们提到了变体的限制（也称为普通变体）：\r\n\r\n> 一个函数不能接受由两个不同变体共享的任意构造函数。\r\n\r\n他们还提到，使用多态变体可以克服这个限制。\r\n\r\n本文的目的是揭示普通变体的局限性，并看看多态性变体如何克服这一限制。我们希望我们带着狗和郁金香带来的例子会让这篇文章的阅读有些愉快。\r\n\r\n![狗和郁金香](/images/dog_tulip.jpg)\r\n\r\n## 普通变体 - 简要回顾\r\n\r\n假设你有一个 `animal` 变种\r\n\r\n```ocaml\r\n# type animal =\r\n| Dog\r\n| Cat\r\n\r\ntype animal = Dog | Cat\r\n```\r\n\r\n并且你想写一个函数来将 `animal` 字符串化。\r\n\r\n```ocaml\r\n# let string_of_animal = x =>\r\nswitch (x) {\r\n  | Dog => \"dog\"\r\n  | Cat => \"cat\"\r\n};\r\n\r\nval string_of_animal : animal => string = <fun>\r\n```\r\n\r\n现在，一只 `Dog` 是一只 “狗” ，一只 `Cat` 是一只“猫”：\r\n\r\n```ocaml\r\n# \"The \" ++ string_of_animal(Dog) ++ \" bites the \" ++ string_of_animal(Cat);\r\n- : string = \"The dog bites the cat\"\r\n```\r\n\r\n到现在为止还挺好。\r\n\r\n现在让我们对鲜花做同样的事情：\r\n\r\n```ocaml\r\n# type flower =\r\n| Rose\r\n| Tulip;\r\n\r\ntype flower = Rose | Tulip\r\n\r\n# let string_of_flower = x =>\r\nswitch (x) {\r\n  |Rose => \"rose\"\r\n  |Tulip => \"tulip\"\r\n};\r\n\r\nval string_of_flower : flower => string = <fun>\r\n\r\n# let a = \"The \" ++ string_of_flower(Rose) ++ \" is more beautiful than the \" ++ string_of_flower(Tulip);\r\n\r\nval a : string = \"The rose is more beautiful than the tulip\"\r\n```\r\n\r\n## 变体的局限性\r\n\r\n现在如果你尝试写一个函数使花和动物字符串化会发生什么？\r\n\r\n```ocaml\r\n# let string_of_flower_or_animal = x =>\r\nswitch (x) {\r\n  |Rose => \"rose\"\r\n  |Tulip => \"tulip\"\r\n  |Dog => \"dog\"\r\n  |Cat => \"cat\"\r\n};\r\n\r\nFile \"\", line 5, characters 4-7:\r\nError: This variant pattern is expected to have type flower\r\nThe constructor Dog does not belong to type flower\r\n/* 文件“”，第5行，字符4-7：\r\n错误：这种变体模式预计会有花类型\r\n构造函数Dog不属于花的类型 */\r\n```\r\n\r\n构造函数 `Dog` 不属于 `flower` 类型，在这种情况下，ocaml 不会立即创建 `flower_or_animal` 类型！\r\n\r\n普通变体的另一个限制是，你不能在列表或数组中混合 `animal` 和 `flower` 类型元素：\r\n\r\n```ocaml\r\n# let a = [Dog, Cat, Rose, Tulip];\r\n\r\nFile \"\", line 1, characters 19-23:\r\nError: This variant expression is expected to have type animal\r\nThe constructor Rose does not belong to type animal\r\n\r\n/* 文件“”，第1行，字符19-23：\r\n错误：预计此变体表达式具有 Dog 类型\r\n构造函数 Rose 不属于 Dog 类型 */\r\n```\r\n\r\n欢迎来到多态变体的世界！\r\n\r\n## 多态变体\r\n\r\n在语法上，多态变体通过反向撇号区别于普通变体：\r\n\r\n```ocaml\r\n# let myDog = `Dog;\r\nval myDog : [> `Dog] = `Dog\r\n```\r\n\r\n请注意，与普通变体不同，多态变体可以在没有显式类型声明的情况下使用。他们的类型是自动推断的。\r\n\r\n当然，它也适用于参数化的变体：\r\n\r\n```ocaml\r\n# let myNumber = `Int(4);\r\nval myNumber : [> `Int of int ] = `Int 4\r\n```\r\n\r\n现在，让我们看看如何使用多态类型来编写我们的 `string_of_flower_or_animal` 函数：\r\n\r\n```ocaml\r\n# let string_of_flower_or_animal = x =>\r\nswitch (x) {\r\n  |`Rose => \"rose\"\r\n  |`Tulip => \"tulip\"\r\n  |`Dog => \"dog\"\r\n  |`Cat => \"cat\"\r\n};\r\n\r\nval string_of_flower_or_animal : [< `Cat | `Dog | `Rose | `Tulip ] => string = <fun>\r\n```\r\n\r\n请注意，系统已经自动推断函数参数的类型：它是[< \\`Cat | \\`Dog| \\`Rose | \\`Tulip ]。你可能想知道 `<` 符号 的含义是什么。\r\n\r\n在回答这个问题之前，让我们看看多态变体如何让我们在列表中混合不同类型的元素：\r\n\r\n```ocaml\r\n# let myNatrue = [`Dog, `Cat, `Rose, `Tulip];\r\nval myNatrue : [> `Cat | `Dog | `Rose | `Tulip] list = [`Dog; `Cat; `Rose; `Tulip]\r\n```\r\n现在，列表的类型是：`[> \\`Cat | \\`Dog | \\`Rose | \\`Tulip] list 。\r\n\r\n## 上限和下限\r\n\r\n现在是时候解释多态变体中 `<` 和 `>` 的含义了。\r\n\r\n`>` 在变体类型的开头标记类型 a 是**开放的**以便与其他变体类型组合。我们可以解读类型  [> \\`Cat | \\`Dog | \\`Rose | \\`Tulip ] 为描述一种变体，其标签包括 \\`Cat，\\`Dog，\\`Rose和 \\`Tulip，但也可能包含更多标签。\r\n\r\n换句话说，你可以大致翻译 `>` 来表示：“这些标签或更多”。\r\n\r\n事实上，我们可以连接动物列表和花名单：\r\n\r\n```ocaml\r\nlet myAnimals = [`Dog, `Cat];\r\nlet myFlowers = [`Rose, `Tulip];\r\nlet myThings = List.concat([myAnimals, myFlowers]);\r\n\r\nval myAnimals : [> `Cat | `Dog] list = [`Dog; `Cat]\r\nval myFlowers : [> `Rose | `Tulip] list = [`Rose; `Tulip]\r\nval myThings : [> `Cat | `Dog | `Rose | `Tulip] list = [`Dog; `Cat; `Rose; `Tulip]\r\n```\r\n\r\n`<` 变体类型的开始部分表示 “这些标签或更少”。例如，在我们上面定义的 `string_of_flower_or_animal` 函数中，参数被推断为类型  [< \\`Cat | \\`Dog | \\`Rose| \\`Tulip]。\r\n\r\n事实上，这个函数没有办法处理具有除 \\`Cat，\\`Dog，\\`Rose 和 \\`Tulip 之外的标签的值。\r\n\r\n## 结论\r\n\r\n你现在可能会问自己为什么不总是使用多态变体。\r\n\r\n答案是多态变体的灵活性是有代价的。\r\n\r\n- 它们比普通变体更复杂\r\n- 他们不太可能捕捉那些普通变体的错误 - 正是由于它们允许的灵活性\r\n- 它们比普通变体重一点，性能较差\r\n\r\n请务必阅读 Real World Ocaml 的 [这一章](https://realworldocaml.org/v1/en/html/variants.html#polymorphic-variants)，深入了解普通和多态变体。在本章最后，他们详细解释了多态变体相对于普通变体的优点和缺点。\r\n","source":"source\\_posts\\polymorphic-variants.md"},{"title":"傻瓜式类型安全绑定从 JS 到 Reason","description":"傻瓜式类型安全绑定从 JS 到 Reason","created":"2018/05/25","author":"lanqy","link":"2018/05/25/externals-js-ffi-reason","htmlDir":"website\\2018\\05\\25\\externals-js-ffi-reason","htmlFile":"website\\2018\\05\\25\\externals-js-ffi-reason\\index.html","body":"\r\n\r\n# 傻瓜式类型安全绑定从 JS 到 Reason。\r\n\r\n译自： http://blog.klipse.tech/reason/2017/10/17/externals-js-ffi-reason.html\r\n\r\n有时，我们需要能够从我们的 Reason 代码中访问 JS 代码。这是所谓的 Javascript 互操作性的一部分。\r\n\r\n更具体地说，这叫做 FFI (外部函数接口)。FFI 是一种机制，用一种编程语言编写的程序可以调用例程或使用另一种编程语言编写的服务。\r\n\r\n在 Reason 的背景下，为了访问 JS 代码，我们必须从 JS 到 Reason 构建类型安全的绑定。为此，我们必须编写类型声明。\r\n\r\nReason 的 FFI 非常强大，但这种能力是有代价的。了解它的工作原理有点复杂。\r\n\r\n本文的目的是以简单的方式公开 Reason 的 FFI 的主要功能，以帮助您克服语法的困难。\r\n\r\n![烧脑](/images/burn-out.jpg)\r\n\r\n## 绑定到简单的 JS 函数值\r\n\r\n我们来看看一些例子：\r\n\r\n以下是我们如何使 `Math.sqrt` 函数可以访问我们的 Reason 代码：\r\n\r\n```ocaml\r\n[@bs.val] external sqrt : float => float = \"Math.sqrt\";\r\nlet a = sqrt (2.0);\r\n\r\n/* 1.4142135623730951 */\r\n```\r\n\r\n当指定的名称与原始名称完全相同时，我们可以将名称留空：\r\n\r\n```ocaml\r\n[@bs.val] external encodeURIComponent : string => string = \"\";\r\nlet a = encodeURIComponent(\"Hello World\\n\");\r\n\r\n/* Hello%20World%0A */\r\n```\r\n\r\n## 绑定到 JavaScript 构造函数：bs.new\r\n\r\n`bs.new` 用于创建 JavaScript 对象。\r\n\r\n```ocaml\r\ntype date;\r\n[@bs.new] external create_date : unit => date = \"Date\";\r\nlet date = create_date ();\r\n/* Fri May 25 2018 14:32:19 GMT+0800 (中国标准时间) */\r\n```\r\n\r\n## 绑定到方法：bs.send 和 bs.send.pipe\r\n\r\n`bs.send` 允许我们调用一个 JS 对象的方法。例如，这是我们如何绑定 `dom.getElementById`\r\n\r\n`dom` 是 `DOM` 的抽象类型，`element` 是元素的抽象类型\r\n\r\n```ocaml\r\ntype dom;\r\n[@bs.val] external dom : dom = \"document\";\r\ntype element;\r\n[@bs.send] external get_by_id : dom => string => element = \"getElementById\";\r\n\r\nlet a = get_by_id(dom, \"klipse\");\r\n```\r\n\r\n输出\r\n\r\n```javascript\r\n// Generated by BUCKLESCRIPT VERSION 1.9.2, PLEASE EDIT WITH CARE\r\n'use strict';\r\n\r\nvar a = document.getElementById(\"klipse\");\r\n\r\nexports.a = a;\r\n/* a Not a pure module */\r\n```\r\n\r\n`bs.send.pipe` 与 `bs.send` 相似，除了第一个参数，即对象，放在最后一个参数的位置，以帮助用户以链式编写：\r\n\r\n```ocaml\r\n[@bs.send.pipe : array('a)] external map : ([@bs] ('a => 'b)) => array('b) = \"\";\r\n\r\nlet test (arr) =\r\n  arr\r\n  |> map ([@bs] (fun (x) => x + 1))\r\n  |> map ([@bs] (fun (x) => x * 4));\r\n\r\nlet a = test([|1,2,3|]);\r\n\r\n/* 8,12,16 */\r\n```\r\n\r\n如果您对 Ocaml / Reason 管道运算符还不熟悉，则这里是经过转换的 js 代码：\r\n\r\n```ocaml\r\n[@bs.send.pipe : array('a)] external map : ([@bs] ('a => 'b)) => array('b) = \"\";\r\n\r\nlet test (arr) =\r\n  arr\r\n  |> map ([@bs] (fun (x) => x + 1))\r\n  |> map ([@bs] (fun (x) => x * 4));\r\n```\r\n\r\n转换成：\r\n\r\n```javascript\r\n// Generated by BUCKLESCRIPT VERSION 1.9.2, PLEASE EDIT WITH CARE\r\n'use strict';\r\n\r\n\r\nfunction test(arr) {\r\nreturn arr.map((function (x) {\r\nreturn x + 1 | 0;\r\n})).map((function (x) {\r\nreturn (x << 2);\r\n}));\r\n}\r\n\r\nexports.test = test;\r\n/* No side effect */\r\n```\r\n\r\n> 如果您对回调中的[@bs]属性感兴趣，请参阅[绑定到回调函数（高阶函数）](https://bucklescript.github.io/bucklescript/Manual.html#_binding_to_callbacks_high_order_function)。\r\n\r\n绑定到动态密钥访问/设置：`bs.set_index` 和 `bs.get_index`\r\n\r\n以下是我们如何对 JavaScript 属性进行动态访问：\r\n\r\n```ocaml\r\ntype js_array;\r\n[@bs.new] external create : int => js_array = \"Int32Array\";\r\n[@bs.get_index] external get : js_array => int => int = \"\";\r\n[@bs.set_index] external set : js_array => int => int => unit = \"\";\r\n\r\nlet i32arr = create(3);\r\nset(i32arr, 0, 42);\r\nlet a = get(i32arr, 0);\r\n\r\n/* 42 */\r\n```\r\n\r\n## 绑定到 Getter / Setter：bs.get，bs.set。\r\n\r\n该属性有助于获取和设置 JavaScript 对象的属性。\r\n\r\n让我们在 javascript klipse 片段中定义一个 javascript 对象：\r\n\r\n```javascript\r\nvar bob = {\"name\": \"Bob\", \"age\": 32};\r\n```\r\n\r\n现在，下面是我们如何创建 setter 和 getter 到这个 javascript 对象（谢谢 @yawaramin，来自 Reason Discord！）：\r\n\r\n```ocaml\r\ntype person;\r\n[@bs.val] external bob : person = \"\";\r\n[@bs.get] external get_age : person => int = \"age\";\r\n[@bs.set] external set_age : (person, int) => unit = \"age\";\r\n\r\nlet () = {\r\n  let bobAge = get_age(bob);\r\n  set_age(bob, bobAge + 1)\r\n}\r\n\r\n/* 33 */\r\n```\r\n只是为了好玩，看一下如何简单和干净的转换的js代码:\r\n\r\n```ocaml\r\ntype person;\r\n[@bs.val] external bob : person = \"\";\r\n[@bs.get] external get_age : person => int = \"age\";\r\n[@bs.set] external set_age : (person, int) => unit = \"age\";\r\n\r\nlet () = {\r\n  let bobAge = get_age(bob);\r\n  set_age(bob, bobAge + 1)\r\n};\r\n```\r\n\r\n转成：\r\n\r\n```javascript\r\n// Generated by BUCKLESCRIPT VERSION 1.9.2, PLEASE EDIT WITH CARE\r\n'use strict';\r\n\r\n\r\nvar bobAge = bob.age;\r\n\r\nbob.age = bobAge + 1 | 0;\r\n\r\n/* bobAge Not a pure module */\r\n```\r\n\r\n## 拼接调用约定：bs.splice\r\n\r\n在 JS 中，有一个函数采用可变参数是很常见的。 BuckleScript 支持类型同质可变参数。我们传递一个数组，而不是传递可变数量的参数：\r\n\r\n```ocaml\r\n[@bs.val] [@bs.splice] external max : array(int) => int = \"Math.max\";\r\n\r\nmax([|10, 12, 99|]);\r\n\r\n/* 99 */\r\n```\r\n\r\n## 绑定到来自模块的值：bs.module\r\n\r\n我们可以绑定到 js 模块的值：\r\n\r\n```ocaml\r\n[@bs.module \"x\"] external add : (int, int) => int = \"add\";\r\n\r\nlet f = add(3, 4);\r\n```\r\n\r\n转成：\r\n\r\n```javascript\r\n// Generated by BUCKLESCRIPT VERSION 1.9.2, PLEASE EDIT WITH CARE\r\n'use strict';\r\n\r\nvar X = require(\"x\");\r\n\r\nvar f = X.add(3, 4);\r\n\r\nexports.f = f;\r\n/* f Not a pure module */\r\n```\r\n\r\n我们甚至可以提示编译器为模块生成一个更好的名称：\r\n\r\n```ocaml\r\n[@bs.module (\"x\", \"coolx\")] external add : (int, int) => int = \"add\";\r\n\r\nlet f = add(3, 4);\r\n```\r\n\r\n转成：\r\n\r\n```javascript\r\n// Generated by BUCKLESCRIPT VERSION 1.9.2, PLEASE EDIT WITH CARE\r\n'use strict';\r\n\r\nvar CoolX = require(\"x\");\r\n\r\nvar f = CoolX.add(3, 4);\r\n\r\nexports.f = f;\r\n/* f Not a pure module */\r\n```\r\n\r\nBucklescript FFI 还有许多其他高级功能。您可以阅读有关优秀的官方 [BuckleScript手册](https://bucklescript.github.io/bucklescript/Manual.html#_ffi)。\r\n\r\n注意到使用 FFI，在 `ReasonReact` 项目中访问 React.js 组件非常简单，因为它在[这里](https://reasonml.github.io/reason-react/docs/en/interop.html)已经解释了。\r\n","source":"source\\_posts\\externals-js-ffi-reason.md"},{"title":"BuckleScript 绑定技巧","created":"2018/05/25","description":"BuckleScript 绑定技巧","author":"lanqy","link":"2018/05/25/bucklescript-binding-tips","htmlDir":"website\\2018\\05\\25\\bucklescript-binding-tips","htmlFile":"website\\2018\\05\\25\\bucklescript-binding-tips\\index.html","body":"# BuckleScript 绑定技巧\r\n\r\n译自： https://jwheatley.co/bucklescript-binding-tips/\r\n\r\n> 这是一组适用于当前或未来项目的简单绑定提示，减少了对试验 / 错误的需求，并减少了深度文档搜索解决与下面示例相关的问题。\r\n\r\n## 保持 React.js 中的 js\r\n\r\n```ocaml\r\nmodule Container = {\r\n  [@bs.module \"./styled/Container\"]\r\n  external js : ReasonReact.reactClass = \"default\";\r\n  let make = children =>\r\n    ReasonReact.wrapJsForReason(\r\n      ~reactClass=js,\r\n      ~props=Js.Obj.empty(),\r\n      children\r\n      );\r\n};\r\n```\r\n\r\n我将外部 js 命名为如果我需要将 React 组件的规范传递到 Reason 中使用的基于 JS 的库，我可以使用 `<ComponentName>.js` 来访问它。\r\n\r\n例如：\r\n\r\n```ocaml\r\nopen Bindings.ReactRouter;\r\nlet component = ReasonReact.statelessComponent(\"App\");\r\n\r\nlet make = (_children) => {\r\n  ...component,\r\n  render: (_self) =>\r\n    <Router>\r\n      <div>\r\n        <Header />\r\n      </div>\r\n      <Switch>\r\n        <Route exact=true path=\"/\" component=Home.js />\r\n        <Route component=NoMatch.js />\r\n      </Switch>\r\n      <Footer />\r\n      </div>\r\n    </Router>\r\n}\r\n```\r\n\r\n## 属性\r\n\r\n这是 Khoa Nguyen 关于使用 BuckleScript 对象“特殊创建函数”绑定 ReasonReact 属性的“[正确方法](https://khoanguyen.me/writing-reason-react-bindings-the-right-way/)”。\r\n\r\n## 使 ReasonReact 组件对 JS 更友好\r\n\r\n```ocaml\r\nlet component = ReasonReact.statelessComponent(\"App\");\r\n\r\nlet make = _children => {\r\n  ...component,\r\n  render: self => <div />\r\n};\r\n\r\nlet default = ReasonReact.wrapReasonForJs(~component, _jsProps => make([||]));\r\n```\r\n\r\n使用为 JS 封装的组件创建“默认”变量，您可以通过它的 BuckleScript 输出文件名简单地导入它，而不用担心命名的导出。例如: 用 `import App from './App.bs'`; 代替 `import { AppWrapped } from './App.bs'`;\r\n\r\n## 非代码导入\r\n\r\n```ocaml\r\ntype assetT;\r\n[@bs.module] external twitterSvg : assetT = \"../assets/svg/twitter.svg\";\r\n```\r\n\r\n我个人不会假设在 JS 端会输出什么类型（int，string 等）。我只是给它一个泛型类型，让 Webpack 或 Metro Bundler 处理它，但它通常会。\r\n\r\n## 全局\r\n\r\n```ocaml\r\n[@bs.val] external setInterval : (unit => unit, int) => int = \"setInterval\";\r\n[@bs.val] external clearInterval : int => unit = \"clearInterval\";\r\n```\r\n\r\n要与 BuckleScript 绑定的全局 JS 变量是 `bs.val`，而不是 `bs.module`。\r\n\r\n## 函数重载\r\n\r\n```ocaml\r\nmodule Date = {\r\n  type t;\r\n  [@bs.new] external fromValue: float => t = \"Date\";\r\n  [@bs.new] external fromString: string => t = \"Date\";\r\n};\r\n\r\nlet date1 = Date.fromValue(107849354.);\r\nlet date2 = Date.fromString(\"1995-12-17T03:24:00\");\r\n```\r\n\r\n如果你绑定的 JS 函数采用不同类型的参数，你可以使用不同类型的不同名称进行多次绑定，以表示你将传递给它的东西。\r\n\r\n```ocaml\r\nmodule Date = {\r\n  type t;\r\n  [@bs.new] external make : ([@bs.unwrap] [ | `Value(float) | `String(string)]) => t = \"Date\";\r\n};\r\n\r\nlet date1 = Date.make(`Value(107849354.));\r\nlet date2 = Date.make(`String(\"1995-12-17T03:24:00\"));\r\n```\r\n\r\n你也可以使用 `bs.unwrap` 来“重载”你的函数类型。\r\n","source":"source\\_posts\\bucklescript-binding-tips.md"},{"title":"Reason 基础知识","created":"2018/05/23","description":"Reason 基础知识","author":"lanqy","link":"2018/05/23/reason-basics","htmlDir":"website\\2018\\05\\23\\reason-basics","htmlFile":"website\\2018\\05\\23\\reason-basics\\index.html","body":"# Reason 基础知识\r\n\r\n译自： https://github.com/parkerziegler/reason-basics\r\n\r\n> 人们学习 Reason 编程语言的存储库。\r\n\r\n## 目的\r\n\r\n此存储库是 Reason 社区的新手通过简单示例了解该语言的基础知识的地方。你在这里看到的大部分内容都是从[文档](https://reasonml.github.io/docs/en/overview.html)中压缩或修改的。文档是一个很好的资源，并为语言背后的设计决策提供了高层次的解释。但是，对于初次使用程序员和首次使用 Reason 的用户来说，他们会感到有点压倒性。这个存储库希望能够简化一些语言，并提供非常清晰，简洁的例子来帮助你了解和使用 Reason。如果您发现任何令人困惑，过于复杂或错误的事情，请[提交问题](https://github.com/parkerziegler/reason-basics/issues)或[创建拉取请求](https://github.com/parkerziegler/reason-basics/pulls)。\r\n\r\n## 安装\r\n\r\n遵循相同的标准步骤克隆和本地安装此存储库：\r\n\r\n```ocaml\r\ngit clone https://github.com/parkerziegler/reason-basics.git\r\ncd reason-basics\r\nyarn install\r\n```\r\n\r\n## 运行代码\r\n\r\n该存储库的源文件当前位于 src/index.re 中。要将 Reason 代码编译为 BuckleScript，然后编译为 JS：\r\n\r\n```ocaml\r\nyarn run build\r\n```\r\n\r\n编译该文件并在保存时监视更改：\r\n\r\n```ocaml\r\nyarn run start\r\n```\r\n\r\n运行代码并查看终端中的输出：\r\n\r\n```ocaml\r\nnode src/index.bs.js\r\n```\r\n\r\n这期望您的计算机上安装了Node @ 6或更高版本。\r\n\r\n## 编辑器\r\n\r\n如果使用 vscode，则可以使用 `Cmd + Shift + B`（在 macOS 上）或 `Windows + Shift + B`（在 Windows 上）自动构建。\r\n\r\n## 扩展\r\n\r\n如果您使用 vscode，我建议安装 [OCaml 和 Reason IDE](https://marketplace.visualstudio.com/items?itemName=freebroccolo.reasonml) 以获得令人敬畏的 Reason 编码体验。\r\n\r\n\r\n## 让我们学习 Reason\r\n\r\n> 注意：这些内容与index.re中的内容相同，只是为了您的欣赏而写在 Markdown 中。\r\n\r\n请注意，此存储库使用 Reason 的 v3 语法。\r\n\r\n```ocaml\r\n/* 这里是 Reason 中的注释. */\r\n```\r\n\r\n要在控制台打印，我们可以使用 BuckleScript 的 JS 模块。\r\n\r\n```ocaml\r\nJs.log(\"Hello, BuckleScript and Reason! Luv BuckleScript\");\r\n```\r\n\r\n我们也可以使用 Reason 的原生 print_* 模块。\r\n\r\n```ocaml\r\nprint_endline(\"Hello, BuckleScript and Reason! Luv Reason\");\r\n```\r\n\r\n请注意，print_endline 只能打印字符串。要打印数据结构，请使用 Js.log 。未来在语言上对此的支持即将到来。\r\n\r\n要打印其他类型，您可以使用 Reason 的类型强制方法或 print_* 模块。\r\n\r\n```ocaml\r\nprint_endline(string_of_int(1));\r\nprint_endline(string_of_bool(true));\r\n```\r\n\r\n如果使用 print_* 方法，则需要使用 print_newline() 来获取新行。 print_endline() 为你添加新行。\r\n\r\n```ocaml\r\nprint_int(1);\r\nprint_newline();\r\nprint_float(1.0);\r\nprint_newline();\r\n```\r\n### 变量\r\n\r\nReason 中的变量使用 let 定义。 没有 JS 中 const 的概念。\r\n\r\n```ocaml\r\nlet myVar = \"myVar\";\r\nlet myInt = 1;\r\n```\r\n\r\n### 字符和字符串\r\n\r\nReason 区分字符( 用单引号 )和字符串( 用双引号 )。\r\n\r\n\r\n```ocaml\r\nlet x = 'x';\r\nlet y = 'y';\r\n```\r\n\r\n模式匹配字符的示例。\r\n\r\n```ocaml\r\nlet isXY = char: bool =>\r\n  switch (char) {\r\n    | 'x'\r\n    | 'y'=> true\r\n    | _ => false\r\n  };\r\n```\r\n\r\n要将字符转换为字符串，请使用 String.make，将 1 作为第一个参数传递。\r\n\r\n```ocaml\r\nlet stringFromChar: string = String.make(1, x) ++ String.make(1, y);\r\nprint_endline(stringFromChar);\r\n```\r\n\r\n字符串使用 ++ 运算符连接。\r\n\r\n```ocaml\r\nlet greeting = \"Hello\";\r\nlet space = \" \";\r\nlet name = \"P-Doo\";\r\nlet exclamation = \"!\";\r\n\r\nprint_endline(greeting ++ space ++ name ++ exclamation);\r\n```\r\n\r\n我们可以使用标准库中的 String 方法（ Reason 的内置方法）对字符串进行操作。\r\n\r\n```ocaml\r\nlet whitespaceString = \"  _trim me_  \";\r\nlet trimmedString = String.trim(whitespaceString);\r\n\r\nprint_endline(trimedString);\r\n\r\nlet atString =\r\n  String.map(\r\n    c =>\r\n      switch (c) {\r\n        |' ' => '@'\r\n        | _ => c\r\n      },\r\n      whitespaceString\r\n    );\r\nprint_endline(atString);\r\n```\r\n\r\n字符串中的特殊字符需要使用 `\\` 转义。\r\n\r\n```ocaml\r\nlet slash = \"\\\\\";\r\nprint_endline(slash);\r\n```\r\n\r\n原因还支持多行字符串，类似于 JS 模板文字。他们使用 `{|` 和 `|}` 分隔。\r\n\r\n```ocaml\r\nlet multilineString = {|Hello\r\nReasonable\r\nFolks!|};\r\n\r\nprint_endline(multilineString);\r\n```\r\n\r\n字符串方法在多行字符串上工作相同。例如，要将多行字符串转换为单行字符串：\r\n\r\n```ocaml\r\nlet singlelineString =\r\n  String.map(\r\n    c =>\r\n      swith (c) {\r\n        | '\\n' => ' '\r\n        | _ => c\r\n      },\r\n      multilineString\r\n    );\r\n\r\nprint_endline(singlelineString);\r\n```\r\n\r\n要在多行字符串中插入变量，请用 `j| 和 `|j` 包围字符串。\r\n\r\n```ocaml\r\nlet style = \"background-color: papayawhip\";\r\nlet cssStyle = {j|$style|j};\r\n\r\nprint_endline(cssStyle);\r\n```\r\n\r\n要在 Reason 中的字符串中使用 unicode 字符，请使用 `js| |js` （译者注：或者 `j| |j`）。\r\n\r\n```ocaml\r\nlet unicodeString = {js|••∆∆••|js};\r\n\r\nprint_endline(unicodeString);\r\n```\r\n\r\n获取字符串长度和截取字符串：\r\n\r\n```ocaml\r\nlet background = \"background-color: aquamarine\";\r\nlet strLength: int = String.length(background);\r\n\r\nprint_endline(string_of_int(strLength));\r\n\r\nlet subStr: string =\r\n  String.sub(background, 0, String.index(background, '-'));\r\n\r\nprint_endline(subStr);\r\n```\r\n\r\n### 条件语句\r\n\r\n条件语句的工作原理与 JS 类似。然而，如果没有 `else` 的 `if` 语句，则将其计算为 `else{()}`，即 `unit` 类型。\r\n\r\n```ocaml\r\nlet displayGreeting = true;\r\n\r\nif (displayGreeting) {\r\n  let message = \"Enjoying my ridiculous commentary yet?\";\r\n  print_endline(message);\r\n}\r\n```\r\n\r\n条件是对其正文内容进行评估的——不需要返回语句。\r\n\r\n```ocaml\r\nlet good = true;\r\nlet content =\r\n  if (good){\"This tweet is good.\"} else {\r\n    \"This tweet is bad. please make it better.\"\r\n  };\r\n\r\nprint_endline(content);\r\n```\r\n\r\n在上面的块中，必须有一个 `else` 分支对字符串进行评估。如果没有，内容将被分配到 `unit` 类型，尽管它的目的是作为一个字符串。这会产生编译器错误。还有对三元运算符的支持。\r\n\r\n```ocaml\r\nlet retweet = good ? \"Most certainly.\" : \"Eh, don't think so.\";\r\nprint_endline(retweet);\r\n```\r\n\r\n### 作用域\r\n\r\n变量默认为块作用域。让绑定可以使用 `{}` 创建匿名作用域。\r\n\r\n```ocaml\r\nlet anonymousScope = {\r\n  let name = \"Parker\";\r\n  let company = \"Formidable\";\r\n  let place = \"Seattle\";\r\n  print_endline({j|$name works at $company in $place.|j});\r\n}\r\n```\r\n\r\n`nam` ， `company` 和 `place` 在这里是无法访问的，因为它们是由上面创建的匿名范围持有的。试图在范围之外访问它们会导致错误！\r\n\r\n### 类型！\r\n\r\nReason 由 OCaml 顶尖的系统支持。我们可以明确地输入变量，虽然这不是必需的。Reason 往往会为我们推断类型。\r\n\r\n```ocaml\r\nlet petalLength: int = 5;\r\n```\r\n\r\n我们也可以使用别名类型。\r\n\r\n```ocaml\r\ntype sepalLength = int;\r\n```\r\n\r\n然后使用它们！\r\n\r\n```ocaml\r\nlet sepalLength: sepalLength = 20;\r\n```\r\n\r\n我们通过注解参数来输入函数返回值。\r\n\r\n```ocaml\r\nlet flowerLength = (petal: int, sepal: sepalLength): int => petal + sepal;\r\nprint_endline(string_of_in(flowerLength(petalLength, sepalLength)));\r\n```\r\n\r\n### 布尔\r\n\r\nReason 中的布尔比较类似于 JS 。 `===` 表示引用相等，而 `==` 表示结构相等。小心使用 `==`，Reason 会提醒你这个！\r\n\r\n```ocaml\r\nlet myTuple = (\"Parkie\", \"is\", 1);\r\nlet compareBool = tuple: bool => tuple === myTuple;\r\n\r\nprint_endline(string_of_bool(compareBool(myTuple)));\r\n```\r\n这条线会产生多态比较（可能不安全）。\r\n\r\n```ocaml\r\nprint_endline(string_of_bool(('M', 23) == ('M', 23)));\r\n```\r\n\r\n该行不会产生警告。\r\n\r\n```ocaml\r\nprint_endline(string_of_bool(('M', 23) === ('M', 23)));\r\n```\r\n\r\n### 整数和浮点数\r\n\r\nReason 有整数和浮点数的概念，而不仅仅是 JS 数字。\r\n\r\n```ocaml\r\nlet githubStars: int = 9;\r\nlet squareInt = (num: int): int => num * num;\r\n\r\nprint_endline(string_of_int(squareInt(githubStars)));\r\n```\r\n\r\n要使用整数，请使用 Reason's Pervasives 模块中的方法。这些已经在范围内。\r\n\r\n```ocaml\r\nlet start: int = 1;\r\n+ start; /* 一元添加 */\r\n- start; /* 一元相减 */\r\nlet remainder = 20 mod 5;\r\n\r\nprint_endline(string_of_int(remainder));\r\n```\r\n\r\n浮点数具有唯一的操作数语法，附加 . 到 `+, -, *, /` 操作符上。\r\n\r\n```ocaml\r\nlet pi: float = 3.1415926;\r\nlet circleArea = (radius: float): float => pi *. radius *. radius;\r\n\r\nprint_endline(string_of_float(circleArea(20.0)));\r\n\r\nlet radius = sqrt(circleArea(20.0)) /. pi;\r\n\r\nprint_endline(string_of_float(radius));\r\n\r\n```\r\n\r\n### 元组\r\n\r\n元组在创建时是不可变的、有序的、有限的，并且是异构类型的(尽管它们可以是相同类型的)。Tuple 类型只是模仿它们所代表的元组的形状!\r\n\r\n```ocaml\r\nlet myTuple: (char, string, int, string) = ('A', \"wonderful\", 100, \"tuple\");\r\n```\r\n\r\n有一些特殊的方法可以获得长度为 2 的元组的元素元素。这些元素可以在 Pervasives 模块中使用。\r\n\r\n```ocaml\r\nlet twoTuple: (string, string) = (\"It\", \"Me\");\r\nlet first: string = fst(twoTuple);\r\nlet second: string = snd(twoTuple);\r\n\r\nprint_endline(first);\r\nprint_endline(second);\r\n```\r\n\r\n大多数元组元素都是使用解构来访问的。\r\n\r\n```ocaml\r\nlet (_, _, third: int, _) = myTuple;\r\nprint_endline(string_of_int(third));\r\n```\r\n\r\n元组对于模式匹配多个参数特别有用。\r\n\r\n```ocaml\r\nlet rotate = (x, y) =>\r\n  switch (x, y) {\r\n    | (180, (-180)) => print_endline({j|Rotate $x, $y|j})\r\n    | (90, (-90)) => print_endline({j|Turn $x, $y|j})\r\n    | (_, _) => print_endline(\"Hold steady!\")\r\n  };\r\n\r\nrotate(180, -180);\r\nrotate(90, -90);\r\nrotate(50, 70);\r\n```\r\n\r\n### 记录\r\n\r\n记录类似于 JS 对象，但更轻，默认情况下不可变，固定在字段名称和类型中，速度更快，键入更严格。记录类型是必需的 - 如果不写类型，编译器会报错！请务必使用 mutable 关键字预先设置可变属性。\r\n\r\n```ocaml\r\ntype team = {\r\n  name: string,\r\n  mutable rank: int,\r\n  average: float,\r\n};\r\n\r\nlet redSox: team = {\r\n  name: \"Red Sox\",\r\n  rank: 1,\r\n  average: 0.326\r\n};\r\n\r\n```\r\n\r\n记录的 `keys` 通过点符号访问。\r\n\r\n```ocaml\r\nprint_endline(redSox.name);\r\nprint_endline(string_of_float(redSox.average));\r\n```\r\n\r\n使用扩展操作符可以从旧记录中创建新的记录。但是，扩展不能添加新字段，因为记录受到类型限制。\r\n\r\n```ocaml\r\nlet redSoxUpdate = {...redSox, average: 0.418};\r\nprint_endline(string_of_float(redSoxUpdate.average));\r\n```\r\n\r\n现有的记录可以使用 `=` 更新可变字段。\r\n\r\n```ocaml\r\nredSox.rank = redSox.rank + 1;\r\nprint_endline(string_of_int(redSox.rank));\r\n```\r\n\r\n在 Reason 中记录也有双关语，类似于ES6对象简写语法。如果值和键匹配，这允许您只提供关键名称。\r\n\r\n```ocaml\r\nlet capital = \"Olympia\";\r\nlet population = 6000000;\r\n\r\ntype state = {\r\n  capital: string,\r\n  population: int,\r\n};\r\n\r\nlet washington: state = {\r\n  capital,\r\n  population\r\n};\r\n```\r\n\r\n你也可以用类型双关！\r\n\r\n```ocaml\r\ntype place = {\r\n  state,\r\n  team,\r\n};\r\n\r\nlet seattle: place = {\r\n  state: washington,\r\n  team: {\r\n    name: \"Mariners\",\r\n    rank: 3,\r\n    average: 0.298,\r\n  },\r\n};\r\n```\r\n\r\n尽管记录与 JS 对象有些类似，但您必须更加认识它们的类型。将数据记录用于不改变形状的数据。记录被编译为具有数组索引访问权限的 JS 数组，使其快速。更改记录的类型还可以帮助标记需要更新数据结构的位置，从而使调试变得更加简单！\r\n\r\n如果你对使用 JS 本地对象感兴趣，Reason 提供了一个简写语法。这涉及用双引号（`\"\"`）来包装 `key` 名称。\r\n\r\n```ocaml\r\ntype jsObject = {.\r\n  \"response\": {.\r\n    \"data\": {.\r\n      \"starCount\": int,\r\n      \"watchers\": int\r\n    },\r\n    \"code\": int\r\n  }\r\n};\r\n\r\nlet jsObject:jsObject = {\r\n  \"response\": {\r\n    \"data\": {\r\n      \"starCount\": 9,\r\n      \"watchers\": 2\r\n    },\r\n    \"code\": 200\r\n  }\r\n};\r\n```\r\n要访问字段，请使用 `##` 符号。\r\n\r\n```ocaml\r\nlet starCount: int = jsObject##reponse##data##starCount;\r\nprint_endline(string_of_int(starCount));\r\n```\r\n\r\n### 变种\r\n\r\n变体是 Reason 中唯一的数据结构。他们让我们表达这种或那种关系。\r\n\r\n```ocaml\r\ntype tweetQuality =\r\n  | Dope /* 这些被称为变体的构造函数或标签。 */\r\n  | Sweet\r\n  | NotBad\r\n  | AF\r\n```\r\n\r\n变体通常与 Reason 的 switch 语句一起用于模式匹配。\r\n\r\n```ocaml\r\nlet tweetStatus = status: string =>\r\n  switch (status) {\r\n    | Dope => \"That was a dope tweet!\"\r\n    | Sweet => \"Pretty sweet tweet!\"\r\n    | NotBad => \"Not great, but not bad!\"\r\n    | AF => \"Pretty af tweet my friend!\"\r\n  };\r\n\r\nprint_endline(tweetStatus(AF));\r\n```\r\n\r\n变体需要明确的定义。通过调用它们所在的模块来导入它们。\r\n\r\n```ocaml\r\nlet team: Team.seattleVariant = Mariners;\r\n```\r\n\r\n变体构造函数也可以带参数。查看 Team.re 中的 seattleVariant，它具有以下形状：\r\n\r\n```ocaml\r\ntype seattleVariant =\r\n  | Mariners(player)\r\n  | Sonics(player, year)\r\n  | Seahawks\r\n  | Sounders;\r\n```\r\n\r\n这看起来很像函数参数！我们可以在模式匹配中使用这个优势！\r\n\r\n```ocaml\r\nopen Team;\r\nlet player: Team.bostonVariant = RedSox(\"Mookie Betts\");\r\n\r\nlet namePlayer = arg =>\r\n  switch (arg) {\r\n    | RedSox(name) => {j|You chose $name|j}\r\n    | Celtics(name, year) => year < 2008 ? name : \"Big 3\"\r\n    | Patriots => \"Malcolm Butler\"\r\n    | Bruins => \"Zdeno Chara\"\r\n  };\r\n\r\nprint_endline(namePlayer(player));\r\nprint_endline(namePlayer(Celtics(\"Larry Bird\", 2009)));\r\nprint_endline(namePlayer(Celtics(\"Larry Bird\",1984)))\r\n```\r\n\r\n独立库为您提供了一些很酷的变体。`type option('a) = None | Some('a)`;- 这允许你定义可以为 `null` 或者 `undefined` 的类型。例如，`option(int)` 键入一个变量作为可为空的整数。\r\n\r\n```ocaml\r\nlet isNull = true;\r\n\r\nlet possiblyNullInt: option(int) =\r\n  if (isNull) {\r\n    None\r\n  } else {\r\n    Some(5);\r\n  };\r\n\r\nlet checkNull = (num: option(int)) => {\r\n  switch (num) {\r\n    | Some(int) => false\r\n    | None => true\r\n  };\r\n\r\nprint_endline(string_of_bool(checkNull(possiblyNullInt)));\r\n}\r\n```\r\n\r\n### 列表和数组\r\n\r\n列表是同类型的，不可变的，并且在预添加项目时很快。列表看起来很像 JS 中的数组。\r\n\r\n```ocaml\r\nlet fibList: list(int) = [1, 1, 2, 3, 5, 8, 13, 21];\r\n```\r\n\r\n要添加到列表中，请使用延展运算符。这不会改变原始列表。相反，新列表维护一个链接到扩展列表。例如，下面的 fibListHeadZero 与 fibList 共享其元素，使其非常高效。\r\n\r\n```ocaml\r\nlet fibListHeadZero = [0, ...fibList];\r\n```\r\n\r\n需要注意的是，在 Reason 中不允许使用双延展操作符，即不允许类似这样 [a,...b,...c] 。要访问任意列表项，请使用 List 模块中的 List.nth。\r\n\r\n```ocaml\r\nlet five = List.nth(fibList, 4);\r\nprint_endline(string_of_int(five));\r\n```\r\n要获得列表的长度，使用List.length。\r\n\r\n```ocaml\r\nlet length: int = List.length(fibList);\r\nlet lastItem: int = List.nth(fibList, length - 1);\r\n```\r\n\r\nList 模块 附带有用于在列表上操作的附加内置方法。\r\n\r\n```ocaml\r\nlet reverse = List.rev(fibList);\r\nlet sum = List.fold_left((acc, el) => acc + el, 0, fibList);\r\nprint_endline(string_of_int(sum));\r\n\r\nlet thriteen = List.find(item => item === 13, fibList);\r\nprint_endline(string_of_int(thirteen));\r\nlet aboveTen = List.filter(item => item > 10, fibList);\r\n\r\nList.iter(item => print_endline(string_of_int(item)), aboveTen);\r\n```\r\n\r\n数组就像列表，但是对于随机访问和更新是可变的和优化的。它们的大小是固定的，但在 JS 上是灵活的。数组的两端都用 `[|` 和 `|]` 表示。\r\n\r\n```ocaml\r\nlet fibArray: array(int) = [|1, 1, 2, 3, 5, 8, 13, 21|];\r\n```\r\n数组访问和更新类似于 JS。\r\n\r\n```ocaml\r\nlet length: int = Array.length(fibArray);\r\nlet lastItem: int = fibArray[length - 1]\r\nfibArray[2] = 500;\r\n```\r\n\r\n您也可以使用标准库中的 `Array.get` 和 `Array.set`。\r\n\r\n```ocaml\r\nfibArray[2] = 1000;\r\nprint_endline(string_of_int(fibArray[2]));\r\n```\r\n\r\n要将数组转换为列表，请在 ArrayLabels 模块中使用 `.to_list` 函数。\r\n\r\n```ocaml\r\nlet fibArrayAsList: list(int) = ArrayLabels.to_list(fibArray);\r\nlet fibListAsArray: Array(int) = ArrayLabels.of_list(fibArrayAsList);\r\n```\r\n\r\nReason 还支持多维数组。前两个参数指定数组的维数，而第三个参数提供填充数组的初始值。\r\n\r\n```ocaml\r\nlet multiDemArray = Array.make_matrix(2, 2, \"Initial.\");\r\nJs.log(multiDemArray);\r\n```\r\n\r\n### 函数\r\n\r\n函数使用 => 声明。单行函数是允许的。多行函数应该被 `{}` 包围。在理由中，所有函数都有参数。如果没有显式参数传递，我们传递 `()`，unit 类型。\r\n\r\n```ocaml\r\nlet noArg = () : unit => print_endline(\"This is unit!\");\r\nlet add = x => x + x;\r\nlet square = x => x * x;\r\n```\r\n\r\n管道操作符的预览！\r\n\r\n```ocaml\r\nlet addAndSquare = x => x |> add |> square;\r\n\r\nprint_endline(string_of_int(addAndSquare(4)));\r\n```\r\n\r\nReason 也有标签参数的概念。由于 Reason 支持 currying（柯里化），因此我们可以使用带标签的参数以任意顺序指定参数。\r\n\r\n```ocaml\r\nlet concatStringInt = (~int: int, ~str: string) =>\r\n  string_of_int(int) ++ \" \" ++ str;\r\n\r\nprint_endline(concatStringInt(~str=\"is an int.\", ~int=50));\r\n```\r\n\r\n您也可以使用标签参数来在函数中使用。\r\n\r\n```ocaml\r\nlet calcTriangleArea = (~base as b: float, ~height as h: float): float => 0.5 *. b *. h;\r\nprint_endline(string_of_float(calcTriangleArea(~base=2.0, ~height=7.0)));\r\n```\r\n\r\n### 柯里\r\n\r\nReason 函数可以自动部分调用。事实上，Reason 中的所有函数都接受一个参数！\r\n\r\n```ocaml\r\nlet multiply = (x, y) => x * y;\r\nlet multiplyByFive = multiply(5);\r\nlet result = multiplyByFive(6);\r\n\r\nprint_endline(string_of_int(result));\r\n```\r\n\r\n上面的乘法函数相当于\r\n\r\n```ocaml\r\nlet multiply = (x, y) => x * y;\r\n```\r\n\r\nOCaml 为我们优化了这一点，以避免不必要的函数分配。\r\n\r\n### 可选的标签参数\r\n\r\n在 Reason 中可以用 `=?` 创建可选的标签参数。\r\n\r\n```ocaml\r\nlet sayHello = (~greeting as g, ~name=?, ()) => {\r\n  let person =\r\n    switch (name) {\r\n      | None => \"\"\r\n      | Some(a) => a\r\n    };\r\n  print_endline(g ++ \" \" ++ person);\r\n};\r\n\r\nsayHello(~greeting=\"Marhaba\", ());\r\nsayHello(~greeting=\"Ahlan ya\", ~name=\"Parker\", ());\r\n```\r\n\r\n在函数定义的第三个索引中注意到括号 ()，并在上面调用。没有它，Reason 就无法解析函数。`greeting` 和 `name` 都可以柯里化和无序运用，所以目前还不清楚 sayHello(~greeting =\"Aloha\") 是什么意思。OCaml 解析 () 表示可选标记的 arg 被省略了。否则，它会将该函数解析为正在等待要应用的名称的curried函数。\r\n\r\n```ocaml\r\n/* 这里我们调用上面定义的实际函数sayHello。 */\r\nlet actualFunction = sayHello(~greeting=\"Marhaba\", ());\r\n\r\n/* 这里我们返回一个可以接受〜name参数的函数。 */\r\nlet curriedFunction = sayHello(~greeting=\"Marhaba\");\r\n\r\ncurriedFunction(~name=\"Parker\", ());\r\n\r\n```\r\n\r\n有时，您不知道您转发给函数的值是 None 还是 Some(val)。在这种情况下，您可以提供一个明确传递的可选类型。\r\n\r\n```ocaml\r\nlet possibleName: option(string) = Some(\"Formidable\");\r\n\r\nsayHello(~greeting=\"Hi ya\", ~name=?possibleName, ());\r\n```\r\n\r\n如果 possibleName 具有构造函数 None，那么上面的函数仍然可以工作！\r\n\r\n您还可以提供默认值，如 JS。只需在参数定义中使用 `=` 来指定它们即可。下面，除非通过明确的值，否则 Aloha 将成为问候语的值。\r\n\r\n```ocaml\r\nlet sayHello = (~greeting=\"Aloha\", ~name=?, ()) => {\r\n  let person =\r\n    switch (name) {\r\n      | None => \"\"\r\n      | Some(a) => a\r\n    };\r\n  print_endline(greeting ++ \" \" ++ person);\r\n};\r\n\r\nsayHello();\r\n```\r\n\r\n### 递归函数\r\n\r\n要定义递归函数，请使用 `rec` 关键字。\r\n\r\n```ocaml\r\nlet rec factorial = (num: int) =>\r\n  if (num === 0) {\r\n    1;\r\n  } else {\r\n    num * factorial(num - 1);\r\n  };\r\n\r\nprint_endline(string_of_int(factorial(5)));\r\n```\r\n\r\n### 相互递归函数\r\n\r\n函数可以在 Reason 中递归调用对方。使用 `and` 关键字来实现这一点。下面的示例还预览了我们如何在 Reason 中使用异常来创建自定义错误。\r\n\r\n```ocaml\r\nexception FactorialArgument(string);\r\n\r\nlet rec factorialEven = (num: int) =>\r\n  if (num === 0) {\r\n    1;\r\n  } else {\r\n    switch (num mod 2) {\r\n      /* 模式匹配来检查数字是偶数还是奇数。 */\r\n      | 0 => num * factorialOdd(num - 1)\r\n      | 1 =>\r\n        raise(\r\n          FactorialArgument(\r\n            \"factorialEven only accepts even-numbered arguments.\"\r\n            )\r\n          )\r\n      | _ => 1\r\n    };\r\n  }\r\nand factorialOdd = (num: int) =>\r\n  if (num === 0) {\r\n    1;\r\n  } else {\r\n    switch (num mod 2) {\r\n      | 0 =>\r\n        raise(\r\n          FactorialArgument(\r\n            \"factorialOdd only accepts odd-numbered arguments.\"\r\n            )\r\n          )\r\n      | 1 => num * factorialEven(num - 1)\r\n      | _ => 1\r\n    };\r\n  };\r\n\r\nprint_endline(string_of_int(factorialEven(6)));\r\nprint_endline(string_of_int(factorialOdd(5)));\r\n\r\n```\r\n\r\n以下调用会抛出我们的 FactorialArgument 异常，并说 factorialEven 只接受偶数参数。\r\n\r\n```ocaml\r\nprint_endline(string_of_int(factorialEven(5)));\r\n```\r\n\r\n如果您来自 JS，上述模式的用处就会起作用，因为 Reason / OCaml 不会提升变量或函数声明！考虑如何调用两个函数 a 和 b 来调用另一个函数。这在 JS 中是可行的，因为函数声明被提升到作用域的顶部。既然 Reason 没有提升，相互递归就是解决这个问题的一种技术。\r\n\r\n### 更多关于类型\r\n\r\n您可以在 Reason 中创建参数化类型，以使类型更具表现力。它们像函数一样，接受参数和返回类型。类型参数前缀为 `'`。\r\n\r\n```ocaml\r\ntype measurements('a) = ('a, 'a)\r\ntype measurementsInt = measurements(int);\r\ntype measurementsString = measurements(string);\r\n\r\nlet modalSize: measurements(int) = (150, 300);\r\nlet modalArea = fst(modalSize) * snd(modalSize);\r\n\r\nprint_endline(string_of_int(modalArea));\r\n\r\nlet dialogSize: measurements(string) = (\"500\", \"1000\");\r\nlet (w, h) = dialogSize;\r\nlet dialogDescription = {j| This dialog is $w by $h px |j};\r\n\r\nprint_endline(dialogDescription);\r\n\r\n```\r\n\r\n大多数情况下，Reason 的类型推断将会为您处理参数类型!\r\n\r\n类型也可以使用变体。\r\n\r\n```ocaml\r\ntype httpResult('a, 'b) =\r\n  | Success('a)\r\n  | Failure('b);\r\n\r\ntype payload = {\r\n  data: string,\r\n  code: int,\r\n}\r\n```\r\n组合类型 `httpResult` 需要两个参数，并将它们应用于 `Success` 和 `Failure` 构造函数。\r\n\r\n```ocaml\r\nlet result: httpResult(payload, int) = Success({\r\n    data: \"woohoo\",\r\n    code: 200\r\n  });\r\n\r\nlet errResult: httpResult(payload, int) = Failure(404);\r\n```\r\n由于 Reason 的类型系统允许使用类型级别的函数，因此不需要太多类型的样板。例如，我们可以使用 `list(int)` 和 `list(string)`，而不需要为每个都创建一个新的基本类型，即 listOfInt 和 listOfString。这使得 Reason 的类型系统具有超凡的表现力，同时仍然提供了坚如磐石的系统的脚手架。请享用！\r\n\r\n### 相互递归类型\r\n\r\n类型如函数，可以是相互递归的。\r\n\r\n```ocaml\r\ntype professor = {courses: list(course)}\r\nand course = {\r\n  name: string,\r\n  professor,\r\n};\r\n```\r\n\r\n### 解构\r\n\r\n解构是 Reason 中的常见模式，对于从结构中提取数据非常有用。\r\n\r\n```ocaml\r\nlet teams = (\"Mariners\", \"Red Sox\", \"Astros\", \"Twins\");\r\nlet (ms, bosox, stros, twins) = teams;\r\n\r\nprint_endline(\r\n  {j|$ms, $bosox, $stros, $twins === Parkie-Doo's playoff picks.|j}\r\n  );\r\n```\r\n\r\n以下是如何解构 Reason 记录。它看起来很像 JS 中的对象解构。\r\n\r\n```ocaml\r\ntype album = {\r\n  name: string,\r\n  artist: string,\r\n  year: int,\r\n};\r\n\r\nlet myFavoriteAlbum: album = {\r\n  name: \"Illinois\",\r\n  artist: \"Sufjan Stevens\",\r\n  year: 2004,\r\n};\r\n\r\nlet {name, artist, year} = myFavoriteAlbum;\r\n\r\nprint_endline({j|$artist wrote $name in $year.|j});\r\n```\r\n\r\n当您解构它们的时候也可以给变量起别名，全部在一行中！这与 ES6 解构相似。\r\n\r\n```ocaml\r\nlet {name: n, artist: a, year: y} = myFavoriteAlbum;\r\n\r\nprint_endline({j|$a wrote $n in $y.|j})\r\n```\r\n\r\n你甚至可以解构和别名函数参数！\r\n\r\n```ocaml\r\ntype exclamation = {\r\n  phrase: string,\r\n  volume: float,\r\n};\r\n\r\nlet exclaim = (~exclamation as {phrase} as exclamation) =>\r\n/* 您可以访问惊叹号（记录）和 短语属性作为一个解构变量。 */\r\nprint_endline(\r\n  {j|And lo, Parkie-Doo shouted, $phrase at $exclamation.volume DB.|j}\r\n  );\r\n\r\nexclaim(~exclamation={phrase: \"Breathtaking, this Reason!\", volume: 120.7});\r\n```\r\n\r\n### 模式匹配\r\n\r\n模式匹配是将数据与一组值相匹配的好方法。模式匹配最好与变体一起使用 - 何时这样做，我们可以从类型系统获得很好的全面帮助，从而检查不匹配的案例。\r\n\r\n```ocaml\r\ntype victory =\r\n  | NailBiter(int)\r\n  | BlowOut(int)\r\n  | OT(string, int);\r\n\r\nlet myVictory: victory = OT(\"8:03\", 1);\r\n```\r\n\r\n模式匹配允许我们解构变体，分别处理每个案例。要查看编​​译器警告你一个不匹配的情况，请尝试在下面注释掉 BlowOut。\r\n\r\n```ocaml\r\nlet myOTVictory =\r\n  switch (myVictory) {\r\n    | NailBiter(margin) => {j|yeesh, close game. Nice win by $margin.|j}\r\n    | BlowOut(margin) => {j|Damn, what a blowout. $margin run is impressive|j}\r\n    | OT(time, margin) => {j|It took $time to win by $margin. But a win's a win.|j}\r\n  };\r\n\r\nprint_endline(myOTVictory);\r\n```\r\n\r\n我们也可以用其他数据结构来切换其他情况。例如，一个 `array(int)`。\r\n\r\n```ocaml\r\nlet arr = [|500, 600|];\r\n\r\nlet handleArray = (array: array(int)) =>\r\n  switch (array) {\r\n    | [|500, 600|] => print_endline(\"This is a very specific case.\")\r\n    | [|500, _|] => print_endline(\"You have two items in this array, and the first is 500.\")\r\n    | [|_, _|] => print_endline(\"You have two items in this array.\")\r\n    | _ => print_endline(\"This is the default.\")\r\n  };\r\n\r\nhandleArray(arr);\r\nhandleArray([|500, 601|]);\r\nhandleArray([|101, 102|]);\r\nhandleArray([|1s|]);\r\n```\r\n\r\n你甚至可以模式匹配一​​组结果到一个特定的结果。例如，让我们将服务器上的错误映射到特定的结果。\r\n\r\n```ocaml\r\ntype httpResultWithCode =\r\n  | Success(int, list(string))\r\n  | Failure(int);\r\n\r\nlet handleResult = (res: httpResultWithCode) =>\r\n  switch (res) {\r\n    | Success(200, data) =>\r\n      let f = (acc, el) => acc ++ \" \" ++ el;\r\n      /* 我们在这里使用 fold_left 来连接字符串。 fold_left 类似于 reduce，但用于列表！ */\r\n      let resString = ListLabels.fold_left(~f, ~init=\"\", data);\r\n      print_endline({j|data: $resString|j});\r\n    | Failure(500)\r\n    | Failure(502) => print_endline(\"Server error.\")\r\n    | Failure(404) => print_endline(\"Not found.\")\r\n    | _ => print_endline(\"we don't know what happened, sorry!\")\r\n  };\r\n\r\nhandleResult(Failure(500));\r\nhandleResult(Failure(501));\r\nhandleResult(Success(200, [\"You\", \"Rock\"]));\r\nhandleResult(Success(201, [\"You\", \"Are\", \"Still\", \"Great\"]));\r\n```\r\n\r\n您也可以使用 `when` 子句来检查案例的特定条件。这就像在你的模式匹配逻辑中添加一点点 `if` 语法糖。扩展我们上面的例子：\r\n\r\n```ocaml\r\nlet isServerError = err => err === 500;\r\nlet isBadGateway = err => err === 502;\r\n\r\nlet handleResult = (res: httpResultWithCode) =>\r\n  switch (res) {\r\n    | Success(200, data) =>\r\n      let f = (acc, el) => acc ++ \" \" ++ el;\r\n      let resString = ListLabels.fold_left(~f, ~init=\"\", data);\r\n      print_endline({j|data: $resString|j});\r\n    | Failure(errCode) when isServerError(errCode) =>\r\n      print_endline(\"Server error.\")\r\n    | Failure(errCode) when isBadGateway(errCode) =>\r\n      print_endline(\"Bad gateway. Getaway? Who knows?\")\r\n    | Failure(404) => print_endline(\"Not found.\")\r\n    | _ => print_endline(\"we don't know what happened, sorry!\")\r\n  };\r\n\r\nhandleResult(Failure(500));\r\nhandleResult(Failure(502));\r\n```\r\n\r\n您也可以嵌套模式，这意味着我们可以对数据结构的嵌套属性进行模式匹配。\r\n\r\n```ocaml\r\ntype composer = {\r\n  name: string,\r\n  concertos: int,\r\n};\r\n\r\nlet evaluateComposer = (composer: composer) =>\r\n  switch (composer) {\r\n    | {name: \"Beethoven\" | \"Mozart\" | \"Debussy\"} => \"What high class. How fancy!\"\r\n    | composer when composer.concertos <= 7 => \"Not too bad, but nothing special.\"\r\n    | _ => \"Just another composer\"\r\n  };\r\n\r\nprint_endline(evaluateComposer({name: \"Debussy\", concertos: 57}));\r\nprint_endline(evaluateComposer({name: \"Jerry\", concertos: 7}));\r\n```\r\n\r\n### 变动\r\n\r\n`let` 绑定默认情况下是不可变的。如果你需要改变一个 `let` 绑定,使用 `ref` 关键字的包起它的值。\r\n\r\n```ocaml\r\nlet mutableVar = ref(\"mutable\");\r\n```\r\n\r\n要访问它，请使用 `^` 运算符。\r\n\r\n```ocaml\r\nlet mutableReference = mutableVar^;\r\n```\r\n要重新分配一个可变变量，请使用 `:=` 运算符。\r\n\r\n```ocaml\r\nmutableVar := \"mutated\";\r\nprint_endline(mutableVar^);\r\n```\r\n\r\n然而，你也可以简单地通过用另一个let绑定来映射它们来改变变量。\r\n\r\n```ocaml\r\nlet shodow = \"First I am this!\";\r\n\r\nprint_endline(shadow);\r\n\r\nlet shadow = \"But now I've been shadowed!\";\r\n\r\nprint_endline(shadow);\r\n```\r\n\r\n### 命令式循环\r\n\r\nfor 循环在 Reason 中迭代从一个开始直到包括一个结束值。\r\n\r\n```ocaml\r\nlet repeatCapitalize = (~time: int, ~str: string) => {\r\n  let result = ref(\"\");\r\n  for (time in 1 to times) {\r\n    switch (time mod 2) {\r\n      | 0 => result := result^ ++ String.capitalize(str)\r\n      | 1 => result := result^ ++ str\r\n      | _ => result := result^ ++ str\r\n    };\r\n  };\r\n  result^;\r\n};\r\n\r\nprint_endline(repeatCapitalize(~time=5, ~str=\"reason\"));\r\n```\r\n\r\n您也可以使用 `downto` 操作符从一个数字开始迭代。\r\n\r\n```ocaml\r\nlet factorialSum = (~num: int): int => {\r\n  let result = ref(0);\r\n  for (n in num downto 0) {\r\n    result := result^ + n;\r\n  };\r\n  result^;\r\n};\r\n\r\nprint_endline(string_of_int(factorialSum(~num=5)));\r\n```\r\n\r\n总的来说，`Array` 和 `List` 方法可能会让你更接近你想要的东西，而不是 for 循环，但是它们很好知道。您也可以像在 JS 中那样使用 while 循环。\r\n\r\n```ocaml\r\nlet count = ref(1);\r\n\r\nwhile (count < ref(5)) {\r\n  print_endline(\"We are while looping!\");\r\n  count := count^ + 1;\r\n};\r\n```\r\n使用上面的可变绑定来跳出循环。Reason 没有像 JS 这样的 `break` 关键字的概念。\r\n\r\n### JSX\r\n\r\nReason 本身支持 JSX 。调用如下：\r\n\r\n```ocaml\r\n<div foo={bar}> child1 child2 </div>\r\n```\r\n\r\n变成：\r\n\r\n```ocaml\r\n([@JSX] div(~foo=bar, ~children=[child1, child2], ()));\r\n```\r\n\r\n[@JSX] 语法将一个函数标记为想要格式化为 JSX。这在任何 Reason 库中都是允许的，而不仅仅是 ReasonReact，来利用JSX。\r\n\r\n### 外部对象\r\n\r\n外部是理性与其他语言（通常是 JS ）的交互方式。使用外部最常用的方法之一是加载模块。例如，让我们从这个 repo 中的 findS 模块加载 findS 函数。\r\n\r\n```ocaml\r\n[@bs.module \"./findS\"] external findS: string => int = \"\";\r\n\r\nlet twos = findS(\"strings\");\r\n\r\nprint_endline(string_of_int(twos));\r\n```\r\n\r\n优雅！我们从 Reason 中调用了一个 JS 函数！上面的注释允许我们从 findS 模块中键入函数 findS，并返回一个类型安全引用到该模块。让我们看看我们如何访问一个作用域函数，比如 Math.random。\r\n\r\n```ocaml\r\n[@bs.val] [@bs.scope \"Math\"] external random : unit => float = \"random\";\r\n[@bs.val] [@bs.scope \"Math\"] external floor : float => int = \"floor\";\r\n```\r\n\r\n在上面的定义中，我们说在 Math 作用域中有一个方法叫做 `random`。它将 unit 类型作为参数并返回一个浮点数。我们将它别名命名为 `random` ，以便在 Reason 中使用。现在我们可以使用它！\r\n\r\n```ocaml\r\nlet getRandomInt = (~max as m: float) =>\r\n  floor(random() *. float_of_int(floor(m)));\r\n\r\nprint_endline(string_of_int(getRandomInt(~max=100.0)));\r\n```\r\n\r\n### 对象\r\n\r\n大多数情况下，您将使用记录来存储名称和值。但有时候，你会想要一个对象。请注意，Reason 中的对象与 JS 对象不同。使用 `pub` 关键字将对象的公共值前缀。 `val` 可用于定义不可从外部访问的对象上的值。 `pri` 可以定义私有方法。\r\n\r\n```ocaml\r\nlet anUntypeReasonObject = {pub city = \"Burlington\"; val state = \"Vermont\"};\r\n\r\nprint_endline(anUntypeReasonObject#city);\r\n```\r\n\r\nReason 对象不需要类型定义。如果我们确定它们，则该对象必须具有所提供的类型的形状。\r\n\r\n```ocaml\r\ntype locale = {\r\n  .\r\n  city: string,\r\n  state: string,\r\n  population: int,\r\n};\r\n\r\nlet burlington: locale = {\r\n  pub city = \"Burlington\";\r\n  pub state = \"Vermont\";\r\n  pub population = 56000\r\n};\r\n\r\nprint_endline(string_of_int(burlington#population));\r\n```\r\n\r\n两个点（称为elision）表示此对象已打开，并且可以具有除原始类型属性之外的属性。开放对象是多态的，需要一个类型参数。\r\n\r\n```ocaml\r\ntype localeOpen('a) = {.. getplace: unit => string} as 'a;\r\n```\r\n\r\nReason 中的对象有一个 `this` 上下文，它指向对象本身。\r\n\r\n```ocaml\r\nlet vt: localeOpen({. getPlace: unit => string}) = {\r\n  val address = \"100 Church St\";\r\n  val city = \"Burlington\";\r\n  val zipCode = \"05712\";\r\n  pub getPlace = () =>\r\n    address ++ \", \" ++ city ++ \" \" ++ zipCode ++ \". \" ++ this#addOn();\r\n  pri addOn = () => \"Didn't ya know?\"\r\n};\r\n\r\nprint_endline(vt#getPlace());\r\n```\r\n\r\n大多数情况下，您将使用记录或 JS 对象来实现您在 JS 中使用的内容。Reason 有一个很好的定义 JS 对象的语法。这涉及到将对象键包装在 `\"\"` 中并使用 `##` 进行访问。\r\n\r\n```ocaml\r\nlet reason = {\"color\": \"orange\", \"language\": \"reason\", \"users\": 5000};\r\nprint_endline(reason##language);\r\n```\r\n\r\n改变 JS 对象涉及让 BuckleScript 知道我们有一个可变的键 - 值对。为此，请使用 `@bs.set` 注释类型。然后，使用 `#=` 改变它。\r\n\r\n```ocaml\r\ntype language = {\r\n  .\r\n  [@bs.set] \"color\": string,\r\n  \"language\": string,\r\n  \"users\": int,\r\n};\r\n\r\n[@bs.module \"./findS\"] external myJSObject : language = \"\";\r\n\r\nprint_endline(myJSObject##language);\r\n\r\nmyJSObject##color#=\"orange\";\r\n\r\nprint_endline(myJSObject##color);\r\n```\r\n\r\n### 模块\r\n\r\nReason 中的模块可以包含类型定义，`let` 绑定，嵌套模块，几乎任何东西。使用 module 关键字来创建一个。\r\n\r\n```ocaml\r\nmodule Earth = {\r\n  let continents = [|\r\n    \"Africa\",\r\n    \"Antarctica\",\r\n    \"Asia\",\r\n    \"Australia\",\r\n    \"Europe\",\r\n    \"North America\",\r\n    \"South America\",\r\n  |];\r\n\r\n  let pickContinent = (idx: int) => continents[idx];\r\n};\r\n\r\nlet aussie = Earth.pickContinent(3);\r\n\r\nprint_endline(aussie);\r\n```\r\n\r\n我们也可以访问嵌套模块！查看 `Team` 模块，它有一个嵌套的 `Boston` 模块。\r\n\r\n```ocaml\r\nprint_endline(Team.Boston.team);\r\n```\r\n\r\n虽然 Reason 有很好的模块推理 - 没有 `import` 概念！ - 使用 open 关键字明确地打开模块可能很有用。这将模块纳入作用域内。我们可以在本地为一个特定的函数打开一个模块，如下所示：\r\n\r\n```ocaml\r\nlet fact =\r\n  Team.Boston.(\r\n    switch (team) {\r\n      | \"Red Sox\" => \"The Red Sox are DOPE.\"\r\n      | _ => \"Eh, don't really care.\"\r\n    }\r\n  );\r\n\r\nprint_endline(fact);\r\n```\r\n\r\n全局打开对于在另一个模块中获取所有内容非常有用。但是要小心，如果模块中有共享名称的成员，这可能会引入不必要的命名冲突/阴影。\r\n\r\n```ocaml\r\nopen Team.Boston;\r\n```\r\n\r\n模块也可以相互扩展，在传统的 OOP 语言中履行继承或混合的角色。\r\n\r\n```ocaml\r\nmodule ExtendedBoston = {\r\n  include Team.Boston;\r\n  let basketball = \"Celtics\";\r\n};\r\n\r\nprint_endline(ExtendedBoston.team);\r\n\r\nprint_endline(ExtendedBoston.basketball);\r\n```\r\n\r\n### Promises\r\n\r\nReason 中的 Promises 通过使用 Js.Promise.* 方法的 BuckleScript 处理。注意。`.` 作为第一个参数传递到 `resolve` 。这可以让 BuckleScript 知道这是一个非柯里化函数。这是在 BuckleScript 2.2.2 中引入的。如果使用旧版本的 bs-platform ，则可以使用 `[@bs] resolve(100)` 获得相同的效果。\r\n\r\n```ocaml\r\nlet promise = Js.Promise.make((~resolve, ~reject as _) => resolve(. 100));\r\n\r\nexception Failure(string);\r\nlet failedPromise = Js.Promise.make((~resolve as _, ~reject) => reject(. Failure(\"Rejected!\")));\r\n\r\npromise\r\n|> Js.Promise.then_(res => {\r\n    Js.log(res);\r\n    Js.Promise.resolve(res);\r\n})\r\n|> Js.Promise.then_(res => {\r\n    Js.log(\"That's all folks!\");\r\n    Js.Promise.resolve(res - 100);\r\n})\r\n|> Js.Promise.catch(err => {\r\n    Js.log2(\"Failure!!\", err);\r\n    Js.Promise.resolve(-1);\r\n});\r\n\r\nfailedPromise\r\n|> Js.Promise.then_(res => {\r\n    Js.log(res)\r\n    Js.Promise.resolve(res);\r\n})\r\n|> Js.Promise.then_(res => {\r\n    Js.Promise.resolve(res - 100);\r\n})\r\n|> Js.Promise.catch(err => {\r\n    Js.log2(\"Failure!!\", err);\r\n    Js.Promise.resolve(-1);\r\n});\r\n```\r\n\r\n### 异常\r\n\r\n异常是一种特殊的变体，在 Reason 中不常使用。\r\n\r\n下面的函数展示了如何使用 `raise` 关键字使用 `Not_found`、`exception`。\r\n\r\n```ocaml\r\nlet aFunkyList = [\"Parliament\", \"Funkadelic\", \"George Clinton\"];\r\n  if (List.exists(item => item ===\"Stevie Wonder\", aFunkyList)) {\r\n    print_endline(\"Yay Stevie!\");\r\n  } else {\r\n    /* 在这里，我们引发 Exception 变体的 Not_found 构造函数。 */\r\n    raise(Not_found);\r\n  }\r\n```\r\n","source":"source\\_posts\\reason-basics.md"},{"title":"理解 CSS 特异性的复杂性","created":"2018/05/21","description":"理解 CSS 特异性的复杂性","author":"lanqy","link":"2018/05/21/understanding-the-complexity-of-css-specificity","htmlDir":"website\\2018\\05\\21\\understanding-the-complexity-of-css-specificity","htmlFile":"website\\2018\\05\\21\\understanding-the-complexity-of-css-specificity\\index.html","body":"# 理解 CSS 特异性的复杂性\r\n\r\n\r\n译自 http://cssdude.com/css/css-specificity/ \r\n\r\n\r\n CSS 特性是层叠样式表中最难理解的概念之一，并且通常应用于 CSS 开发的典型规则不适用于CSS特性。 为了正确编码并缩短所花的时间，您需要仔细考虑并理解您的代码将如何被浏览器解释。 为了确保您的代码可读，您需要完全理解 CSS 特性的工作原理。\r\n\r\n#### 什么是 CSS 特异性？\r\n\r\n简单来说，特定性指的是浏览器应用哪些 CSS 规则。 没有正确理解 CSS 的特殊性会导致一些规则在浏览器中不被应用，即使你可能认为它们是正确的。 特定性在层次结构上运行。 这个层次由四个不同的层次组成：\r\n\r\n- 内联样式 - 内联样式是直接附加到正在设计样式的元素上的样式。 它们是在您的XHTML文档中创建的\r\n- ID-这些 ID 是通常以 `#div` 表示的页面元素的标识符\r\n- 类+属性 - 类和属性使用：.classes 或 [attributes] 进行编码。 伪类通常包含在类和属性级别中\r\n- 元素 - 元素和伪元素将所有样式分配给上下文，它们是特定且独特的，允许您自发创建内容\r\n\r\n\r\n通常情况下，两个选择器在同一个元素上编写，但具有特殊性，这两个选择器都不适用。 元素呈现更高的特异性将是应用的元素，并将覆盖任何冲突规则或以前应用的规则。 如果这些选择器具有相同的特性值，则添加的最近一个是将应用的那个\r\n\r\n#### 了解CSS特定级别：\r\n\r\n嵌入式样式表比其他大多数规则具有更大的特异性。然而，ID 选择器将比属性选择器具有更高的特异性，并且您应该始终致力于始终使用 ID 选择器来提高特异性。类选择器将始终应用于任何元素选择器。通用选择器将具有 0,0,0,0 的特异性\r\n\r\n您可以使用 CSS 特异性计算器来帮助您计算 CSS 特异性，或者您可以应用一些简单的规则来帮助您更好地理解 CSS 特异性。 为了衡量特异性，从 0 开始，为每个内联样式属性添加 1000，对于添加的每个ID属性 100 ，对于添加的每个类或伪类属性10以及添加的任何元素 1。\r\n\r\n您可以通过使用 ID 选择器来制定更具体的规则。当您发现自己遇到 CSS 特定性问题时，请避免使用 ！important。这种编码只会覆盖正常的声明并且不会为样式表提供结构。相反，尝试限制包含的选择器或使规则更具体。\r\n\r\n\r\n一旦您了解了如何将特异性应用于您的编码，您可以更轻松地确保更好的设计。了解如何通过浏览器解释某些属性，元素和选择器将允许您创建更多功能和正确的设计。\r\n\r\n<table class=\"table table-bordered\">\r\n<tbody>\r\n<tr>\r\n<td>1</td>\r\n<td>* { }</td>\r\n<td>0</td>\r\n</tr>\r\n<tr class=\"pdd\">\r\n<td>2</td>\r\n<td>li { }</td>\r\n<td>1 ( 一个元素 )</td>\r\n</tr>\r\n<tr>\r\n<td>3</td>\r\n<td>li:first-line { }</td>\r\n<td>2 ( 一个元素，一个伪类)</td>\r\n</tr>\r\n<tr class=\"pdd\">\r\n<td>4</td>\r\n<td>ul li { }</td>\r\n<td>2 ( 两个元素 )</td>\r\n</tr>\r\n<tr>\r\n<td>5</td>\r\n<td>ul ol+li { }</td>\r\n<td>3 ( 三个元素 )</td>\r\n</tr>\r\n<tr class=\"pdd\">\r\n<td>6</td>\r\n<td>h1 + *[rel=up] { }</td>\r\n<td>11 ( 一个属性，一个元素 )</td>\r\n</tr>\r\n<tr>\r\n<td>7</td>\r\n<td>ul ol li.red { }</td>\r\n<td>13 ( 一个类，三个元素 )</td>\r\n</tr>\r\n<tr class=\"pdd\">\r\n<td>8</td>\r\n<td>li.red.level { }</td>\r\n<td>21 ( 两个类，一个元素 )</td>\r\n</tr>\r\n<tr>\r\n<td>9</td>\r\n<td>style=””</td>\r\n<td>1000 ( 一个内联样式 )</td>\r\n</tr>\r\n<tr class=\"pdd\">\r\n<td>10</td>\r\n<td>p { }</td>\r\n<td>1 (一个 HTML 选择器)</td>\r\n</tr>\r\n<tr>\r\n<td>11</td>\r\n<td>div p { }</td>\r\n<td>2 ( 两个 HTML 选择器 )</td>\r\n</tr>\r\n<tr class=\"pdd\">\r\n<td>12</td>\r\n<td>.sith</td>\r\n<td>10 ( 一个类选择器 )</td>\r\n</tr>\r\n<tr>\r\n<td>13</td>\r\n<td>div p.sith { }</td>\r\n<td>12 ( 两个HTML选择器和一个类选择器 )</td>\r\n</tr>\r\n<tr class=\"pdd\">\r\n<td>14</td>\r\n<td>#sith</td>\r\n<td>100 ( 一个id选择器 )</td>\r\n</tr>\r\n<tr>\r\n<td>15</td>\r\n<td>body #darkside .sith p { }</td>\r\n<td>112 ( HTML选择器，ID选择器，类选择器，HTML选择器 ; 1+100+10+1 )</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n\r\n","source":"source\\_posts\\understanding-the-complexity-of-css-specificity.md"},{"title":"一步一步教你创建 react redux 应用","created":"2018/05/21","description":"一步一步教你创建 react redux 应用","author":"lanqy","link":"2018/05/21/step-by-step-react-redux","htmlDir":"website\\2018\\05\\21\\step-by-step-react-redux","htmlFile":"website\\2018\\05\\21\\step-by-step-react-redux\\index.html","body":"# 一步一步教你创建 react redux 应用\r\n\r\nRedux 已经成为构建React应用的标配，有大量的实例展示它是怎样做到的，但是react-Redux 应用有很多部分，例如：“Reducers”, “Actions”, “Action Creators”, “State”, “Middleware” 等等)，这些都具有颠覆性的。\r\n\r\n当我开始学习它的时候，我找不到任何资料说明“构建react-Redux应用的时候，应该先构建哪个部分”或者一般怎样构建react－redux应用，因此我通过几个实例和文章来教你怎样一步步构建react－redux应用。\r\n<br/>\r\n\r\n注：我通过“模拟”以保持较高水平和不至于太杂乱。我将使用经典的<a href=\"https://github.com/reactjs/redux/tree/master/examples/todos\">Todo list app</a>作为基础来创建任何react应用。如果你的应用有多个（screens）界面，只需要重复这个步骤到你到界面中即可。\r\n\r\n### 为什么要用Redux?\r\n\r\nReact—一个JS库，帮助我们将我们的应用拆分为多个组件，但是没有具体说明如何保持数据（`state`）的轨迹以及如何正常处理我们的所有事件（`Actions`）。\r\n\r\nRedux—一个很受欢迎的库，为react提供一个可以轻松地保持数据（`state`）和事件（`actions`）。\r\n\r\n> 实际上，Redux允许我们以我们的方式创建React应用，然后委托所有的状态（state）和事件（actions）到Redux上。\r\n> 顺便说一个.一个简单到Todo应用，有八个步骤。理论上，早期的框架构建Todo应用很简单，但是做真实的应用比较难（这里指的是维护）。而React Redux做Todo应用就显得比较繁琐，但是真实的应用就比较方便（这里指的是维护）\r\n\r\n让我们开始吧！\r\n\r\n### 第一步－写一个详细的模拟\r\n\r\n这个模拟应该包含所有的数据和视觉效果（例如TodoItem的删除线，一个“All”的过滤器），\r\n\r\n第一步：模拟每个界面，\r\n\r\n怎样模拟：\r\n\r\n1、越详细越好，\r\n\r\n2、画出所有的数据和视觉效果（例如item删除线）。\r\n\r\n如下图：\r\n\r\n<img src=\"/images/1-RtA4NF2PI__vcarQgXEEBg.png\" />\r\n\r\n### 把应用划分成为组件\r\n\r\n尝试将应用划分为基于每个组件的用途的组件块。\r\n\r\n我们有三个组件“`AddTodo`”, “`TodoList`” and “`Filter`”组件。\r\n\r\n第二步：划分应用成为组件：\r\n\r\n怎样划分：基于它们的用途来划分。\r\n\r\n我们的应用有三个主要的“目的”：\r\n\r\n1、添加一个新的Todo 项目（AddTodo组件）\r\n\r\n2、展示Todo列表（TodoList组件）\r\n\r\n3、过滤展示Todos（Filter组件）\r\n\r\n如下图：\r\n\r\n<img src=\"/images/1-AfzFa8zO_dQOmuSHL7bEww.png\" />\r\n\r\n### Redux术语：“`Actions`”和“`States`”\r\n\r\n##### 每个组件做这两件事情：\r\n\r\n 1、根据一些数据渲染DOM，这些数据，我们称之为状态（`state`）。\r\n\r\n 2、监听用户和事件并发送到一个JS方法，我们称之为操作（`actions`）。\r\n\r\n### 第三步－列出每个组件的`States`和`Actions`\r\n\r\n我们通过第二步来仔细看看每一个组件，并列出它们每个的`States`和`Actions`。\r\n\r\n我们有三个组件，分别为“`AddTodo`”, “`TodoList`” and “`Filter`”组件，让我们列出它们每个的`States`和`Actions`。\r\n\r\n* 3.1 AddTodo 组件的`State` 和 `Actions`\r\n\r\n这个部分，我们没有任何状态（`state`），这个组件不依赖任何数据或状态来改变外观，但是它需要让其它组件知道，当用户创建一个新的Todo的时候。让我们叫这个action为`ADD_TODO`\r\n\r\n\r\nAddTodo组件\r\n State：\r\n 1.(一个简单的输入框和一个按钮，不依赖于任何数据来展示)\r\n Actions（events）：\r\n 1.AddTodo组件允许我们创建一个新的Todo项目通过监听DOM事件和从输入框获取数据。这个事件映射到JSON对象，我们称之为Action。\r\n\r\n 在这个案例中，我们可以通过创建一个JSON对象来描述我们的AddTodo action,JSON如下：\r\n\r\n```javascript\r\n {\r\n  type:'ADD_TODO'\r\n  payload:{\r\n    data:'Learn Redux',\r\n    id:1,\r\n    completed:false\r\n  }\r\n }\r\n\r\n```\r\n如下图：\r\n\r\n<img src=\"/images/1-OrfmEw_gPw5kQ3ZO5AjzEQ.png\" />\r\n\r\n* 3.2 TodoList 组件的`State` 和 `Actions`\r\n\r\nTodoList组件需要一个数组来展示数据，因此它需要一个状态（`state`）,我们称之为Todos（数组）。它也需要知道哪一个过滤器被触发，以相应的显示或隐藏Todo 项目，因此还需要一个状态（`state`）,让我们称之为`VisibilityFilter`（布尔值）。\r\n\r\n进一步，它允许我们切换Todo项目为已完成或未完成状态。我们也需要让其它组件知道切换这个状态。我们把这个action叫做“`TOGGLE_TODO`”\r\n\r\nTodoList组件：\r\n\r\nState：\r\n\r\n1、Todos数组\r\n\r\n2、Visibility filter（显示过滤器），这个告诉那种类型的Todo项目需要显示或者隐藏。注：这个来自于“Filter”组件。\r\n\r\nActions（events）：\r\n\r\nTodoList组件只有一个action，它允许用户切换Todo项目的完成状态，当用户点击到每个Todo项目时，它需要告诉其它到组件和数据库等切换Todo的状态。\r\n\r\n我们需要通过JSON对象来描述我们的ToggleTodo action,JSON如下：\r\n\r\n`\r\n{\r\n type:\"TOGGLE_TODO\"\r\n payload:{\r\n  id:<todoItem's id >\r\n }\r\n}\r\n`\r\n\r\n如下图：\r\n\r\n<img src=\"/images/1-waJ9BucAT9qW_sHcqNOB_Q.png\" />\r\n\r\n* 3.3 Filter 组件的`State` 和 `Actions`\r\n\r\nFilter组件可以是一个链接或者一个简单的文本来渲染，但它依赖于是否激活，我们把这个状态（`state`）称之为“`CurrentFilter`”。\r\n\r\nFilter组件依然需要告诉其它组件用户什么时候点击它，我们把这个操作(`action`)称之为“`SET_VIBILITY_FILTER`”。\r\n\r\n\r\nFilter组件：\r\n\r\nState(data)：\r\n\r\n1.CurrentFilter－一个字符串，拥有告诉哪个过滤器需要显示，哪个链接可点击，例如“Active”和“completed”\r\n\r\nActions（events）：\r\n\r\nFilter组件也只有一个操作（action），它只是监听用户点击过滤器点链接并告诉其它组件哪个链接已经被点击。\r\n\r\n我们通过一个JSON对象来描述`SET_VIBILITY_FILTER`操作（action），JSON如下：\r\n\r\n{\r\n type:\"SET_VIBILITY_FILTER\"\r\n payload:{\r\n filter:\"Completed\"\r\n }\r\n}\r\n\r\n如下图：\r\n\r\n<img src=\"/images/1-3G9ycPVPovZPu35rGW3FLw.png\" />\r\n\r\n### Redux术语“```Action Creators```”\r\n\r\n`Action Creators`是一些简单的方法用于从DOM事件中接受数据，格式化为标准的JSON“`Action`”。对象并返回这个对象（又称`Action`），这个帮助我们正规化我们的数据的样子。\r\n\r\n进一步，它允许未来任何组件发送到这些Actions到其它组件去（又成为`dispatch`［调度］）。\r\n\r\n### 第四步，为每个`Action`创建`Action Creators`\r\n\r\n我们统计一共有三个`Action`:`ADD_TODO, TOGGLE_TODO and SET_VISIBILITY_FILTER`。让我们为它们每个创建`Action`:\r\n\r\n```javascript\r\n//1. 从AddTodo文本域获取文本并返回正确的“Action” JSON对象发送到其它到组件中。（Takes the text from AddTodo field and returns proper “Action” JSON to send to other components.）\r\nexport const addTodo = (text) => {\r\n return {\r\n type: ‘ADD_TODO’,\r\n id: nextTodoId++,\r\n text,  //<--ES6. same as text:text, in ES5（这个是ES6的写法，相当于ES5的text:text）\r\n completed: false //<-- initially this is set to false (completed字段初始化为false)\r\n }\r\n}\r\n\r\n//2. 获取filter 字符串并返回正确的“Action” JSON对象发送到其它组件中。（Takes filter string and returns proper “Action” JSON object to send to other components.）\r\nexport const setVisibilityFilter = (filter) => {\r\n return {\r\n type: ‘SET_VISIBILITY_FILTER’,\r\n filter\r\n }\r\n}\r\n\r\n//3. 获取Todo 项目的id并返回正确的“Action” JSON对象发送到其它组件中。（Takes Todo item’s id and returns proper “Action” JSON object to send to other components.）\r\nexport const toggleTodo = (id) => {\r\n return {\r\n type: ‘TOGGLE_TODO’,\r\n id\r\n }\r\n}\r\n```\r\n\r\n### Redux术语“`Reducers`”\r\n\r\n`Reducers`是一些方法，用于从`redux`和“`action`” JSON对象中获取状态（`state`）并返回新的状态（`state`）存回Redux中。\r\n\r\n1、当用户操作时，Reducers方法会被“`Container`”触发［这句好难翻啊，估计翻不对］（Reducer functions are called by the “Container” containers when there is a user action）。\r\n\r\n2、如果`reducer```改变了状态（`state`），Redux传递新的状态（new state）到每个组件并且React重新渲染每个组件。\r\n\r\n```javascript\r\n//(For example the below function takes Redux’ state(an array of previous todos), and returns a **new** array of todos(new state) w/ the new Todo added if action’s type is “ADD_TODO”.)\r\n// 例如下面这个方法获取Redux 状态（一个之前的todos数组），并返回一个新的todos数组（new state），当action's的类型为“ADD_TODO”时，一个新的Todo就会被添加\r\nconst todo = (state = [], action) => {\r\n switch (action.type) {\r\n  case ‘ADD_TODO’:\r\n     return\r\n       […state,{id: action.id, text: action.text, completed:false}];\r\n }\r\n```\r\n\r\n### 第五步，为每个`Action`写`Reducers`\r\n\r\n注：为简洁起见，一些代码已经被简化了,另外我简单当展示一下`SET_VISIBILITY_FILTER`、`ADD_TODO` 和 `TOGGLE_TODO` ，代码如下：\r\n\r\n```javascript\r\nconst todo = (state, action) => {\r\n  switch (action.type) {\r\n     case ‘ADD_TODO’:\r\n      return […state,{id: action.id, text: action.text,\r\n              completed:false}]\r\n\r\n     case ‘TOGGLE_TODO’:\r\n        return state.map(todo =>\r\n                if (todo.id !== action.id) {\r\n                  return todo\r\n                }\r\n                 return Object.assign({},\r\n                    todo, {completed: !todo.completed})\r\n            )\r\n\r\n      case ‘SET_VISIBILITY_FILTER’: {\r\n       return action.filter\r\n      }\r\n\r\n     default:\r\n      return state\r\n    }\r\n}\r\n```\r\n### Redux术语“`Presentational`”和“`Container`”组件\r\n\r\n把React和Redux的逻辑放在每个组件里是很混乱的，因此Redux建议创建一个假的仅仅包含组件的展示型组件和一个父级包装组件就做容器型组件负责Redux的`Actions`调度等等。\r\n\r\n然后父级容器将数据传递到展示型组件，事件处理替展示型组件处理React，如下图：\r\n\r\n<img src=\"/images/1-inU9OmAFSDYKFm8pstsCDw.png\" />\r\n\r\n说明：黄色点线代表展示型组件，黑色点线表示容器型组件。\r\n\r\n###第六步－实现所有的展示型组件\r\n\r\n现在是时候实现我们所有的（3个）展示型组件了\r\n\r\n6.1 实现AddTodoForm组件\r\n\r\n```\r\nAddTodoForm组件：\r\n这个组件渲染一个输入框和一个按钮，它接收一个onSubmit回调方法（来自父级容器组件）当用户提交一个新的Todo时，它发送和传递todo文本到onSubmit方法中\r\n```\r\n```javascript\r\nlet AddTodoForm = ({onSubmit}) => {\r\n let input\r\n return(\r\n  <div>\r\n   <form onSubmit={e=>{onSubmit(input.value)}}>\r\n    <input ref={node = >{input = node}} />\r\n    <button type=\"submit\">Add Todo</button>\r\n   </form>\r\n  </div>\r\n )\r\n}\r\nexport default AddTodoForm\r\n```\r\n如下图：\r\n\r\n<img src=\"/images/1-WlASUkXRWSGaFZdZJXXiRQ.png\" />\r\n\r\n6.2 实现TodoList组件\r\n\r\nTodoList组件:\r\n\r\n这个组件渲染一个Todo列表，它接受`Todos`数组和一个`onTodoClick`回调方法（来自父级容器组件）。当用户点击每个Todo项目时，它发送Todo项\r\n\r\n目的id到`onTodoClick`方法中并切换这个被点击的项目的状态。\r\n\r\n```javascript\r\nconst TodoList = ({todos,onTodoClick})=>{\r\nif(todos.length === 0)\r\n return <div>Add Todos</div>\r\nreturn <ul>\r\n{todos.map(todo=>\r\n <Todo key={todo.id}{...todo} onClick={()=>onTodoClick(todo.id)} />\r\n)}\r\n</ul>\r\n}\r\n\r\nexport default TodoList\r\n```\r\n如下图：\r\n\r\n<img src=\"/images/1-u1CX5abgafgbt3x-IgJ36A.png\" />\r\n\r\n6.2 实现Link组件\r\n\r\n\r\nLink组件：\r\n\r\n这个组件渲染个别链接，分别有三个链接，它接收“active”布尔值并渲染一个文本或者链接，它接收children属性来显示链接的名称，它也接收一\r\n\r\n个onClick回调方法，当链接被点击的时候会被调用。\r\n\r\n```javascript\r\nconst Link = ({active,children,onClick}) = >{\r\n   if(active){\r\n     return <span>{children}</span>\r\n   }\r\n   return <a href=\"#\" onClick={e =>{onClick()}}>{children}</a>\r\n}\r\nexport default Link\r\n```\r\n如下图：\r\n<img src=\"/images/1-5WQbEnAhRP6fmfiCjOeS4A.png\" />\r\n\r\n注意：在实际的代码中，Link展示组件被包含在`FilterLink`容器组件中，进而3个FilterLink组件显示在Footer展示组件中。\r\n\r\n### 第七步－为部分或者全部展示组件创建容器组件\r\n\r\n最后，为每个组件创建Redux链接\r\n\r\n7.1创建容器组件（AddTodo组件）\r\n\r\n<a href=\"https://github.com/rajaraodv/redux/blob/master/examples/todos/containers/AddTodo.js\">最后实际的代码在这里</a>\r\n\r\n<img src=\"/images/1-ElBMxdAUzuVJ343uAlCVmA.png\" />\r\n\r\n7.2创建容器组件（TodoList组件）\r\n\r\n<a href=\"https://github.com/rajaraodv/redux/blob/master/examples/todos/containers/VisibleTodoList.js\">最后实际的代码在这里</a>\r\n\r\n<img src=\"/images/1-malT38rul36L0Ygbt1JjzA.png\" />\r\n\r\n7.3创建容器组件（Filter组件）\r\n\r\n<a href=\"https://github.com/rajaraodv/redux/blob/master/examples/todos/containers/FilterLink.js\">最后实际的代码在这里</a>\r\n\r\n<img src=\"/images/1-1Kgo8pIxbLAkuBho6aQQeQ.png\" />\r\n\r\n注意：在实际的代码中，Link展示组件被包含在`FilterLink`容器组件中，进而3个FilterLink组件排列和显示在Footer展示组件中。\r\n\r\n###第八步－把它们放在一起\r\n\r\n```javascript\r\nimport React from ‘react’ // ← Main React library\r\nimport { render } from ‘react-dom’ // ← Main react library\r\nimport { Provider } from ‘react-redux’ //← Bridge React and Redux\r\nimport { createStore } from ‘redux’ // ← Main Redux library\r\nimport todoApp from ‘./reducers’ // ← List of Reducers we created\r\n//Import all components we created earlier\r\nimport AddTodo from ‘../containers/AddTodo’\r\nimport VisibleTodoList from ‘../containers/VisibleTodoList’\r\nimport Footer from ‘./Footer’ // ← （这个是一个展示型组件，包含三个FilterLink容器组件）This is a presentational component that contains 3 FilterLink Container comp\r\n//Create Redux Store by passing it the reducers we created earlier.(创建Redux store树，传入reducers)\r\nlet store = createStore(reducers)\r\nrender(\r\n <Provider store={store}> //← （react-redux的提供组件，用于将store注入到所有到子组件中）The Provider component from react-redux injects the store to all the child components\r\n <div>\r\n <AddTodo />\r\n <VisibleTodoList />\r\n <Footer />\r\n </div>\r\n </Provider>,\r\n document.getElementById(‘root’) //<-- Render to a div w/ id \"root\"\r\n)\r\n```\r\n就是这样！\r\n\r\n注：本文翻译自<a href=\"https://medium.com/@rajaraodv/step-by-step-guide-to-building-react-redux-apps-using-mocks-48ca0f47f9a#.kljg6fuei\">Step by Step Guide To Building React Redux Apps</a>，有翻译不对的地方，欢迎指正，谢谢！\r\n","source":"source\\_posts\\step-by-step-react-redux.md"},{"title":"Linux 下重新启动 Nginx web 服务器","created":"2018/05/21","description":"Linux 下重新启动 Nginx web 服务器","author":"lanqy","link":"2018/05/21/nginx-linux-restart","htmlDir":"website\\2018\\05\\21\\nginx-linux-restart","htmlFile":"website\\2018\\05\\21\\nginx-linux-restart\\index.html","body":"# Linux 下重新启动 Nginx web 服务器\r\n\r\n译自 https://www.cyberciti.biz/faq/nginx-linux-restart/\r\n\r\n\r\n如何使用命令行选项在 Linux 或 Unix 操作系统下重新启动 nginx Web 服务器？ 要重新启动 nginx Web 服务器，请以 root 用户身份使用以下任一命令。打开终端或使用 ssh 登录到远程服务器。\r\n\r\n### Debian / Ubuntu / RHEL / CentOS Linux\r\n\r\n使用以下命令：\r\n\r\n```nginx\r\n/etc/init.d/nginx restart\r\n```\r\n\r\n或者\r\n\r\n```nginx\r\n/etc/init.d/nginx reload\r\n```\r\n\r\n或者\r\n\r\n```nginx\r\nservive nginx restart\r\n```\r\n\r\n或者\r\n\r\n```nginx\r\nservice nginx reload\r\n```\r\n或者如果您使用基于 systemd 的 Linux 发行版：\r\n\r\n```nginx\r\nsudo systemctl restart nginx\r\n```\r\n\r\n或者\r\n\r\n```nginx\r\nsudo systemctl reload nginx\r\n```\r\n\r\n查看状态\r\n\r\n```nginx\r\nservice nginx status\r\n```\r\n\r\n或者\r\n\r\n```nginx\r\nsudo systemctl status nginx\r\n```\r\n\r\n但是，推荐方法如下。这应该适用于任何 Linux 发行版或类 Unix 操作系统：\r\n\r\n```nginx\r\nnginx -s reload\r\n```\r\n\r\n或者\r\n\r\n```nginx\r\n/path/to/full/nginx -s reload\r\n```\r\n\r\n#### 如果 nginx 编译并从源代码安装\r\n\r\n如果 nginx 二进制文件安装在 /usr/local/nginx/sbin/nginx 中，请输入：\r\n\r\n```nginx\r\n/usr/local/nginx/sbin/nginx -s reload\r\n```\r\n\r\n","source":"source\\_posts\\nginx-linux-restart.md"},{"title":"用 Javascript 编写一个编译器","created":"2018/05/21","description":"用 Javascript 编写一个编译器","author":"lanqy","link":"2018/05/21/make-a-compiler-with-javascript","htmlDir":"website\\2018\\05\\21\\make-a-compiler-with-javascript","htmlFile":"website\\2018\\05\\21\\make-a-compiler-with-javascript\\index.html","body":"# 用 Javascript 编写一个编译器\r\n\r\n译自： https://medium.com/@kosamari/how-to-be-a-compiler-make-a-compiler-with-javascript-4a8a13d473b4#.evrubxdub\r\n\r\n在布鲁克林 布什威克的一个美好的星期天，我在本地书店发现了一本John Maeda写的“数字设计”的书，这本书里一步一步的教DBN编程语言--一种90年代末在麻省理工学院媒体实验室诞生的语言，旨在以可视化的方式介绍计算机编程概念。\r\n<img src=\"/images/dbn.png\" />\r\n\r\nDNB 代码示例 来自 http://dbn.media.mit.edu/introduction.html\r\n\r\n我迫切地想让SVG来实现DBN并运行它在浏览器在2016年将是一个有趣的项目,而不是安装Java环境执行原始DBN源代码。\r\n\r\n我想我需要些一个DBN到SVG的编译器，所以编写一个编译器的任务已经开始。 “写一个编译器”听起来像很多计算机科学...但我从来没有接触过这方面，我可以写一个编译器吗？\r\n\r\n### 让我们先试着做一个编译器\r\n\r\n编译器是一种采用一段代码并将其转换为其他代码的机制。 让我们将简单的DBN代码编译成一个物理图。\r\n\r\n在这个DBN代码中有3个命令，“Paper”定义纸张的颜色，“Pen”定义笔的颜色，“Line”画一条线。 颜色参数100表示CSS中的100％黑色或rgb（0％，0％，0％）。 在DBN中产生的图像总是灰度的。 在DBN中，纸张始终为100×100，线宽始终为1，并且线由起点的x y坐标和从左下角计数的终止点定义。\r\n\r\n让我们试着成为一个编译器自己。 停在这里，抓住一张纸和一支钢笔，尝试编译以下代码作为绘图。\r\n\r\n```js\r\nPaper 0\r\nPen 100\r\nLine 0 50 100 50\r\n```\r\n\r\n你在中间从左侧到右侧画了一条黑线吗？ 恭喜！ 你刚刚实现了一个编译器。\r\n\r\n<img src=\"/images/1-aDJskliFHSIIfYhr8aN3UA.png\" />\r\n<p style=\"color:gray; font-size: 80%; text-align: center;\">编译结果</p>\r\n\r\n### 编译器是怎样工作的？\r\n\r\n让我们来看看刚才在编译器中发生了什么。\r\n\r\n#### 1.词汇分析（标记化）\r\n\r\n我们做的第一件事是用空格分隔每个关键字（称为tokens）。 当我们分离单词时，我们还为每个标记分配了原始类型，如“word”或“number”。\r\n\r\n<img src=\"/images/1-lM4hjuI28Dodn-DfnXQu4A.png\" />\r\n\r\n#### 2.解析（语法分析）\r\n\r\n一旦一个文本块被分成tokens，我们就经历了每一个文本，并试图找到tokens之间的关系。\r\n在这种情况下，我们将与command关键字相关联的数字分组在一起。 通过这样做，我们开始看到代码的结构。\r\n\r\n<img src=\"/images/1-Masaunh04PyclWIGhztHmg.png\" />\r\n\r\n#### 3.转换\r\n\r\n一旦我们通过解析分析语法，我们将结构转换为适合最终结果的结构。 在这个案例中，我们将绘制一个图像，所以我们将把它一步一步转换为人类的语言。\r\n\r\n<img src=\"/images/1-ExV6vUNKZ4-IpG15-CAeFw.png\" alt=\"\" />\r\n\r\n#### 4.代码生成\r\n\r\n最后，我们制作一个编译结果，一个绘图。 在这一点上，我们只是按照我们在上一步中绘制的指令。\r\n\r\n<img src=\"/images/1-250m-6zI6slTBirOxHX7kw.png\" alt=\"\" />\r\n\r\n这是编译器做的！\r\n\r\n我们做的图是编译结果（当你编译C代码时像.exe文件）。 我们可以把这张图纸传递给任何人或任何设备（扫描仪，相机等）来“运行”，每个人（或设备）都会在中间看到一条黑线。\r\n\r\n### 让我们写一个编译器\r\n\r\n现在我们知道编译器如何工作，让我们在JavaScript中做一个。 此编译器使用DBN代码并将其转换为SVG代码。\r\n\r\n#### 1.Lexer方法\r\n\r\n正如我们可以将英语句子“I have a pen”分割为[I，have，a，pen]，词法分析器将一个代码字符串拆分成小的有意义的块（token）。 在DBN中，每个token由空格分隔，并分类为“word”或“number”。\r\n\r\n```js\r\nfunction lexer (code) {\r\n  return code.split(/\\s+/)\r\n          .filter(function (t) { return t.length > 0 })\r\n          .map(function (t) {\r\n            return isNaN(t)\r\n                    ? {type: 'word', value: t}\r\n                    : {type: 'number', value: t}\r\n          })\r\n}\r\n```\r\n\r\n```js\r\n输入: \"Paper 100\"\r\n输出:[\r\n  { type: \"word\", value: \"Paper\" }, { type: \"number\", value: 100 }\r\n]\r\n```\r\n\r\n#### 2.Parser方法\r\n\r\n解析器通过每个标记，找到语法信息，并构建一个称为AST（抽象语法树）的对象。 你可以把AST看作我们代码的映射 - 一种理解一段代码结构的方法。\r\n在我们的代码中，有2种语法类型“NumberLiteral”和“CallExpression”。 NumberLiteral表示该值是一个数字。 它用作CallExpression的参数。\r\n\r\n```js\r\nfunction parser (tokens) {\r\n  var AST = {\r\n    type: 'Drawing',\r\n    body: []\r\n  }\r\n  // extract a token at a time as current_token. Loop until we are out of tokens.\r\n  while (tokens.length > 0){\r\n    var current_token = tokens.shift()\r\n\r\n    // Since number token does not do anything by it self, we only analyze syntax when we find a word.\r\n    if (current_token.type === 'word') {\r\n      switch (current_token.value) {\r\n        case 'Paper' :\r\n          var expression = {\r\n            type: 'CallExpression',\r\n            name: 'Paper',\r\n            arguments: []\r\n          }\r\n          // if current token is CallExpression of type Paper, next token should be color argument\r\n          var argument = tokens.shift()\r\n          if(argument.type === 'number') {\r\n            expression.arguments.push({  // add argument information to expression object\r\n              type: 'NumberLiteral',\r\n              value: argument.value\r\n            })\r\n            AST.body.push(expression)    // push the expression object to body of our AST\r\n          } else {\r\n            throw 'Paper command must be followed by a number.'\r\n          }\r\n          break\r\n        case 'Pen' :\r\n          ...\r\n        case 'Line':\r\n          ...\r\n      }\r\n    }\r\n  }\r\n  return AST\r\n}\r\n```\r\n\r\n```js\r\n输入: [\r\n  { type: \"word\", value: \"Paper\" }, { type: \"number\", value: 100 }\r\n]\r\n输出: {\r\n  \"type\": \"Drawing\",\r\n  \"body\": [{\r\n    \"type\": \"CallExpression\",\r\n    \"name\": \"Paper\",\r\n    \"arguments\": [{ \"type\": \"NumberLiteral\", \"value\": \"100\" }]\r\n  }]\r\n}\r\n```\r\n\r\n#### 3. Transformer 方法\r\n\r\n我们在前面的步骤中创建的AST很好地描述代码中发生了什么，但是它没有用于创建SVG文件。\r\n例如。 “纸张”是一个只存在于DBN范例中的概念。 在SVG中，我们可以使用<rect>元素来表示一个Paper。 变换函数将AST转换为另一个支持SVG的AST。\r\n\r\n```js\r\nfunction transformer (ast) {\r\n  var svg_ast = {\r\n    tag : 'svg',\r\n    attr: {\r\n      width: 100, height: 100, viewBox: '0 0 100 100',\r\n      xmlns: 'http://www.w3.org/2000/svg', version: '1.1'\r\n    },\r\n    body:[]\r\n  }\r\n\r\n  var pen_color = 100 // default pen color is black\r\n\r\n  // Extract a call expression at a time as `node`. Loop until we are out of expressions in body.\r\n  while (ast.body.length > 0) {\r\n    var node = ast.body.shift()\r\n    switch (node.name) {\r\n      case 'Paper' :\r\n        var paper_color = 100 - node.arguments[0].value\r\n        svg_ast.body.push({ // add rect element information to svg_ast's body\r\n          tag : 'rect',\r\n          attr : {\r\n            x: 0, y: 0,\r\n            width: 100, height:100,\r\n            fill: 'rgb(' + paper_color + '%,' + paper_color + '%,' + paper_color + '%)'\r\n          }\r\n        })\r\n        break\r\n      case 'Pen':\r\n        pen_color = 100 - node.arguments[0].value // keep current pen color in `pen_color` variable\r\n        break\r\n      case 'Line':\r\n        ...\r\n    }\r\n  }\r\n  return svg_ast\r\n }\r\n```\r\n\r\n```js\r\n输入: {\r\n  \"type\": \"Drawing\",\r\n  \"body\": [{\r\n    \"type\": \"CallExpression\",\r\n    \"name\": \"Paper\",\r\n    \"arguments\": [{ \"type\": \"NumberLiteral\", \"value\": \"100\" }]\r\n  }]\r\n}\r\n输出: {\r\n  \"tag\": \"svg\",\r\n  \"attr\": {\r\n    \"width\": 100,\r\n    \"height\": 100,\r\n    \"viewBox\": \"0 0 100 100\",\r\n    \"xmlns\": \"http://www.w3.org/2000/svg\",\r\n    \"version\": \"1.1\"\r\n  },\r\n  \"body\": [{\r\n    \"tag\": \"rect\",\r\n    \"attr\": {\r\n      \"x\": 0,\r\n      \"y\": 0,\r\n      \"width\": 100,\r\n      \"height\": 100,\r\n      \"fill\": \"rgb(0%, 0%, 0%)\"\r\n    }\r\n  }]\r\n}\r\n```\r\n#### 4. Generator 函数\r\n\r\n作为这个编译器的最后一步，generator函数创建基于我们在上一步中创建的新AST的SVG代码。\r\n\r\n```js\r\nfunction generator (svg_ast) {\r\n\r\n  // create attributes string out of attr object\r\n  // { \"width\": 100, \"height\": 100 } becomes 'width=\"100\" height=\"100\"'\r\n  function createAttrString (attr) {\r\n    return Object.keys(attr).map(function (key){\r\n      return key + '=\"' + attr[key] + '\"'\r\n    }).join(' ')\r\n  }\r\n\r\n  // top node is always <svg>. Create attributes string for svg tag\r\n  var svg_attr = createAttrString(svg_ast.attr)\r\n\r\n  // for each elements in the body of svg_ast, generate svg tag\r\n  var elements = svg_ast.body.map(function (node) {\r\n    return '<' + node.tag + ' ' + createAttrString(node.attr) + '></' + node.tag + '>'\r\n  }).join('\\n\\t')\r\n\r\n  // wrap with open and close svg tag to complete SVG code\r\n  return '<svg '+ svg_attr +'>\\n' + elements + '\\n</svg>'\r\n}\r\n```\r\n\r\n```js\r\n输入: {\r\n  \"tag\": \"svg\",\r\n  \"attr\": {\r\n    \"width\": 100,\r\n    \"height\": 100,\r\n    \"viewBox\": \"0 0 100 100\",\r\n    \"xmlns\": \"http://www.w3.org/2000/svg\",\r\n    \"version\": \"1.1\"\r\n  },\r\n  \"body\": [{\r\n    \"tag\": \"rect\",\r\n    \"attr\": {\r\n      \"x\": 0,\r\n      \"y\": 0,\r\n      \"width\": 100,\r\n      \"height\": 100,\r\n      \"fill\": \"rgb(0%, 0%, 0%)\"\r\n    }\r\n  }]\r\n}\r\n输出:\r\n<svg width=\"100\" height=\"100\" viewBox=\"0 0 100 100\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\r\n  <rect x=\"0\" y=\"0\" width=\"100\" height=\"100\" fill=\"rgb(0%, 0%, 0%)\">\r\n  </rect>\r\n</svg>\r\n```\r\n\r\n#### 5.整合所有代码在一起\r\n\r\n让我们称这个编译器为“sbn编译器”（SVG由数字编译器）。\r\n我们使用词法分析器，解析器，变换器和生成器方法创建一个sbn对象。 然后添加一个“编译”方法来调用链中的所有4个方法。\r\n我们现在可以将代码字符串传递给编译方法并获取SVG。\r\n\r\n```js\r\nvar sbn = {}\r\nsbn.VERSION = '0.0.1'\r\nsbn.lexer = lexer\r\nsbn.parser = parser\r\nsbn.transformer = transformer\r\nsbn.generator = generator\r\n\r\nsbn.compile = function (code) {\r\n  return this.generator(this.transformer(this.parser(this.lexer(code))))\r\n}\r\n\r\n// call sbn compiler\r\nvar code = 'Paper 0 Pen 100 Line 0 50 100 50'\r\nvar svg = sbn.compile(code)\r\ndocument.body.innerHTML = svg\r\n```\r\n\r\n我做了一个<a href=\"https://kosamari.github.io/sbn/\">交互式演示</a>，显示此编译器中的每个步骤的结果。 sbn编译器的代码发布在<a href=\"https://github.com/kosamari/sbn\">github</a>上。 我现在在编译器中添加更多的功能。 如果你想看我们在这篇文章中做的基本编译器，请查看<a href=\"https://github.com/kosamari/sbn/tree/simple\">简单的分支</a>。\r\n\r\n<img src=\"/images/1-7ADpMcLo1VOnW4-fF2vjDg.png\" />\r\nhttps://kosamari.github.io/sbn/\r\n\r\n### 编译器应不应该使用递归和遍历等？\r\n\r\n是的，这些都是精彩的技术来构建一个编译器，但这并不意味着你必须优先采取这种方法。\r\n\r\n我开始为DBN编程语言的一个小子集编译器，一个非常有限的小功能集。 从那时起，我扩展了范围，现在规划添加功能，如变量，代码块和循环到这个编译器。 在这一点上使用这些技术是一个好主意，但这不是开始的要求。\r\n\r\n### 写编译器是很棒的一件事\r\n\r\n你可以通过自己的编译器做什么？ 也许你可能想在西班牙语中制作新的类似JavaScript的语言...español脚本如何？\r\n\r\n```js\r\n// ES (español script)\r\nfunción () {\r\n  si (verdadero) {\r\n    return «¡Hola!»\r\n  }\r\n}\r\n```\r\n任何事情都是有可能的，这里有人使用<a href=\"http://www.emojicode.org/\">Emoji（表情符号代码）</a>和<a href=\"http://www.dangermouse.net/esoteric/piet.html\">彩色图像（Piet编程语言）</a>开发变成语言。\r\n\r\n## 学习编写编译器中学到了什么？\r\n\r\n编译器很有趣，但最重要的是，它教会了我很多关于软件开发。 这里有几个我在学习编译器时学到的东西。\r\n<img src=\"/images/1-AREFc7UVIAu_YIgk46EwaA.png\" />\r\n\r\n我怎么想象自己做一个编译器\r\n\r\n#### 1.不熟悉的东西没关系\r\n\r\n就像我们的词法分析程序,你不需要一开始就知道它。如果你不真正理解一段代码或技术,可以直接说“这我知道”，并且继续下一个步骤。不要有压力,最终你会知道。\r\n\r\n#### 2.尽量友好提示错误信息\r\n\r\n解析器的作用是遵循规则并检查是否按照这些规则输入内容。 所以很多时候错误发生时，尝试发送有用的消息和提示语。 很容易说“它不工作的方式”（像“ILLEGAL Token”或“undefined is not a function” 的错误JavaScript），但相反，尽可能地告诉用户发生了什么。\r\n\r\n这也适用于团队沟通。 当有人被困在一个问题，而不是说“是的，不工作”，也许你可以开始说“我会google关键字，如___和___。”或“我建议阅读这个页面上的文档” 需要为他们做工作，但你当然可以帮助他们通过提供一点点帮助更好更快地完成工作。\r\n\r\nElm是一个拥抱<a href=\"http://elm-lang.org/blog/compiler-errors-for-humans\">这种方法</a>的编程语言。 他们在他们的错误信息中写了“也许你想试试这个？\r\n\r\n#### 3.上下文是一切\r\n\r\n最后，就像我们的变换器将一种类型的AST转换为另一种更适合的最终结果，一切都是上下文特定的。\r\n\r\n没有一个完美的方式来做事情。 不要因为这个事情它是流行的或你以前做过才去做，先考虑上下文。 对一个用户工作的事情可能是另一个用户的灾难。\r\n\r\n此外，欣赏这些转换器做的工作。 你可能知道你的团队中的转换器 - 一个真正善于弥合差距的人。 转换器的这些工作可能不直接创造代码，但它是生产优质产品的一个重要的工作。\r\n\r\n希望你喜欢这篇文章，也希望我说服你开发一个编译器是一件很棒的事情！\r\n\r\n这是我在哥伦比亚的JSConf哥伦比亚2016年在哥伦比亚麦德林举行的演讲的摘录。 如果你想了解该演讲，请在这里<a href=\"http://kosamari.com/presentation/jsconfcolombia-2016/#0\">查看幻灯片</a>。\r\n\r\n\r\n\r\n","source":"source\\_posts\\make-a-compiler-with-javascript.md"},{"title":"通过代数数据类型和模式匹配进行语言比较：Koka，Rust，Haxe，Swift，Elm，PureScript，Haskell，OCaml，ReasonML，Kotlin，Scala，Dotty，Ruby，TypeScript","created":"2018/05/21","description":"通过代数数据类型和模式匹配进行语言比较：Koka，Rust，Haxe，Swift，Elm，PureScript，Haskell，OCaml，ReasonML，Kotlin，Scala，Dotty，Ruby，TypeScript","author":"lanqy","link":"2018/05/21/language-comparison","htmlDir":"website\\2018\\05\\21\\language-comparison","htmlFile":"website\\2018\\05\\21\\language-comparison\\index.html","body":"# 通过代数数据类型和模式匹配进行语言比较：Koka，Rust，Haxe，Swift，Elm，PureScript，Haskell，OCaml，ReasonML，Kotlin，Scala，Dotty，Ruby，TypeScript\r\n\r\n## 代数数据类型\r\n\r\n### Koka\r\n\r\n```haskell\r\ntype color {\r\n  Red\r\n  Green\r\n  Blue\r\n  Rgb( r : int, g : int, b: int )\r\n}\r\n```\r\n\r\n或\r\n\r\n```haskell\r\ntype color {\r\n  Red; Green; Blue; Rgb( r : int, g : int, b: int )\r\n}\r\n```\r\n\r\n### rust \r\n\r\n```rust\r\nenum Color {\r\n Red,\r\n Green,\r\n Blue,\r\n Rgb { r: u8, g: u8, b: u8 }\r\n}\r\n```\r\n\r\n### Haxe \r\n\r\n```haxe\r\nenum Color {\r\n  Red;\r\n  Green;\r\n  Blue;\r\n  Rgb(r: Int, g: Int, b: Int);\r\n}\r\n```\r\n\r\n### swift\r\n\r\n\r\n```swift\r\nenum Color {\r\n  case Red, Green, Blue, Rgb(r: Int, g: Int, b: Int)\r\n}\r\n```\r\n\r\n### Elm\r\n\r\n```elm\r\ntype Color = Red | Green | Blue | Rgb { r: Int, g: Int, b: Int }\r\n```\r\n\r\n### PureScript\r\n\r\n```haskell\r\ndata Color = Red | Blue | Green | Rgb{ r :: Int, g :: Int, b :: Int }\r\n```\r\n\r\n### Haskell\r\n\r\n```haskell\r\ndata Color = Red | Green | Blue | Rgb {r :: Int, g :: Int, b :: Int}\r\n```\r\n\r\n### OCaml\r\n\r\n```ocaml\r\ntype rgb = { r: int; g: int; b: int }\r\ntype color = Red | Green | Blue | Rgb of rgb\r\n```\r\n\r\n### ReasonML\r\n\r\n```ocaml\r\ntype rgb = { r: int, g: int, b: int };\r\ntype color =\r\n  | Red\r\n  | Green\r\n  | Blue\r\n  | Rgb(rgb);\r\n```\r\n\r\n### Kotlin\r\n\r\n```kotlin\r\nsealed class Color {\r\n    object Red: Color()\r\n    object Green: Color()\r\n    object Blue: Color()\r\n    class Rgb(val r: Int,val  g: Int,val  b: Int): Color()\r\n}\r\n```\r\n\r\n### Scala\r\n\r\n```scala\r\nsealed trait Color\r\n\r\nfinal case object Red extends Color\r\nfinal case object Green extends Color\r\nfinal case object Blue extends Color\r\nfinal case class Rgb(r: Int, g: Int, b: Int) extends Color\r\n```\r\n\r\n### Dotty\r\n\r\n```scala\r\nenum Color {\r\n  case Red\r\n  case Green\r\n  case Blue\r\n  case Rgb(r: Int, g: Int, b: Int)\r\n}\r\n```\r\n\r\n### TypeScript\r\n\r\n```typescript\r\ntype Color = Red | Green | Blue | Rgb;\r\nconst enum ColorKind {\r\n  Red = \"Red\",\r\n  Green = \"Green\",\r\n  Blue = \"Blue\",\r\n  Rgb = \"Rgb\"\r\n}\r\n\r\ninterface Red {\r\n    kind: ColorKind.Red;\r\n}\r\n\r\ninterface Green {\r\n    kind: ColorKind.Green;\r\n}\r\n\r\ninterface Blue {\r\n    kind: ColorKind.Blue;\r\n}\r\n\r\ninterface Rgb {\r\n    kind: ColorKind.Rgb;\r\n    r: number;\r\n    g: number;\r\n    b: number;\r\n}\r\n```\r\n\r\n### Ruby\r\n\r\n```ruby\r\nmodule Color\r\n  Red = 1\r\n  Green = 2\r\n  Blue = 3\r\n  Rgb = Struct.new(:r, :g, :b)\r\nend\r\n```\r\n\r\n## 感想\r\n\r\n### 符号\r\n\r\n1. Koka, Rust, Haxe, Elm: 非常好\r\n2. Dotty, Swift, PureScript, Haskell, OCaml: 比较好\r\n3. Ruby: 一般\r\n4. Kotlin: 很难写\r\n5. Scala: 写起来很难\r\n\r\n## 模式匹配\r\n\r\n### Koka\r\n\r\n```haskell\r\n\r\nmatch(color) {\r\n  Red   -> \"#FF0000\"\r\n  Green -> \"#00FF00\"\r\n  Blue  -> \"#0000FF\"\r\n  Rgb(r,g,b) -> \"#\" + showHex(r,2) + showHex(g,2) + showHex(b,2)\r\n}\r\n```\r\n\r\n### Rust\r\n\r\n```rust\r\nmatch color {\r\n    Color::Red   => \"#FF0000\".to_string(),\r\n    Color::Green => \"#00FF00\".to_string(),\r\n    Color::Blue  => \"#0000FF\".to_string(),\r\n    Color::Rgb{r, g, b} => format!(\"#{:02X}{:02X}{:02X}\", r, g, b),\r\n}\r\n```\r\n\r\n### Haxe\r\n\r\n```haxe\r\nswitch( color ) {\r\n  case Red:   \"#FF0000\";\r\n  case Green: \"#00FF00\";\r\n  case Blue:  \"#0000FF\";\r\n  case Rgb(r, g, b): \"#\"+ StringTools.hex(r,2) + StringTools.hex(g,2) + StringTools.hex(b,2);\r\n}\r\n```\r\n\r\n### Swift\r\n\r\n```swift\r\nswitch color {\r\n  case .Red:\r\n    return \"#FF0000\"\r\n  case .Green:\r\n    return \"#00FF00\"\r\n  case .Blue:\r\n    return \"#0000FF\"\r\n  case let .Rgb(r, g, b):\r\n    return String(format:\"#%02X%02X%02X\", r, g, b)\r\n}\r\n```\r\n\r\n### Elm\r\n\r\n```elm\r\ncase color of\r\n    Red   -> \"#FF0000\"\r\n    Green -> \"#00FF00\"\r\n    Blue  -> \"#0000FF\"\r\n    Rgb {r, g, b} -> String.concat [\"#\", (toHex r), (toHex g), (toHex b)]\r\n```\r\n\r\n### PureScript\r\n\r\n```haskell\r\ncase color of\r\n  Red   -> \"#FF0000\"\r\n  Green -> \"#00FF00\"\r\n  Blue  -> \"#0000FF\"\r\n  Rgb { r, g, b } -> \"#\" <> toHex r <>  toHex g <>  toHex b \r\n```\r\n\r\n### Haskell\r\n\r\n```haskell\r\ncase color of\r\n    Red   -> \"#FF0000\"\r\n    Green -> \"#00FF00\"\r\n    Blue  -> \"#0000FF\"\r\n    Rgb r g b -> printf \"#%02X%02X%02X\" r g b\r\n```\r\n\r\n### OCaml\r\n\r\n```ocaml\r\nmatch color with\r\n      Red   -> \"#FF0000\"\r\n    | Green -> \"#00FF00\"\r\n    | Blue  -> \"#0000FF\"\r\n    | Rgb {r; g; b} -> Printf.sprintf \"#%02X%02X%02X\" r g b;;\r\n```\r\n\r\n### ReasonML\r\n\r\n```ocaml\r\nswitch (color) {\r\n  | Red => \"#FF000\"\r\n  | Green => \"#00FF00\"\r\n  | Blue => \"#0000FF\"\r\n  | Rgb{r, g, b} => Format.sprintf(\"#%02X%02X%02X\", r, g, b)\r\n  };\r\n```\r\n\r\n### Kotlin\r\n\r\n```kotlin\r\nwhen ( color ) {\r\n  Color.Red   -> \"#FF0000\"\r\n  Color.Green -> \"#00FF00\"\r\n  Color.Blue  -> \"#0000FF\"\r\n  is Color.Rgb -> \"#%02X%02X%02X\".format(color.r, color.g, color.b)\r\n}\r\n```\r\n\r\n### Scala\r\n\r\n```scala\r\ncolor match {\r\n  case Red   =>\"#FF0000\"\r\n  case Green =>\"#00FF00\"\r\n  case Blue  =>\"#0000FF\"\r\n  case Rgb(r, g, b) => \"#%02X%02X%02X\".format(r, g, b)\r\n}\r\n```\r\n\r\n### Dotty\r\n\r\n```scala\r\ncolor match {\r\n  case Color.Red   => \"#FF0000\"\r\n  case Color.Green => \"#00FF00\"\r\n  case Color.Blue  => \"#0000FF\"\r\n  case Color.Rgb(r, g, b) => \"#%02X%02X%02X\".format(r, g, b)\r\n}\r\n```\r\n\r\n### TypeScript\r\n\r\n```typescript\r\nswitch (color.kind) {\r\n    case ColorKind.Red: return \"#FF0000\";\r\n    case ColorKind.Green: return \"#00FF00\";\r\n    case ColorKind.Blue: return \"#0000FF\";\r\n    case ColorKind.Rgb: return \"#\" + [color.r, color.g, color.b].map((v) => v.toString(16)).join('').toUpperCase();\r\n    default:\r\n        const _exhaustiveCheck: never = color;\r\n        return _exhaustiveCheck;\r\n}\r\n```\r\n\r\n### Ruby\r\n\r\n```ruby\r\ncase color\r\nwhen Color::Red; \"#FF000\"\r\nwhen Color::Green; \"#00FF00\"\r\nwhen Color::Blue; \"#0000FF\"\r\nwhen Color::Rgb; \"#%02X%02X%02X\" % [color.r, color.g, color.b]\r\nend\r\n```\r\n\r\n## 感想\r\n\r\n### 符号\r\n\r\n1. Koka, Rust, Elm, PureScript, Haskell: 非常好\r\n2. OCaml, Kotlin: 好\r\n3. Haxe, Scala, Dotty, Ruby: 一般\r\n4. TypeScript, Swift: 很难写\r\n\r\n## 编译器的默认行为\r\n\r\n1. Rust，Haxe，Swift，Kotlin，Elm，PureScript：如果未覆盖该模式，则会出现编译错误\r\n2. Scala，Dotty，OCaml，ReasonML：即使不包含模式，编译也会在没有警告的情况下传递\r\n3. Koka，Haskell：即使不包含模式，编译也会在没有警告的情况下通过\r\n4. Ruby：外部\r\n\r\n来自： https://qiita.com/xmeta/items/91dfb24fa87c3a9f5993\r\n","source":"source\\_posts\\language-comparison.md"},{"title":"使用 Gruntjs 压缩合并前端静态资源（图片、JavaScript 和 CSS ）","description":"使用 Gruntjs 压缩合并前端静态资源（图片、JavaScript 和 CSS ）","created":"2018/05/21","author":"lanqy","link":"2018/05/21/grunt-example","htmlDir":"website\\2018\\05\\21\\grunt-example","htmlFile":"website\\2018\\05\\21\\grunt-example\\index.html","body":"\r\n# 使用 Gruntjs 压缩合并前端静态资源（图片、JavaScript 和 CSS ）\r\n### 安装环境：\r\n#### Nodejs：https://nodejs.org/en/ 安装最新版本\r\n#### 进入目录（cd projectName）\r\n#### 新建package.json 内容如下：\r\n```js\r\n{\r\n  \"name\": \"my-project-name\",\r\n  \"version\": \"0.1.0\",\r\n  \"devDependencies\": {\r\n    \"grunt\": \"^0.4.5\",\r\n    \"grunt-contrib-concat\": \"^1.0.0\",\r\n    \"grunt-contrib-cssmin\": \"^0.12.3\",\r\n    \"grunt-contrib-imagemin\": \"^1.0.0\",\r\n    \"grunt-contrib-jshint\": \"^0.12.0\",\r\n    \"grunt-contrib-nodeunit\": \"~0.4.1\",\r\n    \"grunt-contrib-uglify\": \"^0.5.1\"\r\n  }\r\n}\r\n```\r\n#### 命令行执行 ``` npm install  ```\r\n#### 接着安装grunt命令行工具 ``` npm install -g grunt-cli```\r\n#### 接着配置Gruntfile.js文件\r\n```js\r\nmodule.exports = function(grunt) {\r\n\r\n    grunt.initConfig({\r\n\r\n        //our JSHint options\r\n        jshint: {\r\n            all: ['main.js'] //files to lint\r\n        },\r\n        //our concat options\r\n        concat: {\r\n            options: {\r\n                separator: ';' //separates scripts\r\n            },\r\n            dist: {\r\n                src: ['html5/javascripts/jquery.min.js', 'html5/javascripts/dialog.js', 'html5/javascripts/utils.js','html5/javascripts/limit.js','html5/javascripts/pageScrollAjax.js','html5/javascripts/app.js','html5/javascripts/tabs.js','html5/javascripts/swiper.min.js'], //需要合并的文件，注意顺序\r\n                dest: 'html5/javascripts/build.js' //合并后生成的文件\r\n            }\r\n        },\r\n\r\n        //压缩js\r\n        uglify: {\r\n            js: {\r\n                files: {\r\n                    'html5/javascripts/build.min.js': ['html5/javascripts/build.js'] //合并后压缩\r\n                }\r\n            }\r\n        },\r\n        cssmin: {\r\n         options: {\r\n             keepSpecialComments: 0\r\n         },\r\n         compress: {\r\n             files: { // css压缩app.min.css为压缩后生成的文件,后面的数组为需要合并压缩的文件（同样注意顺序）\r\n                 'html5/stylesheets/app.min.css': [\r\n                     \"html5/stylesheets/common.css\",\r\n                     \"html5/stylesheets/swiper.min.css\",\r\n                     \"html5/stylesheets/dialog.css\",\r\n                     \"html5/stylesheets/app.css\",\r\n                     \"html5/stylesheets/new.css\",\r\n                     \"html5/stylesheets/app-type.css\"\r\n                 ]\r\n             }\r\n         }\r\n     },\r\n\r\n     imagemin: {\r\n            /* 压缩图片大小 */\r\n            dist: {\r\n                options: {\r\n                    optimizationLevel: 3 //定义 PNG 图片优化水平\r\n                },\r\n                files: [{\r\n                    expand: true,\r\n                    cwd: 'images/html5',\r\n                    src: ['**/*.{png,jpg,jpeg}'], // 优化 img 目录下所有 png/jpg/jpeg 图片\r\n                    dest: 'images/html5' // 优化后的图片保存位置，覆盖旧图片，并且不作提示（建议新建一个目录）\r\n                }]\r\n            }\r\n        }\r\n\r\n    });\r\n    //加载任务\r\n    grunt.loadNpmTasks('grunt-contrib-jshint');\r\n    grunt.loadNpmTasks('grunt-contrib-concat');\r\n    grunt.loadNpmTasks('grunt-contrib-uglify');\r\n    grunt.loadNpmTasks('grunt-contrib-cssmin');\r\n    grunt.loadNpmTasks('grunt-contrib-imagemin');\r\n\r\n    // default tasks to run\r\n    // grunt.registerTask('default', ['jshint', 'concat', 'uglify']);\r\n    grunt.registerTask('development', ['jshint']);\r\n    grunt.registerTask('production', ['jshint', 'concat', 'uglify','imagemin','cssmin']);\r\n  }\r\n\r\n\r\n```\r\n\r\n1.检查js语法```grunt jshint```\r\n\r\n2.合并js ```grunt concat```\r\n\r\n3.压缩js```grunt uglify```\r\n\r\n4.压缩css```grunt imagemin```\r\n\r\n5.压缩图片```grunt cssmin```\r\n\r\n（注意js压缩之前要先合并，也就是第一步和第二部有先后顺序）\r\n\r\n6.批量处理 ```grunt production```\r\n\r\n\r\n### 相关链接：\r\n#### Gruntjs 批量无损压缩图片大小：\r\n#### https://www.zfanw.com/blog/gruntjs-optimize-image-size-loseless.html \r\n#### 前端js和css的压缩合并之grunt：\r\n#### http://www.haorooms.com/post/qd_grunt_cssjs \r\n#### grunt官网：\r\n#### http://gruntjs.com/getting-started \r\n","source":"source\\_posts\\grunt-example.md"},{"title":"构建一个基于 Redux 的 react 应用","created":"2018/05/21","description":"构建一个基于 Redux 的 react 应用","author":"lanqy","link":"2018/05/21/build-redux-react-application","htmlDir":"website\\2018\\05\\21\\build-redux-react-application","htmlFile":"website\\2018\\05\\21\\build-redux-react-application\\index.html","body":"# 构建一个基于 Redux 的 react 应用\r\n在这篇文章里，我们将深入理解以及学习为什么开发React应用的时候，使用Redux这么重要。我也将一步一步教你如何创建你的第一个Redux应用，包括怎样使用<a href=\"https://github.com/stormpath/stormpath-sdk-react\">Stormpath React SDK </a>于<a href=\"https://stormpath.com/product/authentication/\"> user authentication（用户认证）</a>。当你完成的时候，你将掌握这个知识并运用到你已有到React应用中。\r\n\r\n###Redux是什么？\r\n\r\n<a href=\"https://github.com/reactjs/redux\">Redux</a>是一个用于帮助我们管理应用状态到的框架(library)。它的设计源于<a href=\"https://facebook.github.io/react/docs/flux-overview.html\">Flux</a>,但是从编写Flux应用的痛苦中进化而来。如果你写过Flux应用，你将很快注意到Redux可以帮你自动做很多以前你需要手动做的事情，还有，你只有一个单一的状态容器，这是一个很大的优势，这样在你的应用中共享状态和重用代码会变得更加简单。\r\n\r\n### Stores\r\n\r\nstore是一个简单的状态容器，这是存储你应用状态和actions调度和处理的地方。当你开始创建一个Redux应用时，你要想想你的应用程序的数据和状态应该如何存储。这是很重要的，因为Redux推荐一个应用只有一个store，而且由于状态是共享的，因此在开始创建应用的时候，想好这些尤为重要。\r\n\r\n### Actions\r\n\r\nActions 是一些用于描述我们怎样改变我们应用状态的对象，你可以这么认为actions就是我们状态树的API。例如，一个添加用户的action可以像这样：\r\n\r\n```javascript\r\n{\r\n  type: 'ADD_USER',\r\n  data: {\r\n    name: 'Foo',\r\n    email: 'foo@bar.com',\r\n    password: 'Foobar123_'\r\n  }\r\n}\r\n```\r\n为了让代码更清晰，更易于重用,通常是使用一个生成器(方法)生成操作对象，即，上面的例子，我们可以创建一个类似于```addUser(name, email, password) ```的函数来生成对象。如你所见，actions本身什么都不做，一个action仅仅是一个用于描述我们怎样改变我们应用状态的对象。\r\n\r\n### Reducers\r\n\r\nActions很酷，但是它们并没有太大的意义。这就是reducers存在的意义。\r\nReducers是action处理器，用于在store中调度actions以及在状态变化中简化actions操作。如果我们要在store中调度action（ADD_USER）,我们将拥有一个reducer调用action(ADD_USER)并添加一个新的用户到我们到应用状态中。\r\n### 创建Redux应用\r\n现在，当你了解的基础知识以后，让我们继续创建我们第一个基于Redux的应用程序。<br/>\r\n为了让事情变得简单，我们将要创建一个todo应用程序，这样我们可以玩转很多Redux的重要概念，而不用过多的关注应用本身。<br/>\r\n我们考虑一下一个todo应用程序，需要些什么基本的东西。首先一个todo程序，由一个列表组成。其实这个列表包含一些我们可以改变的项目。<br/>\r\n从应用的状态来看，我们可以这样定义我们的模型（model）：\r\n```javascript\r\n{\r\n  todo: {\r\n    items: [\r\n      {\r\n        message: \"Finish Redux blog post...\",\r\n        completed: false\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n### 添加 Actions\r\n\r\n我们要怎样处理我们应用的状态呢？首先，我们添加一个新待办项目到我们状态中去，让我们创建一个action来做这件事：\r\n```javascript\r\nfunction addTodo(message) {\r\n  return {\r\n    type: 'ADD_TODO',\r\n    message: message,\r\n    completed: false\r\n  };\r\n}\r\n```\r\n注意```type```这个字段，这个必须是唯一的，用于表明action的意图。\r\ntype字段的约定格式为大写字母，并且每个单词以下划线作为分隔，接下来你将使用这个名字／标示符在你的reducers中来处理具体的actions，并把它们变成可变的状态。<br/>\r\n一旦我们增加了我们的待办事项，我们肯定希望能够将其标记为已完成状态，我们也可以删除它，可以清空所有的待办项目。<br/>\r\n因此让我们创建actions来做这些事情：\r\n```javascript\r\nfunction completeTodo(index) {\r\n  return {\r\n    type: 'COMPLETE_TODO',\r\n    index: index\r\n  };\r\n}\r\n\r\nfunction deleteTodo(index) {\r\n  return {\r\n    type: 'DELETE_TODO',\r\n    index: index\r\n  };\r\n}\r\n\r\nfunction clearTodo() {\r\n  return {\r\n    type: 'CLEAR_TODO'\r\n  };\r\n}\r\n```\r\n到目前为止，我们已经定义好我们的actions，让我们继续定义我们的store，如前所述，store是Redux应用的核心，所有的状态(state)、调度器(dispatched actions)、reducers都依赖于它。\r\n```javascript\r\nimport { createStore } from 'redux';\r\n\r\nvar defaultState = {\r\n  todo: {\r\n    items: []\r\n  }\r\n};\r\n\r\nfunction todoApp(state, action) {\r\n}\r\n\r\nvar store = redux.createStore(todoApp, defaultState);\r\n```\r\n### 添加Reducers\r\n现在，我们已经拥有一些actions和一个store。让我们创建我们的第一个reducer，如前所述，reducer仅仅是一个action处理器，拥有处理actions和改变应用的状态（state）。\r\n让我们先处理我们的```ADD_TODO``` action，如下所示：\r\n```javascript\r\nfunction todoApp(state, action) {\r\n  switch (action.type) {\r\n    case 'ADD_TODO':\r\n      var newState = Object.assign({}, state);\r\n\r\n      newState.todo.items.push({\r\n        message: action.message,\r\n        completed: false\r\n      });\r\n\r\n      return newState;\r\n\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n```\r\n注意，当我们说一个reducer“改变”了应用的状态，如果一个状态需要改变，我们真正要做的是创建一个状态（state）的副本，并修改这个状态的副本。如果状态没有改变,那我们就返回相同的状态。任何情况下，如果你直接修改原始的状态（state），这意味着你将改变状态的历史。<br/>\r\n现在我们有了第一个我们的action处理器，让我们添加其它的：<br/>\r\n```javascript\r\nfunction todoApp(state, action) {\r\n  switch (action.type) {\r\n    case 'ADD_TODO':\r\n      var newState = Object.assign({}, state);\r\n\r\n      newState.todo.items.push({\r\n        message: action.message,\r\n        completed: false\r\n      });\r\n\r\n      return newState;\r\n\r\n    case 'COMPLETE_TODO':\r\n      var newState = Object.assign({}, state);\r\n\r\n      newState.todo.items[action.index].completed = true;\r\n\r\n      return newState;\r\n\r\n    case 'DELETE_TODO':\r\n      var items = [].concat(state.todo.items);\r\n\r\n      items.splice(action.index, 1);\r\n\r\n      return Object.assign({}, state, {\r\n        todo: {\r\n          items: items\r\n        }\r\n      });\r\n\r\n    case 'CLEAR_TODO':\r\n      return Object.assign({}, state, {\r\n        todo: {\r\n          items: []\r\n        }\r\n      });\r\n\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n```\r\n###结合React UI\r\n现在，我们已经制定了业务逻辑，让我们写一些UI代码，由于大部分React的知识都跟构建Flux应用类似，我们就不再深入讲解。一下是我们的代码：\r\n```js\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport { createStore } from 'redux';\r\n\r\nvar defaultState = {\r\n  todo: {\r\n    items: []\r\n  }\r\n};\r\n\r\n// Add the actions here that we created in the previous steps...\r\n\r\nfunction todoApp(state, action) {\r\n  // Add the reducer logic that we added in the previous steps...\r\n}\r\n\r\nvar store = createStore(todoApp, defaultState);\r\n\r\nclass AddTodoForm extends React.Component {\r\n  state = {\r\n    message: ''\r\n  };\r\n\r\n  onFormSubmit(e) {\r\n    e.preventDefault();\r\n    store.dispatch(addTodo(this.state.message));\r\n    this.setState({ message: '' });\r\n  }\r\n\r\n  onMessageChanged(e) {\r\n    var message = e.target.value;\r\n    this.setState({ message: message });\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <form onSubmit={this.onFormSubmit.bind(this)}>\r\n        <input type=\"text\" placeholder=\"Todo...\" onChange={this.onMessageChanged.bind(this)} value={this.state.message} />\r\n        <input type=\"submit\" value=\"Add\" />\r\n      </form>\r\n    );\r\n  }\r\n}\r\n\r\nclass TodoItem extends React.Component {\r\n  onDeleteClick() {\r\n    store.dispatch(deleteTodo(this.props.index));\r\n  }\r\n\r\n  onCompletedClick() {\r\n    store.dispatch(completeTodo(this.props.index));\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <li>\r\n        <a href=\"#\" onClick={this.onCompletedClick.bind(this)} style=>{this.props.message.trim()}</a>&nbsp;\r\n        <a href=\"#\" onClick={this.onDeleteClick.bind(this)} style=>[x]</a>\r\n      </li>\r\n    );\r\n  }\r\n}\r\n\r\nclass TodoList extends React.Component {\r\n  state = {\r\n    items: []\r\n  };\r\n\r\n  componentWillMount() {\r\n    store.subscribe(() => {\r\n      var state = store.getState();\r\n      this.setState({\r\n        items: state.todo.items\r\n      });\r\n    });\r\n  }\r\n\r\n  render() {\r\n    var items = [];\r\n\r\n    this.state.items.forEach((item, index) => {\r\n      items.push(<TodoItem\r\n        key={index}\r\n        index={index}\r\n        message={item.message}\r\n        completed={item.completed}\r\n      />);\r\n    });\r\n\r\n    if (!items.length) {\r\n      return (\r\n        <p>\r\n          <i>Please add something to do.</i>\r\n        </p>\r\n      );\r\n    }\r\n\r\n    return (\r\n      <ol>{ items }</ol>\r\n    );\r\n  }\r\n}\r\n\r\nReactDOM.render(\r\n  <div>\r\n    <h1>Todo</h1>\r\n    <AddTodoForm />\r\n    <TodoList />\r\n  </div>,\r\n  document.getElementById('container')\r\n);\r\n```\r\n如你所见，为Redux应用构建我们的UI并不难，唯一不同的是使用```store.subscribe(listener)```来监听状态(state)的改变，然后通过```store.getState()```获取状态。但除此之外，它非常像构建Flux应用。\r\n\r\n### 在Stormpath React SDK中支持Redux\r\n因为有不少请求为Stormpath React SDK添加Redux支持，因此我们实现了这个功能，如果你想配置SDK来使用Redux，简单配置dispatcher选项并设置几个type和redux指向store，具体如下:\r\n```javascript\r\nfunction myApp(state, action) {\r\n  return state;\r\n}\r\n\r\nReactStormpath.init({\r\n  dispatcher: {\r\n    type: 'redux',\r\n    store: createStore(myApp)\r\n  }\r\n});\r\n```\r\n一旦做到这一点，我们就可以通过Stormpath React SDK拦截和处理我们的actions调度，例如，如果你希望通过用户数据来丰富你的状态，那么简单地处理```USER_SET```action来添加用户数据到你的状态中。\r\n```javascript\r\nfunction myApp(state, action) {\r\n  switch (action.type) {\r\n    case 'USER_SET':\r\n      return Object.assign({}, state, {\r\n        user: action.data\r\n      });\r\n\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n```\r\n###总结\r\n正如你在文章中所看到的一样，构建一个Redux应用是非常简单和直接的。这就像是构建Flux应用一样，仅仅是概念上的差异，并且手动写的代码变得更少。希望你们喜欢这个教程，并且发现未来你可以使用它。如果有任何问题，请参考github上的<a href=\"https://github.com/typerandom/stormpath-react-redux-todo-example-application\" target=\"_blank\">项目</a>。<br/>\r\n###扩展阅读\r\n想要学习更多关于给React应用添加用户认证，请看以下教程：\r\n* <a href=\"https://stormpath.com/blog/build-a-react-app-with-user-authentication/\">Tutorial: Build a React.js Application With User Authentication</a>\r\n* <a href=\"https://stormpath.com/blog/react-sdk-custom-forms/\">Custom Login and Registration Forms</a>\r\n\r\n注：本文翻译自<a href=\"https://stormpath.com/blog/build-a-redux-powered-react-application/\" target=\"_blank\">Let's Build a Redux Powered React Application</a>,如有翻译不对的地方请指正。谢谢！\r\n","source":"source\\_posts\\build-redux-react-application.md"},{"title":"给 create-react-app 创建的项目，加上热加载功能","created":"2018/05/21","description":"给 create-react-app 创建的项目，加上热加载功能","author":"lanqy","link":"2018/05/21/adding-hot-module-reloading-to-create-react-app","htmlDir":"website\\2018\\05\\21\\adding-hot-module-reloading-to-create-react-app","htmlFile":"website\\2018\\05\\21\\adding-hot-module-reloading-to-create-react-app\\index.html","body":"# 给 create-react-app 创建的项目，加上热加载功能\r\n\r\n修改index.js文件\r\n\r\n```js\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\nimport './index.css';\r\nconst rootEl = document.getElementById('root');\r\nReactDOM.render(\r\n  <App />,\r\n  rootEl\r\n);\r\nif (module.hot) { //热替换代码\r\n  module.hot.accept('./App', () => {\r\n    const NextApp = require('./App').default;\r\n    ReactDOM.render(\r\n      <NextApp />,\r\n      rootEl\r\n    );\r\n  }); \r\n}\r\n```\r\n\r\n来自 ：https://medium.com/@sheepsteak/adding-hot-module-reloading-to-create-react-app-e053fadf569d#.jn5jammd4\r\n","source":"source\\_posts\\adding-hot-module-reloading-to-create-react-app.md"},{"title":"React 生态系统入门第一部分（共三个部分）","created":"2016/07/14","description":"React 生态系统入门第一部分（共三个部分）","author":"lanqy","link":"2016/07/14/a-primer-on-the-react-rcosystem-part1","htmlDir":"website\\2016\\07\\14\\a-primer-on-the-react-rcosystem-part1","htmlFile":"website\\2016\\07\\14\\a-primer-on-the-react-rcosystem-part1\\index.html","body":"\r\n# React1 生态系统入门第一部分（共三个部分）\r\n\r\n\r\n译自: http://patternhatch.com/2016/07/06/a-primer-on-the-react-ecosystem-part-1-of-3/\r\n\r\n\r\n- <a href=\"#user-content-update\">更新</a>\r\n- <a href=\"#user-content-introduction\">介绍</a>\r\n- <a href=\"#user-content-installment\">这一期中</a>\r\n- <a href=\"#user-content-prerequisite\">先决条件</a>\r\n- <a href=\"#user-content-code\">代码</a>\r\n- <a href=\"#user-content-description\">项目描述</a>\r\n- <a href=\"#user-content-creation\">创建项目</a>\r\n- <a href=\"#user-content-webpack\">Webpack</a>\r\n- <a href=\"#user-content-babel\">Babel</a>\r\n- <a href=\"#user-content-hot\">热模块更换</a>\r\n- <a href=\"#user-content-component\">第一个React组件</a>\r\n\r\n<h4 id=\"user-content-update\">更新</h4>\r\n<p>2016.07.06: 第一次发布</p>\r\n<h4 id=\"user-content-introduction\">介绍</h4>\r\n<p>过去8个月，我一直在工作中使用React生态系统，我们创建应用来监控我们的交易状态，编辑我们的交易风险检查和控制我们的战略。</p>\r\n<p>它证明了梦幻般的生态系统，鉴于其组合的性质和平易近人的学习曲线，React几乎已经成为提供一个消费级的企业级用户界面的有趣交付物。</p>\r\n<p>我想通过一个入门的教程 分享我的学习经验，通过这个入门你将学习到：</p>\r\n\r\n- 配置开发React应用的环境 \r\n- 创建React组件并让他们对数据变化做出反应\r\n- 通过Redux管理应用的状态\r\n\r\n<p>如果你是第一次接触React生态系统，我希望通过这个入门教程，你将很轻松的开始创建你的React应用</p>\r\n<h4 id=\"user-content-installment\">在这一期中</h4>\r\n<p>在第一部分中，我们将会配置一个基本的React开发环境，在文章的末尾，你将拥有一个创建应用和动态重载的开发环境，当你的文件发生改变的时候，我们也会创建我们的的第一个React组件\r\n</p>\r\n\r\n<h4 id=\"user-content-prerequisite\">先决条件</h4>\r\n<p>我假设你已经熟悉Node和NPM并且已经安装好这两个工具。你还应该熟悉(Javascript)ES6。你不需要是ES6专家，但是知道主要的新功能如箭头函数和解构赋值。</p>\r\n<p>写这篇文章的时候，我使用的是Node6.2.0和NPM3.8.9版本</p>\r\n<h4 id=\"user-content-code\">代码</h4>\r\n<p>你可以在这里找到第一部分的所有代码，每个部分将有自己的分支</p>\r\n<h4 id=\"user-content-description\">项目描述</h4>\r\n<p>我们将要创建一个应用依托于Spotify的后台，我们的应用将允许用户：</p>\r\n\r\n- 检索艺术家的专辑\r\n- 检索给定专辑的曲目\r\n- 播放曲目开头30秒\r\n\r\n<p>以下是一个样本：</p>\r\n<img src=\"/images/mockup.png\" />\r\n<p>使用Spotify的后台，这样我们可以把更多的注意力集中放在前端开发上。</p>\r\n\r\n<h4 id=\"user-content-creation\">创建项目</h4>\r\n<p>让我们开始创建我们的项目</p>\r\n\r\n```js\r\nmkdir respotify\r\ncd respotify\r\nnpm init -y\r\n```\r\n<p>这个将在我们的根目录下创建一个package.json文件</p>\r\n<p>下一步，在根目录下创建一个src目录,在src目录中创建一个index.html文件：</p>\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <title>Respotify</title>\r\n  </head>\r\n  <body>\r\n    <h1>Respotify</h1>\r\n    <div id=\"user-content-container\"></div>\r\n    <script src=\"/bundle.js\"></script>\r\n  </body>\r\n</html>\r\n```\r\n<p>index.html是我们应用的入口，其中有两行代码比较有趣:</p>\r\n\r\n```html\r\n <div id=\"user-content-container\"></div>\r\n  <script src=\"/bundle.js\"></script>\r\n```\r\n<p>我们的React组件将渲染到id为container的div中，这个将会更加清晰，通过这个编文章</p>\r\n<p>构建的时候，我们要放在一起将所有的JS文件合并成一个文件bundle.js，并且在index.html引用它</p>\r\n<p>下一步，创建index.js：</p>\r\n\r\n```js\r\nconsole.log(\"Hello,world!\");\r\n```\r\n<p>index.js是我们的应用程序的主要的Javascript文件，现在，我们仅仅打印一些日志，以确保我们的构建正常工作。</p>\r\n\r\n这个时候，我们的目录结构应该像这样：\r\n\r\n```js\r\nrespotify\r\n -src\r\n  --index.html\r\n  --index.js\r\n --package.json\r\n```\r\n\r\n<h4 id=\"user-content-webpack\">Webpack</h4>\r\n<p>现在好了，我们将从头开始组建我们的构建环境，你可能听说过很多开发样本，例如<a href=\"https://github.com/kriasoft/react-starter-kit\">这里</a>提供了完整的开发配置环境，虽然这个很有用，但是我觉得至少自己会创建基本的配置，这样你才知道主要的东西是如何工作的</p>\r\n<p>我们从<a href=\"https://webpack.github.io/\">Webpack</a>开始构建我们的环境，简单地说，Webpack为我们打包静态资源，虽然有很多不同类型的打包工具，但是Webpack提供的一些功能，获得React社区的青睐，我们只是使用其中的一部分。</p>\r\n<p>让我们开始安装Webpack：</p>\r\n\r\n```js\r\nnpm install webpack --save-dev\r\n```\r\n<p>一旦安装完整，检查package.json文件Webpack是否在你的dev依赖。</p>\r\n<p>我们使用Webpack做两件事：</p>\r\n- 获取我们的应用程序代码，并从代码中生成静态资源\r\n- 启动一个开发服务器来服务静态资源\r\n\r\n<p>因为Webpack是配置驱动的，我们就从这里开始，在根目录下创建一个webpack.config.js文件：</p>\r\n\r\n```js\r\nconst webpack = require('webpack'); // line 1\r\nconst path = require('path');// line 2\r\n // line 3\r\nconst PATHS = { // line 4\r\n  app: './src/index.js', // line 5\r\n  dist: path.join(__dirname, 'dist') // line 6\r\n}; // line 7\r\n // line 8\r\nmodule.exports = { // line 9\r\n  entry: { // line 10\r\n    javascript: PATHS.app // line 11\r\n  }, // line 12\r\n  output: { // line 13\r\n    path: PATHS.dist, // line 14\r\n    publicPath: '/', // line 15\r\n    filename: 'bundle.js' // line 16\r\n  }, // line 17\r\n  devServer: { // line 18\r\n    contentBase: PATHS.dist // line 19\r\n  } // line 20\r\n}; // line 21\r\n```\r\n<p>让我们继续</p>\r\n<p>在webpack.config.js文件顶部，我们引用webpack和path模块，然后为我们的应用程序定义几个常量</p>\r\n<p>[第9行] 这个是我们Webpack配置的开始</p>\r\n<p>[第10行] 这里最终成为我们bundle.js文件的<a href=\"https://webpack.github.io/docs/configuration.html#entry\">入口</a>，在这个例子中，我们有一个单独的JS文件（index.js）服务，做为我们的入口文件，Webpack将构建index.js以及任何其他JS文件在index.js中声明依赖的，与依赖那些依赖等，最终合成一个单一的bundle.js文件。想象一下一个依赖折叠成一个节点的图形。</p>\r\n<p>[第13行] <a href=\"https://webpack.github.io/docs/configuration.html#output\">这里</a>是我们设置的配置文件。在这个例子中，我们告诉Webpack：</p>\r\n- 输出其编译结果到dist目录下\r\n- 将输出的文件的网址设置为首页路径\r\n- 调用其编译的bundle.js结果\r\n\r\n<p>[第18行] 这里我们制定Webpack服务器从dist目录下请求静态资源目录。</p>\r\n<p>现在尝试在您的终端运行此命令（确保您在您的项目的根目录和节点在您的路径下）：</p>\r\n\r\n```js\r\nnode node_modules/webpack/bin/webpack.js\r\n```\r\n<p>你将看到已经在根目录下创建一个dist目录，目录中有一个bundle.js文件在里面。</p>\r\n\r\n<p>如果你看看bundle.js,你将看到一些Webpack特定的方法和一个console.log声明在文件底部。</p>\r\n\r\n<p>这个时候，您的项目目录结构看起来应该像这样：</p>\r\n\r\n```js\r\nRespotify\r\n-dist\r\n --bundle.js\r\n-node_modules\r\n-src\r\n --index.html\r\n --index.js\r\n--package.json\r\n--webpack.config.js\r\n```\r\n<p>现在我们也需要提供引用bundle.js的index.html文件，这个文件目前不在我们的dist目录下，因此我们需要复制index.html到dist目录下。</p>\r\n<p>要实现这个，我们需要安装文件加载程序包，安装方式如下：</p>\r\n\r\n```js\r\nnpm install file-loader --save-dev\r\n```\r\n<p>我们将修改webpack.config.js文件来引用index.html文件，我们还将包括一个模块对象来指定我们的第一个<a href=\"https://webpack.github.io/docs/loaders.html\">加载程序</a>。本质上，加载器就是加载或预编译运行的文件，在这种情况下，我们使用文件<a href=\"https://github.com/webpack/file-loader\">加载</a>复制index.html来输出（dist）目录，添加以下高亮的行到webpack.config.js文件中：</p>\r\n\r\n```js\r\nconst webpack = require('webpack');\r\nconst path = require('path');\r\n \r\nconst PATHS = {\r\n  app: './src/index.js',\r\n  html: './src/index.html', // 高亮行\r\n  dist: path.join(__dirname, 'dist')\r\n};\r\n \r\nmodule.exports = {\r\n  entry: {\r\n    javascript: PATHS.app,\r\n    html: PATHS.html // 高亮行\r\n  },\r\n  output: {\r\n    path: PATHS.dist,\r\n    publicPath: '/',\r\n    filename: 'bundle.js'\r\n  },\r\n  devServer: {\r\n    contentBase: PATHS.dist\r\n  },\r\n  // 高亮部分\r\n  module: { \r\n    loaders: [\r\n      {\r\n        test: /\\.html$/,\r\n        loader: \"file?name=[name].[ext]\"\r\n      }\r\n    ]\r\n  }\r\n  // 高亮部分\r\n};\r\n```\r\n\r\n<p>现在我们再次运行之前的命令：</p>\r\n\r\n```js\r\nnode node_modules/webpack/bin/webpack.js\r\n```\r\n\r\n你应该看到index.html已经复制到dist目录项了，dist目录现在应像这样：\r\n\r\n```js\r\ndist\r\n--bundle.js\r\n--index.html\r\n```\r\n\r\n我们在开发的过程中，我们需要重新编译bundle.js，每次修改代码都要重新在命令行编译Webpack必然很乏味，如果我们要创建一个在我们修改代码的时候可以自动编译和刷新浏览器实时看到效果，我们该怎样做呢？\r\n\r\n这个时候就应该使用<a href=\"https://webpack.github.io/docs/webpack-dev-server.html\">Webpack dev server</a>了,让我们来安装它：\r\n\r\n```js\r\nnpm install webpack-dev-server --save-dev\r\n```\r\n\r\n一旦安装完成，我们运行一下命令：\r\n\r\n```js\r\nnode node_modules/webpack-dev-server/bin/webpack-dev-server.js\r\n```\r\n\r\n这将启动开发服务器在:<a href=\"http://localhost:8080/webpack-dev-server/\">http://localhost:8080/webpack-dev-server/</a>\r\n\r\n如果您访问这个链接，你应该会看到我们的应用：\r\n\r\n<img src=\"/images/respotify_initial_dev.png\" />\r\n\r\n试着去修改index.html文件中的h1标签并且保存它，webpack开发服务器将自动检测并重新加载。每次重新加载你也会看到控制台输出日志。因此现在我们有一个webpack服务器，服务我们的静态资源和重新加载当有代码有修改的时候。\r\n\r\n让我们完善一下我们的package.json文件，创建一些脚本，以至于我们更方便处理一些事情。\r\n\r\n添加以下高亮行package.json的脚本对象中：\r\n\r\n```js\r\n\"scripts\": {\r\n  \"start\": \"node node_modules/webpack-dev-server/bin/webpack-dev-server.js\", // 高亮\r\n  \"build\": \"node node_modules/webpack/bin/webpack.js\", // 高亮\r\n  \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n},\r\n```\r\n如果你没有停止webpack开发服务器，停掉它然后运行用一下命令运行Webpack开发服务：\r\n\r\n```js\r\nnpm run start\r\n```\r\n\r\n使用一下命令构建:\r\n\r\n```js\r\nnpm run build\r\n```\r\n\r\n这个时候，我们基本的构建已经完成，下一步，我们将扩大我们的构建过程，允许我们使用最新的ES6功能。\r\n\r\n\r\n<h4 id=\"user-content-babel\">Babel</h4>\r\n\r\n<a href=\"https://kangax.github.io/compat-table/es6/\">ES6支持</a>各种不同的浏览器，因此这样使用所有的ES6功能，不需要考虑各个浏览器的兼容性呢？一个解决方案就是把ES6代码转成ES5，这正是我们接下来要做的。\r\n\r\n我们将使用<a href=\"http://babeljs.io/\">Babel</a>来做这个事情,我们需要Babel来做两件事：\r\n\r\n- 转ES6代码到ES5\r\n- 转<a href=\"https://facebook.github.io/react/docs/jsx-in-depth.html\">JSX</a>成JavaScript。JSX是React DSL，类似HTML。你将学习它，当你开始React开发的时候。\r\n\r\n开始安装这些Babel包：\r\n\r\n```js\r\nnpm install babel-core babel-loader babel-preset-es2015 babel-preset-react --save-dev\r\n```\r\n\r\n让我们看看每个包都干嘛的：\r\n\r\n- <a href=\"https://github.com/babel/babel/tree/master/packages/babel-core\">babel-core</a> Babel核心编译器。\r\n- <a href=\"https://github.com/babel/babel-loader\">babel-loader</a> Webpack的Babel加载器。\r\n- <a href=\"https://babeljs.io/docs/plugins/preset-es2015/\">preset-es2015</a> 一套ES6转ES5的Babel插件。\r\n- <a href=\"https://babeljs.io/docs/plugins/preset-react/\">babel-preset-react</a> 一套JSX转成JS的Babel插件。\r\n\r\n在开始结合Babel之前，让我们来改改index.js，让它包含以下ES6代码，修改之后看起来像这样：\r\n\r\n```js\r\nconst greeting = (name) => {\r\n  console.log(`Hello, ${name}!`);\r\n};\r\ngreeting('world');\r\n```\r\n\r\n现在执行 npm run build命令，看看文件bundle.js底部，你应该可以看到之前定义的原始的ES6方法，没有任何变化，考虑到这一点，让我们结合Babel。\r\n\r\n第一，我们将添加babel-loader到我们的webpack.config.js文件中，回想一下，我们如何使用文件加载器将index.html文件复制到dist目录中，我们现在为Babel添加第二个加载对象，添加一下高亮行到你到module对象中：\r\n\r\n```js\r\nmodule: {\r\n  loaders: [\r\n    {\r\n      test: /\\.html$/,\r\n      loader: \"file?name=[name].[ext]\"\r\n    },\r\n    //高亮部分\r\n    { \r\n      test: /\\.js$/,\r\n      exclude: /node_modules/,\r\n      loaders: [\"babel-loader\"]\r\n    }\r\n    //高亮部分\r\n  ]\r\n}\r\n\r\n```\r\n\r\n这里，我们要求Webpack应用babel-loader在所有以.js为后缀到并且不在node_modules文件夹中的文件。\r\n\r\n下一步，我们在项目根目录中创建一个.babelrc文件，内容如下：\r\n\r\n```js\r\n{\r\n\"presets\":[\"react\",\"es2015\"]\r\n}\r\n```\r\n\r\n这里要求Babel使用前面我们安装的<a href=\" presets\"> presets</a>。\r\n\r\n就这样。\r\n\r\n再一次执行 npm run build 和检查bundle.js，我们的greeting 方法现在应该转成了ES5。\r\n\r\n好，我们几乎已经完成了，下一步我们要做的就是重新加载React组件，当我们做改动的时候，不会丢失状态信息。\r\n\r\n<h4 id=\"user-content-hot\">热模块更换</h4>\r\n\r\n让我们开始安装<a href=\"https://facebook.github.io/react/\">React</a>和<a href=\"https://facebook.github.io/react/docs/top-level-api.html#reactdom\">ReactDOM</a>，以及<a href=\"https://gaearon.github.io/react-hot-loader/\">React Hot Loader</a>。注意我们安装React和ReactDOM作为正常的依赖，而React Hot Loader作为开发依赖。安装方式如下：\r\n\r\n```js\r\nnpm install react react-dom --save\r\n```\r\n\r\n```js\r\nnpm install react-hot-loader --save-dev\r\n```\r\n下一步，我们让webpack使用热更换，打开webpack.config.js修改babel-loader像这样：\r\n\r\n```js\r\nloaders:[\"react-hot\",\"babel-loader\"]\r\n```\r\n重要的是，React-hot被添加为webpack过程从右到左的之前。\r\n\r\n下一步，打开package.json编辑 start npm脚本如下：\r\n\r\n```js\r\n\"start\": \"node node_modules/webpack-dev-server/bin/webpack-dev-server.js --hot --inline\",\r\n```\r\n\r\n在这一点上，我们进一步加强我们的开发配置重新加载React组件而状态不丢失，但是这个意味着什么呢？要回答这一问题，我们需要创建一个React组件来测试我们的配置。\r\n\r\n<h4 id=\"user-content-component\">我们的第一个React组件</h4>\r\n\r\n在src目录下创建一个greeting.js:\r\n\r\n```js\r\nimport React from \"react\"; //第1行\r\n \r\nexport default React.createClass({ //第3行\r\n  render: function() {//第4行\r\n    return ( //第5行\r\n      <div className=\"greeting\">\r\n        Hello, {this.props.name}!\r\n      </div>\r\n    ); //第9行\r\n  }\r\n});\r\n```\r\n\r\n我们刚刚创建我们的第一个React组件，让我们一行一行来看。\r\n\r\n［第一行］在顶部，我们导入React。\r\n\r\n［第三行］我们通过<a href=\"https://facebook.github.io/react/docs/top-level-api.html#react.createclass\">React.createClass方法</a>创建一个React组件类，传入一个描述我们组件的规范对象。\r\n\r\n［第四行］每个React组件都必须有一个render方法，它返回组件的标记。\r\n\r\n［第五－九行］在render方法里，我们返回一个类HTML 包含一个class名称为gretting的div 包裹这一个字符串，字符串本身把Hello和一些引用值连接起来。\r\n\r\n我们将继续深入理解第五－九行，但是现在，让我们先把这个组件在屏幕上展示出来。\r\n\r\n打开index.js修改它如下:\r\n\r\n```js\r\nimport React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport Greeting from './greeting';\r\n \r\nReactDOM.render(\r\n  <Greeting name=\"World\"/>,\r\n  document.getElementById('container')\r\n);\r\n```\r\n我们再一次从导入React开始，接着我们导入ReactDOM，用于渲染DOM的API接口，我们也导入我们的greeting component。\r\n\r\n当我们调用ReactDOM的render方法时，我们传入两个参数：\r\n\r\n- 1.我们需要渲染的组件。\r\n- 2.我们要把组件渲染到的位置。\r\n\r\n在我们的例子中，我们将渲染我们的greeting组件到一个id为container的div中，这个div在我们的index.html中。\r\n\r\n注意第一个参数是怎么样子的，我们传入greeting组件，它好像是一个HTML元素，它包含了一个键值对，其中键的名字为name，值为world。然后name就成为我们greeting组件的属性。\r\n\r\n大体上，我们可以这么描述index.js：\r\n\r\n<strong>渲染greeting组件，把world赋给它的name属性，把这个组件渲染到id为container的div上。</strong>\r\n\r\n现在，当我们渲染greeting组件时，我们将接收name属性和包含它的值的字符串，重启开发服务并验证这个组件渲染：\r\n\r\n<img src=\"/images/respotify_first_component.png\" />\r\n\r\n测试它的重载，试着用h1标签包裹字符串，如下：\r\n\r\n```js\r\n<h1>Hello, {this.props.name}!</h1>\r\n```\r\n\r\n保存它，你将看到组件局部更新，而不需要全部重新加载。\r\n\r\n现在，让我们退后一步，重新看greeting.js代码片段：\r\n\r\n```js\r\n return (\r\n      <div className=\"greeting\">\r\n        Hello, {this.props.name}!\r\n      </div>\r\n    );\r\n```\r\n\r\n我们返回的标记实际上是JSX，一个React特定的DSL，就像HTML用方便描述树结构。我们的Babel配置会把JSX转换成等效的纯JavaScript。有两个重要的概念要记住：\r\n\r\n- JSX不是JavaScript的扩展。\r\n- JSX不是必须的，你可以使用纯JavaScript的调用方式代替。\r\n\r\n要展示第二点，我们使用<a href=\"http://babeljs.io/repl/\"> Babel REPL</a>,在REPL中，确保选中ES2015 和 React preset这两个选项，复制greeting.js的内容到左侧的编辑器中，你会看到转换输出到右侧，一个代码片段类似这样：\r\n\r\n```js\r\n<div className=\"greeting\" />\r\n```\r\n\r\n将转换为：\r\n\r\n```js\r\n_react2.default.createElement(\"div\", { className: \"greeting\" });\r\n```\r\n\r\n以上的纯JavaScript你可以直接使用，然而，我强烈推荐使用JSX，这个让你的React组件方便阅读和书写。事实上，它看起来像HTML也有助于减少学习曲线，当然，由于JSX是JavaScript，跟HTML有一些细微的差异，比如JSX的className和HTML的class，我们将深入理解更多JSX的功能，可以去看看Facebook的指南了解更多的东西。\r\n\r\n让我们把注意力放在div中的这行代码：\r\n\r\n```js\r\n Hello, {this.props.name}!\r\n```\r\n\r\n在JSX中，用花括号括起来的是一个JavaScript表达式，因此，在这里，我们访问这个组件的props对象，反过来，在props上访问name属性。\r\n\r\n还记得在index.js中的这一行代码吗？\r\n\r\n```js\r\n<Greeting name=\"World\"/>\r\n```\r\n\r\n当你实例化一个组件，你可以传入大量的表示该组件状态的键值对。因此，当我们实例化我们的greeting组件，我们也应该指定一个名为name的状态。这个值的状态叫做“world”。\r\n\r\n\r\n在实际的greeting组件中，该状态通过组件的props对象和使用相同的name标签来传递。花括号里的值被计算，并且返回“Hello，world”渲染到浏览器中。\r\n\r\n记住主要的一点，就是props是不可变的。换句话说，一旦状态被传递到一个组件，接受组件就不能再改变它了。这样有助于你的组件更容易理解和调试。以及将状态管理分离到几个模块中。\r\n\r\n试着在index.js中修改name的值。你将看到Webpack检测变化和自动加载，greeting组件将接收到新的状态，并作出响应。\r\n\r\n\r\n如果你跟着一起做下来，并且一切都正常工作，那么恭喜你！你刚刚构建了一个基于打包、转换、热更新的React应用开发环境。此外，你还创建了一个React组件，记住，你可以添加更多的环境，比如压缩文件，选择性打包，启用和禁用各种开发工具。但是对于我们而言，这样已经够了。\r\n\r\n在下一部分中，我们将进一步创建更多的React组件来完善我们的Spotify客户端，我们还将添加静态分析来保持我们的代码整洁明了。\r\n\r\n预计下一部分会在这一期发布之后的两个星期内完成。在此之前，如果你有任何意见和建议，请在下面留言或者给我发<a href=\"http://patternhatch.com/about/\">邮件</a>。\r\n\r\n\r\n\r\n","source":"source\\_posts\\a-primer-on-the-react-rcosystem-part1.md"}],"pages":[{"title":"关于","description":"关于","author":"lanqy","htmlDir":"website\\about","link":"/about","htmlFile":"website\\about\\index.html","body":"# 关于\r\n\r\n### 本站\r\n\r\n> 思绪偶尔会停留在这里  :)\r\n\r\n看过的东西 过段时间就忘了。于是建了这个网站，主要用于记录平时看到的文章，翻译一些外文，还有平时的学习笔记。\r\n\r\n### 我\r\n\r\n实用主义者、前端开发工程师。\r\n\r\n工作中主要使用 HTML / CSS / JavaScript / Nodejs 构建 Web 应用程序。\r\n\r\n喜欢静态类型的函数式编程语言 OCaml 、 F#。","source":"source\\about.md"}]}